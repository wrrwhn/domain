---
title: "Regex"
date: "2016-12-08"
categories:
 - "整理"
tags:
 - "Regex"
toc: true
---


## 元字符
- `.`    匹配除换行符以外的任意字符
- `\w`    匹配字母或数字或下划线或汉字
- `\s`    匹配任意的空白符
- `\d`    匹配数字
- `\b`    匹配单词的开始或结束
- `^`    匹配字符串的开始
- `$`    匹配字符串的结束

## 字符转义
- 想查找元字符本身的话，使用\来取消这些字符的特殊意义

## 重复
- `*`        重复零次或更多次
- `+`        重复一次或更多次
- `?`        重复零次或一次
- `{n}`        重复n次
- `{n,}`    重复n次或更多次
- `{n,m}`    重复n到m次

## 字符类
- `[aeiou]`    就匹配任何一个英文元音字母
- `[.?!]`        匹配标点符号(.或?或!)
- `[a-z0-9A-Z_]`

## 分枝条件
- `\d{5}-\d{4}|\d{5}`    5-4或5位数值

## 分组
- 以小括号指定的即为分组
```((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)```

## 反义
- `\W`            匹配任意不是字母，数字，下划线，汉字的字符
- `\S`            匹配任意不是空白符的字符
- `\D`            匹配任意非数字的字符
- `\B`            匹配不是单词开头或结束的位置
- `[^x]`        匹配除了x以外的任意字符
- `[^aeiou]`    匹配除了aeiou这几个字母以外的任意字符

## 零宽断言
- 查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言
    + `(?=exp)`也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。
    + `(?<=exp)`也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。

## 负向零宽断言
- 零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；`\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词。
    +`(?<=<(\w+)>).*(?=<\/\1>)`匹配不包含属性的简单HTML标签内里的内容。`(?<=<(\w+)>)`指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是`.*`(任意的字符串),最后是一个后缀`(?=<\/\1>)`。
        * 注意后缀里的`\/`，它用到了前面提过的字符转义；`\1`则是一个反向引用，引用的正是捕获的第一组，前面的`(\w+)`匹配的内容，这样如果前缀实际上是`<b>`的话，后缀就是`</b>`了。整个表达式匹配的是`<b>`和`</b>`之间的内容(再次提醒，不包括前缀和后缀本身)。

## 注释
- 通过语法(?#comment)来包含注释
```2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)```



## 贪婪与懒惰
- 贪婪：匹配尽可能多的字符，如a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。
- 懒惰：匹配尽可能少的字符，a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。
    + 其中懒惰例子中第一个不是ab是由于最先开始匹配的拥有最高的优先权


## 处理选项
- IgnoreCase(忽略大小写)                匹配时不区分大小写。
- Multiline(多行模式)                    更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
- Singleline(单行模式)                更改.的含义，使它与每一个字符匹配（包括换行符\n）。
- IgnorePatternWhitespace(忽略空白)    忽略表达式中的非转义空白并启用由#标记的注释。
- ExplicitCapture(显式捕获)            仅捕获已被显式命名的组。



## 平衡组/递归匹配
### 概念：
- `(?'group')` 把捕获的内容命名为group,并压入堆栈(Stack)
- `(?'-group')` 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- `(?(group)yes|no)` 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- `(?!)` 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

### 事例：
```
    <                         #最外层的左括号
        [^<>]*                #最外层的左括号后面的不是括号的内容
        (
            (
                (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
                [^<>]*       #匹配左括号后面的不是括号的内容
            )+
            (
                (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
                [^<>]*        #匹配右括号后面不是括号的内容
            )+
        )*
        (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败
    >                         #最外层的右括号
```


## 补充语法
- `\a    `                报警字符(打印它的效果是电脑嘀一声)
- `\b    `                通常是单词分界位置，但如果在字符类里使用代表退格
- `\t    `                制表符，Tab
- `\r    `                回车
- `\v    `                竖向制表符
- `\f    `                换页符
- `\n    `                换行符
- `\e    `                Escape
- `\0nn`                ASCII代码中八进制代码为nn的字符
- `\xnn`                ASCII代码中十六进制代码为nn的字符
- `\unnnn`                Unicode代码中十六进制代码为nnnn的字符
- `\cN`                    ASCII控制字符。比如\cC代表Ctrl+C
- `\A    `                字符串开头(类似^，但不受处理多行选项的影响)
- `\Z    `                字符串结尾或行尾(不受处理多行选项的影响)
- `\z    `                字符串结尾(类似$，但不受处理多行选项的影响)
- `\G    `                当前搜索的开头
- `\p{name}`            Unicode中命名为name的字符类，例如\p{IsGreek}
- `(?>exp)`                贪婪子表达式
- `(?<x>-<y>exp)`        平衡组
- `(?im-nsx:exp)`        在子表达式exp中改变处理选项
- `(?im-nsx)`            为表达式后面的部分改变处理选项
- `(?(exp)yes|no)`        把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否`则使用no
- `(?(exp)yes)`            同上，只是使用空表达式作为no
- `(?(name)yes|no)`        如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
- `(?(name)yes)`        同上，只是使用空表达式作为no
