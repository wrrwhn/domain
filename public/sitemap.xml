<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
    
     <entry>
        <title>服务器瓶颈排查</title>
        <url>http://domain.yqjdcyy.com/post/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%93%B6%E9%A2%88%E6%8E%92%E6%9F%A5/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>运维</tag>
        </tags>
        <content type="html">  网络 指定端口连接数  netstat -nat | grep -i &amp;quot;80&amp;quot; | wc -l  端口TCP连接上限 TCP 连接项  Local IP Local Port Remote IP Remote Port  客户端  发起 TCP 连接请求时，需要选用空闲的本地端口进行独占  可变项仅为 Local.Port 项  2%16= 65535    服务端  服务端可变更 Remote.IP x Remote.Port  2^32 * 2^16= 281,474,976,710,656   测试 IP 是否可连  ping xxx.xxx.xxx.xxx  测试指定 IP 端口是否可连  telnet xxx.xxx.xxx.xxx xxxxxx  带宽使用情况  iftop
    字段 解析     TX 发送流量   RX 接收流量   TOTAL 总流量   Cumm 运行期间总流量   peak 流量峰值   rates 过去 2s/10s/40s 的平均流量      内存 性能分析  top
 效果图
   字段解析
   字段 解析     PID 进程 ID   USER 进程拥有者   PR 进程优先级
越小越优先   NI Nlnice 值   VIRT 进程所占虚拟内存   RES 进程所点物理内存   SHR 进程所占共享内存   S 进程所处状态
S：休眠，R：运行中，Z：僵死，N：进程优先值为负   %CPU 进程所占 CPU 使用率百分比   %MEM 该进程所占物理内存与总内存的百分比   TIME&#43; 进程历史占用 CPU 累加时间   COMMAND 进程启动命名    命令
   命令 作用     P 按 %CPU 数值排行   T 按 TIME&#43; 数据排行   M 按 %MEM数据排行      查询指定服务  ps -e -o &#39;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&#39;  查看进程的内存映射  pmap -d 10809 | less  磁盘 使用率 查看各目录总体使用情况  df -h
Filesystem Size Used Avail Use% Mounted on /dev/xvda1 20G 15G 4.2G 78% / devtmpfs 16G 0 16G 0% /dev tmpfs 16G 0 16G 0% /dev/shm tmpfs 16G 698M 15G 5% /run tmpfs 16G 0 16G 0% /sys/fs/cgroup  查询当前目录使用情况 查询指定目录占用大小  du -sh /data/service
6.9G /data/service  查询当前目录占用大小  cd /data/service &amp;amp; du --max-depth=1 -h
984K ./bin 3.2G ./logs 3.8G ./webapps 92K ./run 15M ./tomcat 6.9G   服务 应用服务 第三方监控  暴露 /health 给阿里云监控服务  日志异常排查  查询是否有出现 out of memory 等情况异常  优化  界面静态化 前端缓存接口数据 减少接口请求数量  压测 分表分库  减少因连接同库导致连接数不足等瓶颈  微服务  服务分割 快速扩容 服务降级 网关  缓存  nginx tomcat redis  外部 微信请求数限制  「获取带参数的二维码」的「每日请求额度」为 100000  Mysql CPU 使用率  top  连接数与执行语句  show processlist;
   Id User Host db Command Time State Info Rows_sent Rows_examined     线程 ID 连接用户 所连接而来的 IP 和端口 显示该线程所连接的数据库 显示当前状态，如SLEEP/ QUERY/ CONNECT  状态持续时间，单位为秒 执行的 SQL 语句 查询结果行数 扫描行数   899 readonly localhost training Query 0 init show processlist 0 0   411906 yunkai_user 10.30.220.110:56965 training Sleep 3  NULL 1 0   411907 yunkai_user 10.30.220.110:56966 training Query 0 init commit 0 0   411946 yunkai_user localhost training Query 0 init show processlist 0 0     慢查询日志  添加配置
 my.cnf
-- 指定慢查询日志存放位置 log_slow_queries = /usr/local/mysql/var/slow_queries.log -- 指定慢查询的时限标志 long_query_time = 10 -- 记录未使用索引的 SQL 语句 log-queries-not-using-indexes = 1  查询配置
 show variables like &#39;long_query_time&#39;     Variable_name Value     long_query_time 0.300000    查询日志
 tail /data/mysql/data/xxxx-slow.log
SET timestamp=1456293509; select meetingsig0_.id as id1_10_, meetingsig0_.account_id as account_2_10_, meetingsig0_.create_time as create_t3_10_, meetingsig0_.end_time as end_time4_10_, meetingsig0_.meeting_id as meeting_5_10_, meetingsig0_.price as price6_10_, meetingsig0_.start_time as start_ti7_10_ from meeting_sign_up_price_range meetingsig0_ where meetingsig0_.meeting_id=34 order by meetingsig0_.start_time asc; # Time: 160224 14:15:18 # User@Host: yunkai_user[yunkai_user] @ localhost [127.0.0.1] Id: 501 # Schema: yunkai Last_errno: 0 Killed: 0 # Query_time: 0.015686 Lock_time: 0.000112 Rows_sent: 0 Rows_examined: 0 Rows_affected: 1 -- # Query_time: 查询时间 Lock_time: 锁定时间 Rows_sent: 查询结果行数 Rows_examined: 描述行数 Rows_affected: 影响行数 # Bytes_sent: 11 SET timestamp=1456294518; show global status like &#39;%Slow_queries%&#39;;
   Variable_name Value     Slow_queries 64893     硬件检查 平台监控 运行状态  show status like &#39;%%&#39;;
   字段 描述     Aborted_clients 客户端未正确关闭而断开的连接数量   Aborted_connects 尝试连接失败的次数   Handler_update 请求更新表中单行的次数   Handler_write 请求新增单行的次数   Threads_connected 当前打开的连接数   Max_used_connections 最大连接数   Open_tables 打开表的数量   Open_files 打开的文件数量   Open_streams 打开流的数量
日志记载   Slow_queries 超过 long_query_time 时间的连接数量   Uptime 服务器运行时间     Redis  CPU 使用情况  饱和 竞争  端口使用情况  TCP 连接牌 FIN_WAIT2 状态  Server 端主动状态连接，如 keepalive 超时，而因 TCP/IP 协议中该状态无超时判定，当 Client 不关闭，则将越发占用   不合理的使用  API  keys  数据结构  持久化相关的阻塞 内存交换 网络异常  延迟 中断 请求拒绝   参考  简单总结服务器并发瓶颈与解决方向 定位服务器瓶颈 当应用运行缓慢时，如何确定系统瓶颈？ 关于服务器性能的思考  Network  单机最大tcp连接数 每天一个linux命令（58）：telnet命令 每天一个linux命令（54）：ping命令 Linux服务器上监控网络带宽的18个常用命令  Dir  linux查看磁盘使用情况命令  MYSQL  Mysql 高负载排查思路 MySql状态查看方法 MySql如何查看连接数和状态? Process List Mysql 高负载排查思路 MySQL慢查询日志总结  Redis  关于Redis的一些思考和总结 高并发下redis的瓶颈分析  </content>
    </entry>
    
     <entry>
        <title>费曼学习法</title>
        <url>http://domain.yqjdcyy.com/post/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>学习</tag>
        </tags>
        <content type="html">  步骤 学习  学习你所想掌握的知识  讲授  用自己的语言，将学习的内容讲解给同伴  推荐使用比喻的方法  回答同伴的提问  整理  整理讲授过程中卡顿、说得不够简单 收集同伴提问无法解答的问题  重复  带着「整理」阶段收集的问题，重新开始  参考  费曼技巧：可能是最好的学习方法 号称终极快速学习法的费曼技巧，究竟是什么样的学习方法？  </content>
    </entry>
    
     <entry>
        <title>Linux.Netstat</title>
        <url>http://domain.yqjdcyy.com/post/linux.netstat/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Netstat 作用  可于内核中访问网络连接状态及其相关信息 用于显示网络连接、路由表和每个网络接口设备的状态信息  格式  netstat [-a][-e][-n][-o][-p Protocol][-r][-s][Interval]  参数    参数 作用     -a/-all 显示所有socket，不论是否正在监听   -c/-continuous 持续每秒进行选中信息的输出显示   -i/-interfaces=iface 显示所有的网络接口   -n/-numeric 以数值地址形式进行展示   -r/-route 显示内核路由表，同 route -e   -t/-tcp 显示 TCP 协议的连接情况   -u/-udp 显示 UDP 协议的连接情况   -v/-verbose 详细显示正在进行的工作   -p/-program 显示套接字关联的程序名称和 PID   -e/-extend 显示额外信息，如 uid 等
若连续两次调用则显示最大程度明细   -o/-timers 显示与网络计时器相关的信息   -s/-statistics 展示每个协议的摘要统计   -l/-listening 仅显示监听中的套接字    序列图     输出 State    State Desc     LISTENING 正在监听端口   SYNC_SEND 已发送 SYN 报文等待连接请求建立   SYNC_RECEIVED 已接收 SYN 报文的连接请求后，发送 SYN 回包后的   ESTABLISHED 连接已建立，开始进行数据传输   CLOSE_WAIT 服务端等待关闭
回应客户端的 FIN报文以 ACK报文，无后缀则关闭 Socket 并发送 FIN 报文   FIN_WAIT_1 客户端请求断开，发送 FIN 报文后的等待状态
由于服务端响应及时，观察频率低   FIN_WAIT_2 客户端等待数据传输完成后，服务端发送FIN 报文确认的过程
半连接   LAST_ACK 被动关闭方等待最终 ACK 报文的确认   TIME_WAIT 接收 FIN 并返回 ACK 报文后，等待 2MSL 后返回 CLOSED 状态   CLOSING 等待远程 TCP 对连接的确认   CLOSED 无连接状态链路    示例 过滤 TCP 连接统计  netstat -nat |awk &#39;{print $6}&#39;| sort | uniq -c  查询指定端口的 TCP 连接数  netstat -ant | grep -i &amp;quot;80&amp;quot; | wc -l  已连接链路数  netstat -an | grep ESTABLISHED | wc -l  参考  netstat用法及TCP state解析 查看linux中的TCP连接数  </content>
    </entry>
    
     <entry>
        <title>Hello.Spring.Cloud.Sleuth</title>
        <url>http://domain.yqjdcyy.com/post/hello.spring.cloud.sleuth/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Spring.Cloud</tag>
        </tags>
        <content type="html">  功能  链路追踪  查看该请求经过了哪些服务，当前哪些服务异常（实时数据）  可视化异常  在 zipkin 界面上查看异常情况  分析蚝时  记录各采样请求的蚝时，可控地进行服务扩容  优化链路  根据服务调用的频次，合理配置各服务数量(全量数据)   结构  采集端  sleuth  显示端  zipkin  数据存储  In-Memory Kafka MySql Elasticsearch Cassandra    连接方式  http stream  kafka rabbitmq.binder    原理 由 Google.dapper 论文发展而来 示例      术语    模块 字段 含义     trace  多个 span 组成的树状请求   span  工作单元，以 spanId 标识
服务间调用时生成同一 spanId 的客户端请求和服务端处理记录    traceId 此次请求的标识 ID    pspanId 上一服务请求 spanId    spanId 此次请求的 spanId    cs client-send    cr client-receive    ss server-send    sr server-receive    采样  配置  spring.sleuth.sampler.percentage=0.1  默认  采样率为 0.1  算法  Reservoir sampling | 水塘抽样  实现  PercentageBasedSampler   细节 Sleuth Http  TraceFilter  对请求添加 X-B3-SpanId、 X-B3-TraceId等属性进行链路跟踪  TraceHandlerInterceptor  检测到 HttpServletRequest 中若不存在   实现 Maven  Server.pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.zipkin.java&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;zipkin-server&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.11.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.zipkin.java&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;zipkin-autoconfigure-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.11.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Client.pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  Properties  Server.bootstrap.yml
# 未配置，默认走 In-Memory 形式 management: metrics: web: server: # 修复运行后无法正常运行的异常 auto-time-requests: false Client.bootstrap.yml
spring: sleuth: sampler: # 采集率调整为 100%，全部采集 probability: 1.0 zipkin: # 指定 Zipkin 的推送地址 base-url: http://localhost:8303  Code  Server.Application
// v2.* 版本请引用此路径下文件 import zipkin2.server.internal.EnableZipkinServer; @EnableEurekaClient @SpringBootApplication // 启动 Zipkin 服务收集 @EnableZipkinServer public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Client
// 无须添加代码！  Invoke  http://localhost:8303/zipkin/index.html
 Zipkin 首页  http://localhost:8303/zipkin/
 Zipkin 搜索 注： 如若仅使用 Feign 或 Robbin 进行转跳，不会判定为 depth 增加   补充 ZipKin  Twitter 开源的分布式跟踪系统 致力于收集服务的定时数据，用以解决微服务架构中的延迟问题 功能  收集 存储  In-Memory  测试推荐  Kafka MySql Elasticsearch  生产推荐  Cassandra  查找 展现  提供 Web 前端界面进行数据展示    Error  Caused by: java.lang.ClassNotFoundException: org.springframework.boot.actuate.metrics.buffer.CounterBuffers
 配置  Spring.Boot 2.0.5.RELEASE Zipkin.Server 1.30.2 Zipkin.UI 1.30.2  参考 -I get a class error when trying to create a reactive spring cloud sleuth zipkin server
``` Yeah. See #727. Short summary: Zipkin doesn&amp;#39;t work with Boot 2.0, so if you need a stream server, use Spring Boot 1.5. ```  java.lang.IllegalArgumentException: Prometheus requires that all meters with the same name have the same set of tag keys.
 参考
 zipkin日志收集注意事项
a、将management.metrics.web.server.auto-time-requests=false设置为false,默认为true; b、重写DefaultWebMvcTagsProvider或者实现接口WebMvcTagsProvider，参照DefaultWebMvcTagsProvider的写法，只需要把DefaultWebMvcTagsProvider下getTages()方法的WebMvcTags.exception(exception)去除掉。    参考 官方 -Part VII. Spring Cloud Sleuth -Dapper, a Large-Scale Distributed Systems Tracing Infrastructure
补充 -Spring Cloud技术分析（3）- spring cloud sleuth -springcloud(十二)：使用Spring Cloud Sleuth和Zipkin进行分布式链路跟踪 -Spring Cloud Sleuth进阶实战 -Dapper，大规模分布式系统的跟踪系统 -水塘抽样（Reservoir Sampling）
代码 -yqjdcyy/Hello_Spring_Cloud
</content>
    </entry>
    
     <entry>
        <title>Hello.Spring.Cloud.Zuul</title>
        <url>http://domain.yqjdcyy.com/post/hello.spring.cloud.zuul/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Spring.Cloud</tag>
        </tags>
        <content type="html">  作用  保障服务无状态  确保对外服务的安全性，增加服务访问的控制控制 保障集群中 REST API 无状态  保障接口的复用  功能 服务路由  通过 JVM 实现
均衡负载 权限控制 ZuulFilter
 filterType  pre  pre-routing filtering 请求被路由之前调用  route  routing to an origin 请求路由时调用  post  post-routing filters 调用后，未调用  error  error handling   filterOrder  filterOrder 是必须的 但对于非提前执行的过滤器而言是同样的，仅用于指定预先过滤判断的顺序 不需要该顺序值是连续的  shouldFilter  当返回 true 的时候表示执行 run() 方法  run  过滤器实现的核心   流程图
 ![]()
动态路由 服务迁移 静态响应   实现 转跳 Maven  pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  Properties  bootstrap.yml
zuul: routes: # v3 other: path: /other/** url: http://&amp;lt;ZUUL_HOST&amp;gt;:&amp;lt;ZUUL_PORT&amp;gt;/other-service # v2 portal: path: /portal/** serviceId: portal # v1 sns: /sns/** # v0 ## hystrix: ## 默认通过 `http://&amp;lt;ZUUL_HOST&amp;gt;:&amp;lt;ZUUL_PORT&amp;gt;/&amp;lt;Eureka.ServiceId&amp;gt;/** ` 访问  Code  Application
@EnableEurekaClient @SpringBootApplication @EnableZuulProxy public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }  Invoke  http://localhost:8302/portal/config  相当于调用 http://localhost:8100/config   过滤 Code  ZuulFilter
public class ZuulFilter extends com.netflix.zuul.ZuulFilter { private static Logger logger = LoggerFactory.getLogger(ZuulFilter.class); @Override public String filterType() { return &amp;#34;pre&amp;#34;; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() throws ZuulException { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest req = ctx.getRequest(); logger.info(&amp;#34;[{}] request to [{}]&amp;#34;, req.getMethod(), req.getRequestURL().toString()); Object token = req.getParameter(&amp;#34;token&amp;#34;); if (null == token) { logger.warn(&amp;#34;token is empty&amp;#34;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); return null; } logger.info(&amp;#34;token pass&amp;#34;); return null; } }  Invoke  http://localhost:8302/portal/config  HTTP 401  http://localhost:8302/portal/config?token=yao  basic   参考 官方  19. Router and Filter: Zuul  补充  Spring Cloud构建微服务架构（五）服务网关 springcloud(十)：服务网关zuul初级篇  代码  yqjdcyy/Hello_Spring_Cloud  </content>
    </entry>
    
     <entry>
        <title>Hello.Spring.Cloud.Hystrix</title>
        <url>http://domain.yqjdcyy.com/post/hello.spring.cloud.hystrix/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Spring.Cloud</tag>
        </tags>
        <content type="html">  作用  在高并发下，避免服务阻塞造成对整体服务稳定性的影响 通过服务降级、服务隔离来保障业务的顺利进行  选型  命令模式
   线程|线程池
 客户端单独线程执行，避免阻塞影响调用线程的正常任务 便于即时更新客户端库包 避免调用端性能下降，反作用影响请求调用 支持异步操作  网络等操作大部分为同步执行    流程 流程图    节点 *Command.init  HystrixCommand  HystrixCommand command = new HystrixCommand(arg1, arg2);cls  HystrixObservableCommand  HystrixObservableCommand command = new HystrixObservableCommand(arg1, arg2);   *Command.execute  HystrixCommand  execute  同步请求 K value = command.execute();  queue  异步请求 Future&amp;lt;K&amp;gt; fValue = command.queue();   HystrixObservableCommand  observe  订阅 Observable，返回源 Observable 的拷贝 Observable&amp;lt;K&amp;gt; ohValue = command.observe();  toObservable  订阅时，将执行 Hystrix 请求，并将返回值封装为 Observable 对象 Observable&amp;lt;K&amp;gt; ocValue = command.toObservable();    Cache.Response  当允许缓存且当请求结果已缓存情况，直接返回 Observable 缓存结果  Circuit.Open  检测融断状态  已融断时，不再执行指令，并路由至 Fallback 未融断则继续流转   Thread Pool| Queue| Semaphore full  检测请求数是否已超出 Hystrix 限制  已超出时，不再执行指令，并路由至 Fallback   HystrixObservableCommand.construct() | HystrixCommand.run()  返回结果
 HystrixCommand.run()  单一返回值和 onCompleted 通知|异常  HystrixObservableCommand.construct()  包含一个或多个返回值的Observable| onError 通知   执行超时情况下，将抛出 TimeoutException 异常，返回 Fallback
 若方法无法取消、中断，返回值亦将被废弃  注意
 Hystrix 通过 JVM 抛出 InterruptedException 但大多数 HTTP 调用库不支持对 InterruptedException 异常的处理  因此需确保连接、读和写的的超时时长    Circuit.Health calc  Hystrix 将运行状态上报给融断器，以供进行统计决定融断器的状态更新
 上报状态
 成功 失败 拒绝 超时  融断状态
 闭合  下一次健康  打开  短路 后续请求无法调用请求，直到恢复期过去    Fallback  调用时机
 命令执行时抛出异常 融断器短路 命令线程池|队列|信号 超出阀值 命令执行超时  方法内容
 通用返回值 无网络请求、内存缓存、静态逻辑   Response.success    细节 融断器  条件
 错误超过指定比例，默认为 50% 10秒 内超过 20个 请求异常  时机
 关闭-&amp;gt; 半开  当请求量超出预定阀值 当请求失败率直琿预定异常阀值比率  半开  短路状态  所有请求将直接路由到 fallback  经过指定休眠时间后，将放过下一请求  请求失败  半开-&amp;gt; 开启  请求成功  半开-&amp;gt; 关闭    开启  持续一个睡眠窗口的时间   结构
  默认维护 10 个 Bucket，每秒一个 Bucket 以记录成功、失败、超时和拒绝的状态   隔离  线程隔离  将执行依赖代码的线程，与请求线程（如 Tomcat、Jetty）分离，以自由控制离开的时间 通过线程池大小控制并发，快速失败 优点  支持异步调用 服务恢复时，仅需要清理线程池，便可恢复使用  缺点  增加 CPU、排队、调度和上下文切换  实际使用中，开销足够小，不会造成重大成本和性能影响    信号隔离
 通过信号来限制并发访问 使用请求线程执行依赖代码 信息量大小可动态调整
 线程池大小不可动态调整
参数    应用 Hystrix Maven &amp;lt;!-- Hystrix.* --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  Code  EurekaController
// 服务请求相关配置 @RequestMapping(value = &amp;#34;/hystrix/{method}&amp;#34;, method = RequestMethod.GET) // 融断器配置 @HystrixCommand( // 异常情况下的代理服务，**参数、返回值需一致**  fallbackMethod = &amp;#34;fallback&amp;#34;, commandProperties = { // 设置超时判断时长  @HystrixProperty(name = &amp;#34;execution.isolation.thread.timeoutInMilliseconds&amp;#34;, value = &amp;#34;1000&amp;#34;)}) public String hystrix( @RequestParam Boolean error, @RequestParam Integer duration) { Assert.isTrue(null != error &amp;amp;&amp;amp; !error, &amp;#34;Hystrix.Error&amp;#34;); if(null!= duration &amp;amp;&amp;amp; duration&amp;gt; 0){ Time.sleep(duration); } return feignService.config(); } // 融断异常时的代理方法 public String fallback(Boolean error, Integer duration) { return &amp;#34;Hystrix.Fallback&amp;#34;; } Application
@EnableEurekaClient @SpringBootApplication @EnableFeignClients // 开启融断 @EnableCircuitBreaker public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }  Request  /actuator/hystrix.stream
 请求查询监控状态   Monitor.Hystrix Maven &amp;lt;!-- Hystrix.* --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Code  Application
@EnableEurekaClient @SpringBootApplication @EnableFeignClients @EnableCircuitBreaker // 添加 Hystrix 面板功能 @EnableHystrixDashboard public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }  Request  登录 /hystrix 在观看链路中输入 http://localhost:8301/actuator/hystrix.stream 调用已添加断路监控的请求，查看动态请求状态     Monitor.Turbine Maven ```xml &amp;lt;!-- Hystrix.* --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-turbine&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; ``` Code  Application
@EnableEurekaClient @SpringBootApplication @EnableFeignClients @EnableCircuitBreaker @EnableHystrixDashboard // 添加 Turbine 监控 @EnableTurbine public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }  Properties  bootstrap
turbine: app-config: hystrix aggregator: cluster-config: default cluster-name-expression: new String(&amp;#34;default&amp;#34;)  Request  登录 /hystrix 在观看链路中输入 http://localhost:8301/turbine.stream 调用已添加断路监控的请求，查看动态请求状态  参考 原理  Home How it Works Hystrix工作原理（官方文档翻译）  使用  Hystrix使用入门手册 使用 Hystrix 实现自动降级与依赖隔离 spring cloud 学习(4) - hystrix 服务熔断处理 springcloud(五)：熔断监控Hystrix Dashboard和Turbine  代码  yqjdcyy/Hello_Spring_Cloud  </content>
    </entry>
    
     <entry>
        <title>HTTP.Header.UserAgent</title>
        <url>http://domain.yqjdcyy.com/post/http.header.useragent/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>HTTP</tag>
        </tags>
        <content type="html">  Introduce 作用  User-Agent 请求头包含一特征文本，供允许网络协议获取应用类型、操作系统、软件供应商和软件版本  统计用户浏览器的使用情况  请求服务提供商为当前 PC/ WEb 提供的特定格式网页  前端实现上需要考虑浏览器兼容问题   语法 格式  User-Agent: &amp;lt;product&amp;gt; / &amp;lt;product-version&amp;gt; &amp;lt;comment&amp;gt; User-Agent: Mozilla/&amp;lt;version&amp;gt; (&amp;lt;system-information&amp;gt;) &amp;lt;platform&amp;gt; (&amp;lt;platform-details&amp;gt;) &amp;lt;extensions&amp;gt;  User-Agent: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion  User-Agent: &amp;lt;浏览器标识&amp;gt; (&amp;lt;操作系统标识&amp;gt;; &amp;lt;加密等级标识&amp;gt;; &amp;lt;浏览器语言&amp;gt;) &amp;lt;渲染引擎标识&amp;gt; &amp;lt;版本信息&amp;gt;
选项 &amp;lt;product&amp;gt;
 产品识别码| 浏览器标识 Mozilla/5.0  通用标识符，表示与 Mozilla 兼容 早期服务器于加载前检查是否为 Netscape 浏览器，其它浏览器不得不伪装   &amp;lt;product-version&amp;gt;
 产品版本号| 渲染引擎标识  &amp;lt;comment&amp;gt;
 产品相关备注信息 |版本信息   rv:geckoversion
 Gecko 的发布版本号 geckoversion 与 firefoxversion 相同  system-information
 操作系统标识 如若有多个，则以 ; 进行分隔
   操作系统 版本标识     FreeBSD     X11; FreeBSD (version no.) i386    X11; FreeBSD (version no.) AMD64   Linux     X11; Linux ppc    X11; Linux ppc64    X11; Linux i686    X11; Linux x86_64   Mac     Macintosh; PPC Mac OS X    Macintosh; Intel Mac OS X    Solaris    X11; SunOS i86pc    X11; SunOS sun4u   Windows     Windows NT 6.1 (windows 7)    Windows NT 6.0 (windows vista)    Windows NT 5.2 (windows 2003)    Windows NT 5.1 (windows xp)    Windows NT 5.0 (windows 2000)    Windows ME    Windows 98   Android    Iphone    Mobile      Gecko/geckotrail
 说明使用浏览器基于 Gecko 渲染引擎 桌面浏览器，geckotrail 固定为 20100101  Firefox/firefoxversion
 说明该浏览器是 Firefox  加密等级标识
   标识 含义     N 无安全加密   I 弱安全加密
40位 加密   U 强安全加密
120位 加密    浏览器语言
 表示当前浏览器指定的语言  渲染引擎标识
  示例  Firefox  Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 Mozilla/5.0 (Macintosh; Intel Mac OS X x.y; rv:42.0) Gecko/20100101 Firefox/42.0  Chrome  Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36  Opera  Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 OPR/38.0.2220.41  Safari  Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1  Internet Explorer  Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0)  爬虫和机器人  Googlebot/2.1 (&#43;http://www.google.com/bot.html)   Supplement 浏览器发展史  NCSA.Mosaic Netscape.Mozilla Microsoft.IE Firefox.Gecko KHTML  Konqueror  WebKit  Mac.Safari  Google.Chrome   Opera
  浏览器    浏览器名称 包含关键词 禁止包含关键词 补充     Firefox Firefox/xyz Seamonkey/xyz    Seamonkey Seamonkey/xyz     Chrome Chrome/xyz Chromium/xyz    Chromium Chromium/xyz     Safari Safari/xyz Chrome/xyz Chromium/xyz Safari 有两个版本号，一个技术性较强，格式是Safari/xyz，一个对用户友好一点，格式是Version/xyz   Opera OPR/xyz [1]
Opera/xyz [2]  [1] Opera 15&#43; (基于Blink的引擎) [2] Opera 12- (基于Presto的引擎)   Internet Explorer ; MSIE xyz;  IE浏览器的名字并没有使用BrowserName/VersionNumber的格式    渲染引擎    渲染引擎名称 包含关键字 补充     Gecko Gecko/xyz    WebKit AppleWebKit/xyz 请注意，WebKit浏览器包含了&amp;rsquo;like Gecko&amp;rsquo;字符串，如果不加以注意，可能会触发检测Gecko的false positive。   Presto Opera/xyz 注: 在Opera浏览器在15及以上的版本中，已经不再使用Presto（参见&amp;rsquo;Blink&amp;rsquo;）。   Trident Trident/xyz IE浏览器将此字符串放在User Agent字符串的注释部分。   Blink Chrome/xyz     Reference 官方  User-Agent  User-Agent 中文版本  Browser detection using the user agent  Browser detection using the user agent 中文版本  Firefox user agent string reference  补充  认识User-Agent Browser Statistics  </content>
    </entry>
    
     <entry>
        <title>Linux.Iptables</title>
        <url>http://domain.yqjdcyy.com/post/linux.iptables/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  介绍 作用  配置 Linux 内核防火墙的命令行工具  检测、修改、转发、重定向和丢弃 IPv4 数据包 针对 IPv6 需使用 ip6tables   组成  Tables
 作为具有相同功能规则的合集
   table work     raw 网址过滤，raw 中的数据包不会被系统跟踪   filter 包过滤，存放所有与防火墙相关操作的默认表   nat 用于网络地址转换
例如端口转发   mangle 用于对特定数据包的修改
例如损坏数据包   security 用于强制访问控制 网络规则
例如 SELinux     Chains
 为按顺序排列的规则列表 是表的组成元件  filter= INPUT&#43; OUTPUT&#43; FORWARD nat= PREROUTING&#43; OUTPUT mangle= PREROUTING&#43; INPUT&#43; FORWARD&#43; OUTPUT&#43; POSTROUTING  默认无规则，而添加的默认规则为 ACCEPT 而新添加的规则，默认置于队尾，需在前面规则通过的基础上才能生效 链路功能
   链路类型 处理数据类型     INPUT 数据包目标地是本地主机   OUTPUT 处理输出数据包   FORWARD 数据包目标地是其它主机   PREROUTING 用于目标地址转换（DNAT）   POSTOUTING 用于源地址转换（SNAT）     Rules
 规则用于过滤数据包 由一个目标&#43; 多个匹配组成  顺序  在通过多个匹配后，执行目标  目标  使用 -j|-jump 指定 可指定自定义链、内置的特定目标、不终止  内置目标  ACCEPT DROP QUEUE RETURN  目标扩展  REJECT LOG    匹配  端口  eth0 eth1  类型  ICMP TCP UDP  目标端口  指定端口，如 8080    动作
   动作 实现功能     ACCEPT 接收数据包   DROP 丢弃数据包   REDIRECT 重定向、映射、透明代理   SNAT 源地址转换   DNAT 目标地址转换   MASQUERADE IP伪装（NAT），用于ADSL   LOG 日志记录     Traversing Chains
 描述接收到的网络数据包，按照怎样的顺序通过表的交通管制链  Modules
 通过模块以扩展功能，实现更为复杂的过滤 模块  connlimit  限制同一 IP 连接数  conntrack  追踪、记录一个连接的状态  limit  限速  recent  大型地址列表 配合限制登录等操作使用     路由  网络请求由 &amp;lt;Network&amp;gt; 作为起点流通 本地请求则由 &amp;lt;local process&amp;gt; 作为起点流通  XXXXXXXXXXXXXXXXXX XXX Network XXX XXXXXXXXXXXXXXXXXX &#43; | v &#43;-------------&#43; &#43;------------------&#43; |table: filter| &amp;lt;---&#43; | table: nat | |chain: INPUT | | | chain: PREROUTING| &#43;-----&#43;-------&#43; | &#43;--------&#43;---------&#43; | | | v | v [local process] | **************** &#43;--------------&#43; | &#43;---------&#43; Routing decision &#43;------&amp;gt; |table: filter | v **************** |chain: FORWARD| **************** &#43;------&#43;-------&#43; Routing decision | **************** | | | v **************** | &#43;-------------&#43; &#43;------&amp;gt; Routing decision &amp;lt;---------------&#43; |table: nat | | **************** |chain: OUTPUT| | &#43; &#43;-----&#43;-------&#43; | | | | v v | &#43;-------------------&#43; &#43;--------------&#43; | | table: nat | |table: filter | &#43;----&#43; | chain: POSTROUTING| |chain: OUTPUT | &#43;--------&#43;----------&#43; &#43;--------------&#43; | v XXXXXXXXXXXXXXXXXX XXX Network XXX XXXXXXXXXXXXXXXXXX 指令 格式  iptables &amp;lt;option&amp;gt; (&amp;lt;args&amp;gt;) iptables -t 表名 &amp;lt;-A/I/D/R&amp;gt; 规则链名 [规则号] &amp;lt;-i/o 网卡名&amp;gt; -p 协议名 &amp;lt;-s 源IP/源子网&amp;gt; --sport 源端口 &amp;lt;-d 目标IP/目标子网&amp;gt; --dport 目标端口 -j 动作  详解    选项 作用     -t &amp;lt;表&amp;gt; 指定要操纵的表   -A 向规则链中添加条目   -D 从规则链中删除条目   -i 向规则链中插入条目   -R 替换规则链中的条目   -L 显示规则链中已有的条目   -F 清除规则链中已有的条目   -Z 清空规则链中的数据包计算器和字节计数器   -N 创建新的用户自定义规则链   -P 定义规则链中的默认目标   -h 显示帮助信息   -p 指定要匹配的数据包协议类型   -s 指定要匹配的数据包源IP地址   -j &amp;lt;目标&amp;gt; 指定要跳转的目标   -i &amp;lt;网络接口&amp;gt; 指定数据包进入本机的网络接口   -o &amp;lt;网络接口&amp;gt; 指定数据包要离开本机所使用的网络接口    示例 限制每IP在一分钟内最多对服务器只能有3个SSH连接 iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 3 --name SSH -j LOG --log-prefix &amp;#34;SSH Attack&amp;#34; iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 3 --name SSH -j DROP iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH -j ACCEPT 查看并删除第8条规则 iptables -L -n --line-numbers iptables -D INPUT 8 添加规则 # 配置规则  # 允许 192.168.1.0/24 针对 22 端口的 tcp 请求  iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT # 开放外网对 80 端口的 tcp 请求  iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 限制来自 123.45.6.7 的请求  iptables -I INPUT -s 123.45.6.7 -j DROP # 重启 service iptables restart # 状态 service iptables status 配置查看 cat /etc/sysconfig/iptables 参考 IPTables  Linux - CentOS6下操作防火墙(iptables) iptables详解（1）：iptables概念 Iptables (简体中文)  安全  Iptables防攻击模块介绍（五） 通过iptables配置加强服务器安全  扩展  网络地址转换 损坏数据包 强制访问控制 SELinux   </content>
    </entry>
    
     <entry>
        <title>Hello.Spring.Cloud.Eureka</title>
        <url>http://domain.yqjdcyy.com/post/hello.spring.cloud.eureka/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Spring.Cloud</tag>
        </tags>
        <content type="html">  细节 Region-Zone-Eureka  名词解析
 Region
 区域 基础服务的地区集合
   区域 编码     亚太-东京 ap-northeast-1   亚太-新加坡 ap-southeast-1   亚太-悉尼 ap-southeast-2   欧洲-爱尔兰 eu-east-1   南美-圣保罗 sa-east-1   美东-北佛杰尼亚 us-east-1   美西-北加利佛尼亚 us-west-1   美西-俄勒风 us-west-2     Zone
 可用区/ 机房/ Availability Zone/ AZ 多独立供电、网络服务的数据中心组成 如 us-west-2a 区  Eureka
  层级
 region= n* zone= n* (m* eureka)  架构
    模块  Eureka.Server  存储 Eureka.Client 的注册信息 心跳超时，自动注销指定服务节点  默认 90s  复制，同步各 Eureka.Server 的注册表  Eureka.Client  服务启动时，通过其向 Eureka.Server 端注册服务信息 周期心跳  默认 30s  缓存向 Eureka.Server 请求的信息  即使 Eureka.Server 均宕机，仍可通过缓存信息，找到服务提供者    调用 Robbin&#43; RestTemplate  Robbin  基于 HTTP 或 TCP 的客户端负载均衡工具   Feign  Feign  声明式 HTTP 调用 底层通过 Robbin 进行调用   异常 Eureka.自我保护  提示
 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#39;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.  触发机制
 在 15分钟 内 超过85% 的客户端节点都没有正常的心跳  效果
 不再从注册列表中移除心跳过期的客户端 仍能接受服务的注册、查询，但不可被同步到其它节点  仅当网络稳定时，新注册的信息才会被同步到其它节点   配置
# Eureka.Config.* eureka: instance: # 检测心跳异常的超时时长 lease-expiration-duration-in-seconds: 90 server:1 # 关闭自我保护机构 enable-self-preservation: false # 检查失效服务的间隔时间 eviction-interval-timer-in-ms: 3000  应用 Eureka.Server Maven  pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   Properties  bootstrap.yml
# Eureka.Config.* eureka: client: # 是否将自身注册至 Eureka.Server register-with-eureka: false # 是否同步其它 Eureka.Server 节点数据 fetch-registry: false instance: # 检测心跳异常的超时时长 lease-expiration-duration-in-seconds: 90 server: # 关闭自我保护机构 enable-self-preservation: false # 检查失效服务的间隔时间 eviction-interval-timer-in-ms: 3000  Code  Application.java
// 配置当前服务为 Eureka.Server @EnableEurekaServer @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }   Monitor  http://localhost:10000/   Eureka.Client Maven  pom.xml
&amp;lt;!--Eureka.Client.*--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Eureka.Client.Invoke - Robbin --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Eureka.Client.Invoke - Feign --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-feign&amp;lt;/artifactId&amp;gt; &amp;lt;!-- **有时加上版本才能正常运行** --&amp;gt; &amp;lt;version&amp;gt;1.4.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  Properties  bootstrap.yml
## Eureka.* eureka: client: service-url: defaultZone: http://localhost:10000/eureka   Code  Application.java
@EnableEurekaClient // 注册为 Eureka 客户端 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } ConfigureApplication
@Configuration public class ConfigureApplication { @Bean // 注册 RestTemplate 供服务调用  @LoadBalanced // 标注为通过负载均衡  public RestTemplate restTemplate() { return new RestTemplate(); } } FeignService.java
// 代理接口类 // 使用 FeignClient 指定向 Eureka 中注册指定名称的服务 @FeignClient(&amp;#34;portal&amp;#34;) public interface FeignService { // 对应服务内的链接  @RequestMapping(&amp;#34;/config&amp;#34;) String config(); } EurekaController.java
@RestController @RequestMapping(&amp;#34;/eureka&amp;#34;) public class EurekaController { // Ribbon&#43; RestTemplate  @Autowired RestTemplate restTemplate; @RequestMapping(value = &amp;#34;/robbin/{application}/{method}&amp;#34;, method = RequestMethod.GET) public String invoke(@PathVariable String application, @PathVariable String method) { // 调用 portal 应用的 config 接口，接口为 http://PORTAL/config  // 其中应用名称为 Eureka.Monitor 的 Instances 列表上的 Application 字段  return restTemplate.getForObject(String.format(&amp;#34;http://%s/%s&amp;#34;, application.toUpperCase(), method), String.class); } // Feign  @Autowired FeignService feignService; @RequestMapping(value = &amp;#34;/feign/{method}&amp;#34;, method = RequestMethod.GET) public String feign(@PathVariable String method) { return feignService.config(); } }  参考 文档  Eureka  Spring Cloud第一篇 Eureka简介及原理 AWS的区域和可用区概念解释 Spring Cloud中，Eureka常见问题总结 Spring Cloud Eureka 自我保护机制 Understanding Eureka Peer to Peer Communication F1V3.0-7 Spring Cloud 介绍  Eureka 相关配置参数一览   Robbin  SpringCloud 教程 | 第二篇: 服务消费者（rest&#43;ribbon） Spring Cloud之服务调用及使用ribbon实现负载均衡(三) Spring Cloud源码分析（二）Ribbon  Feign  Spring Cloud中声明式服务调用Feign Spring Cloud Feign 声明式服务调用   代码  yqjdcyy/Hello_Spring_Cloud  </content>
    </entry>
    
     <entry>
        <title>Hello.Spring.Cloud.Config</title>
        <url>http://domain.yqjdcyy.com/post/hello.spring.cloud.config/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Spring.Cloud</tag>
        </tags>
        <content type="html">  组件 配置读取  Spring.Cloud.Config.Server Spring.Cloud.Config.Client  主动更新  Spring.Cloud.Config.Server Spring.Cloud.Config.Client Spring.Cloud.Bus Redis/ RabbitMQ/ Kafka  实现 Config-Server Maven  pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  Properties  src/main/resource/application.yml
## config.server git # cloud: # config: # server: # git: # uri: https://github.com/yqjdcyy/Hello_Spring_Cloud_Config ## config.server locale profiles: active: native cloud: config: server: native: search-locations: D:/work/git/yao/java/Hello_Spring_Cloud_Config  Code  Application.java
@SpringBootApplication @EnableConfigServer // * 必须项 public class Application { public static void main(String[] args) {SpringApplication.run(Application.class, args);} }  Request  格式
 /{application}/{env}(/{label}) (/{label})/{application}-{env}.[yml|properties]  label  git 上对应的分支，可跳过，默认为 master  application  应用名称，于应用配置文件中的 spring.application.name 来指定  env  自定义的环境，如 dev test prod 默认配置，如 default    示例
# 请求 ## Format.Path http://localhost:10086/portal/dev http://localhost:10086/portal/default = http://localhost:10086/portal/default/master ## Format.File http://localhost:10086/portal-dev.yml http://localhost:10086/portal-default.yml = http://localhost:10086/portal.yml = http://localhost:10086/master/portal.yml # 返回值 { &amp;#34;name&amp;#34;: &amp;#34;portal&amp;#34;, &amp;#34;profiles&amp;#34;: [ &amp;#34;default&amp;#34; ], &amp;#34;label&amp;#34;: null, &amp;#34;version&amp;#34;: &amp;#34;58e079a09fc0e4f58a51523ad4f997b9262aaa2a&amp;#34;, &amp;#34;state&amp;#34;: null, &amp;#34;propertySources&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;https://github.com/yqjdcyy/Hello_Spring_Cloud_Config/portal.yml&amp;#34;, &amp;#34;source&amp;#34;: { &amp;#34;config.hello&amp;#34;: &amp;#34;basic-v2&amp;#34; } }, { &amp;#34;name&amp;#34;: &amp;#34;https://github.com/yqjdcyy/Hello_Spring_Cloud_Config/application.yml&amp;#34;, &amp;#34;source&amp;#34;: { &amp;#34;config.env&amp;#34;: &amp;#34;basic&amp;#34; } } ] }  Config-Client Maven  pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   Properties  src/main/resource/bootstrap.yml
spring: cloud: config: uri: http://localhost:10086   Code  ConfigController
@RestController @RequestMapping(&amp;#34;/config&amp;#34;) public class ConfigController { @Value(&amp;#34;${config.hello:undefined}&amp;#34;) // 读取配置文件，无此项时以 `undefined` 代替  private String hello; }  Client.Refresh Maven  pom.xml
&amp;lt;!-- 自动添加 health/ info 等接口 --&amp;gt; &amp;lt;!-- 使用的为 2.0.5.RELEASE 版本，接口已由 /* 变更为 /actuator/* --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;   Properties  aaplication.yml
## Actuator.* management: endpoints: web: exposure: # 默认仅开放 [&amp;#34;health&amp;#34;, &amp;#34;info&amp;#34;] 接口，调整为 “*&amp;#34; 则开放所有接口 include: &amp;#34;*&amp;#34;  Code  ConfigController
// 添加 RefreshScope 注解，以便调用 `/refresh` 接口后，自动将更新值更新到该类 @RefreshScope @RestController @RequestMapping(&amp;#34;/config&amp;#34;) public class ConfigController{...}  Request  GET /actuator  查询 actuator 开放的所有接口  POST /actuator/refresh  指定当前服务 获取最新配置  GET /actuator/health  查询程序运行状态   Bus.Refresh Maven  * /pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-kafka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  Properties  config-server/application.yml
## Bus.Kafka spring: stream: kafka: binder: brokers: &amp;#34;192.168.16.37:9092&amp;#34; ## Actuator.* ## 将 /bus/refresh 接口开放出来， 最新版本中路径更新为 /actuator/bus-refresh management: endpoints: web: exposure: include: &amp;#34;*&amp;#34; portal/application.yml
## Bus.Kafka spring: stream: kafka: binder: brokers: &amp;#34;192.168.16.37:9092&amp;#34;  Log  stdout.log log partitions assigned: [springCloudBus-0]   Request  GET /actuator  查看开放的所有监控接口  POST /actuator/bus-refresh  所有关联应用重新拉取配置  POST /actuator/bus-refresh/portal  指定 portal 应用进行配置拉取   细节 配置格式  键值对 YAML 格式  来源  Git SVN 本地目录 JDBC 覆盖  spring.cloud.config.server.overrides   拉取  git 更新后，服务端 自动拉取最新 配置 通过 spring.application.name 的属性值，作为注册到 Config Server 的客户端 portal ID 默认推送 application.[properties|yml] 文件 而 portal.[properties|yml] 将覆盖 application.[properties|yml] 中的相应配置
 示例
# 文件中的相应属性逐级覆盖 application.yml portal.yml portal-prod.yml   正则  配置文件匹配
spring: cloud: config: server: git: uri: https://github.com/spring-cloud-samples/config-repo repos: development: pattern: - &amp;#39;*/development&amp;#39; - &amp;#39;*/staging&amp;#39; uri: https://github.com/development/config-repo staging: pattern: - &amp;#39;*/qa&amp;#39; - &amp;#39;*/production&amp;#39; uri: https://github.com/staging/config-repo   参考 文档  Part II. Spring Cloud Config 微服务之分布式配置中心Cloud Config spring cloud 学习(5) - config server spring boot 2 使用 actuator 404的问题 []() []() []()  代码  yqjdcyy/Hello_Spring_Cloud  </content>
    </entry>
    
     <entry>
        <title>茶</title>
        <url>http://domain.yqjdcyy.com/post/%E8%8C%B6/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>茶</tag>
        </tags>
        <content type="html">  分类 绿茶  介绍  未发酵茶 产量最多  工艺  杀青 揉捻 干燥  类型  龙井 碧螺春 雀舌  饮法  80℃ 40s   红茶  介绍  全发酵茶 红汤、红叶  工艺  萎凋 揉捻 发酵 干燥  类型  祁红 正山小种 滇红  饮法  100℃ 3m   乌龙茶  介绍  半发酵茶 绿叶红镶边  工艺  萎凋 做青 杀青 揉捻 干燥  类型  安溪铁观音 武夷大红袍 铁罗汉 白鸡冠 半天妖 单纵  饮法  90℃ 2m   黄茶  介绍  轻发酵茶 黄叶、黄汤  工艺  杀青 揉捻 闷黄 干燥  类型  黄芽茶 黄小茶 黄大茶  饮法  95℃ 3m   黑茶  介绍  重度发酵茶 叶色呈暗褐色  工艺  杀青 揉捻 渥堆 干燥  类型  普洱 六堡茶 安化黑茶 湖北老青茶  饮法  100℃ 2m   白茶  介绍  加工时不炒不揉，保留茶叶的细嫩白色绒毛 一年茶，三年药，七年宝  工艺  萎凋 干燥  类型  银针 白牡丹 贡眉 寿眉  饮法  100℃ 1m   再加工茶  介绍  将上述基茶薰制处理而成   品法 香气  果香|糖香 坚果香 菜香|花香  浓淡  茶性强弱  口感  滑度  大  细腻|顺口  小  粗糙    回甘 层次 工艺 萎凋  恒定温度、温度下摊放干燥  做青  摇青 晾青  杀青  通过高温破坏鲜茶叶中的氧化酶  揉捻  将茶叶揉捻弯曲  干燥 闷黄  将杀青或揉捻或初烘后的茶叶趁热堆积，使茶坯在湿热作用下逐渐黄变  渥堆  将茶叶堆高后洒水保温发酵后，再行晾干  名茶 绿茶  西湖龙井 黄山毛峰 六安瓜片 太平猴魁 洞庭碧螺春 恩施玉露 信阳毛尖 都匀毛尖 安吉白茶 南京雨花茶 安溪铁观音  红茶  正山小种 金骏眉 祁门红茶 云南滇红 坦洋工夫 政和工夫 白琳功夫 川红工夫  乌龙茶  大红袍 水仙 肉桂 凤凰单枞 冻顶乌龙  黄茶  君山银针 霍山黄芽 蒙顶黄芽 皖西黄大茶 广东大叶青 北港毛尖 沩山白毛 平阳黄汤  黑茶  安化黑茶 雅安黑茶 普洱茶 湖北老青茶 四川边茶  白茶  白毫银针 白牡丹 寿眉 贡眉  补充 武夷岩茶 树种  水仙 肉桂 菜茶 矮脚乌龙  范围  名丛  三坑两涧  悟源涧 流香涧 牛栏坑 慧苑坑 倒水坑   正岩茶  九曲溪沿岸  半岩茶  武夷山景区内  洲茶  崇安县境内  外山茶  崇安县境外   品种  名丛  大红袍 水金龟 白鸡冠 铁罗汉  拼配  大红袍 水仙 肉桂  龙肉  九龙窠肉桂  虎肉  虎啸岩肉桂  牛肉  牛栏坑肉桂  50亩/10户  2~6w/500g  心头肉  天心岩肉桂  狮肉  青狮岩肉桂  鬼肉  鬼洞肉桂  象肉  象鼻岩肉桂  羊肉  洋墩岩肉桂  马肉  马头岩肉桂  猪肉  竹窠肉桂    奇种  故事  母树大红袍生产于天心岩九龙窠，现已停止采摘 2005年，20g 母树大红袍拍卖达 20.8 万  参考  中国十大名茶 茶叶分类 茶叶种类 茶 究竟是怎么分类的？ 茶叶分类及十大名茶 八张图，让你立马看懂武夷岩茶！ 全肉宴！武夷岩茶肉桂传奇！  整理  茶.xmind  </content>
    </entry>
    
     <entry>
        <title>Hello.Spring.Cloud</title>
        <url>http://domain.yqjdcyy.com/post/hello.spring.cloud/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Spring.Cloud</tag>
        </tags>
        <content type="html">  架构 API 调用  内容  API 调用方  类型  PC Phone Client   服务治理 服务注册与发现  内容  基于 REST 的服务注册、发布、故障转移  类型  Netfix Eureka  类型  AP  作用  服务的注册与发布  功能  注册 发布 熔断 负载 降级  实现  Netflix 公司开发 C-S 架构 使用客户端连接到服务，并维护心跳连接  推荐  集群保障   Spring Cloud Consul  类型  CP  作用  支持多数据中心的分页式高可用的服务发布和配置共享  功能  健康检测 支持 Http 和 DNS 协议调用 API  实现  HashiCorp 公司开发 Go 语言开发 基于 Mozilla Public License 2.0 协议开源 与 Docker 无缝集成   Spring Cloud Zookeeper  类型  CP  作用  为分页式应用提供一致性服务  功能  配置维护 域名服务 分布式同步 组维护  实现  Google.Chubby 的开源实现     服务调用 调用端熔断器  内容  在远程服务不可用时自动熔断，并在远程服务恢复时自动恢复  类型  Hystrix  优势  避免基础服务故障导致的级联故障  阀值  20/5s  打开断路后，服务转到 fallback 并返回固定值   功能  断路器 资源隔离 自我修复  扩展  Hystrix Dashboard  实时监控各请求的响应时间、成功率等  Turbine  汇总各服务数据      调用端负载均衡  内容  提供客户端的负载均衡算法  类型  Ribbon  优势  易于与 Eureka 等服务发布组件集成 使用 Archaius 完成运行时配置 使用 JMX 暴露去给指标 使用 Servo 发布 多种可插拨的序列化选择  策略  简单轮询 加权响应时间 区域感知轮询 随机负载     调用端代码封装抽象  内容  服务调用端代码的抽取和封装  类型  Feign  功能  可插拨的注解支持  Feign JAX-RS  可插拨的 HTTP 编解码器 支持 Hystrix 支持 Ribbon 支持 Http 请求和响应的压缩     服务路由和过滤  内容  作为资源的统一访问接口，实行校验、请求等功能  类型  Zuul  作用  提供动态路由、监控、弹性和安全服务  功能  负载均衡 反射代理 权限认证 动态路由 监控  实现  Servlet 2.5 JVM 路由 阻塞 API 不支持长连接，如 websockets Filter   Gateway  作用  通过横切方式关注案例性、监控、指标和弹性  功能  动态路由 过滤 可修改下游的 Http 的请求和响应  实现  Java 8 Spring Framework 5 Spring Boot 2     服务监测  内容  监测各端的运行情况  类型  Spectator  作用  用于收集客户端的相关指标   Servo  作用  应用监控库   Atlas  作用  存储于内存的，以时间为主线的，多维度数据库     分页式链路监控 埋点  内容  全自动、可配置的数据的埋点  类型  Spring Cloud Sleuth  作用  日志收集工具包  功能  调用链分析 服务调用关系 请求调用链 调用链各环节的消费时间  实现  封装服务  Dapper logbased 追踪 Zipkin.HTrace      收集  内容  埋点数据的收集、存储、统计与展示  类型  Zipkin  作用  实现数据的收集、存储、查找和展现的分布式追踪系统  存储方式  Im-Memory MySql Cassandra Elasticsearch  实现  Twitter 公司开源     消息组件  内容  微服务间的异步通信 功能  发布订阅 分组消费 消息分片   类型  Spring Cloud Stream  作用  微服务间消息通信的基础框架  功能  封装第三方消息中间信实现  Redis RabbitMQ Apache Kafka   实现  基于 Spring Boot 创建 使用 Spring integration 提供与消息代理间的连接   Spring Cloud Bus  作用  微服务间的消息通信  实现  基于 Spring Cloud Stream Spring Cloud Stream  场景  结合 Spring Cloud Config 实现动态的配置修改     配置中心  内容  服务配置的动态管理  类型  Spring Cloud Config  作用  配置管理  功能  配置存储 接口  来源  本地存储 Git Subversion   Archaius  作用  配置管理  功能  动态类型化属性 配置操作  线程安全  轮询 回调  原理  每隔固定时间，从配置源读取一次内容  默认配置为 60s      安全控制  内容  基于 OAUTH2 安全标准的认证和授权 功能  单点登录 资源授权 令牌管理   类型  Spring Cloud Security  作用  为应用程序添加安全控制  功能  OAuth2  实现  对Spring Security的封装     集群工具  内容  辅助集群服务的调用  功能  集群选主 分布式锁 一次性令牌 暂未实现  类型  Spring Integration  作用  异步消息驱动不同系统间的交互  功能  轻量级的事件驱动交互框架 基于适配器的灵活的系统间交互   Spring Cloud Cluster  作用  负载均衡  功能  选举 集群状态一致性 全局锁 tokens     命令行工具  内容  以命令行或脚本方式管理微服务、组件  类型  Spring Cloud CLI   补充 大数据 Spring Cloud Data Flow  作用  针对大量数据的处理、开发的编程模型和托管服务  模式  ETL  Extract-Transform-Load 描述将数据从来源端经过抽取（extract）、交互转换（transform）、加载（load）至目的端的过程  批量运算 持续运算  功能  自动部署  实现  基于 Spring Boot 的 stream 和 task/batch 重构的流处理和批处理 原生支持  Cloud Foundry Apache YARN Apache Mesos Kubernetes    定时任务 Spring Cloud Task  作用  针对短效、定期任务的管理  功能  调度实现  完成后自动停止，释放系统占有的资源、线程 Quartz 为常驻线程模式  支持多数据库  DB2 H2 HSQLDB MySql Oracle Postgres SqlServer    其它 Spring Cloud Connectors  功能
 简化连接到服务的过程 从云平台获取操作
Spring Cloud Starters  作用
 Spring Boot 式的启动项目，提供开箱即用的依赖管理
Spring Cloud Foundry  作用
 开源 PaaS 云平台  功能
 多框架支持 多语言支持  实现
 VMWare 推出   概念 IasS  全称  Infrastructure-as-a-service  描述  基础设施服务  内容  计算 存储 网络  示例  AWS Azure AliYun   PaaS  全称  Platform-as-a-service  描述  平台服务  内容  MySql angodb RabbitMQ Java NodeJs  示例  CloudFoundry OpenShift   Saas  全称  Software-as-a-service  描述  软件服务  内容  Email IM Facebook Twitter  示例  所有应用   BBF  全称  Backend For Frontend  作用  作为逻辑层聚合底层服务，针对多端进行展示   原理 CAP  全称  布鲁尔定理  定义  分布式系统，无法同时满足如下三点  Consistency  一致性 所有节点访问同一份最新数据副本  Availability  可用性 每次请求均能获取非异常响应  不保证获取的为最新的数据   Partition tolerance  分区容错性  始终成立  不同网络分区间通信允许失败     参考 Spring.Cloud  Spring Cloud技术分析（序） Spring Cloud 项目综述 网易乐得-Spring Cloud 大话Spring Cloud Spring Cloud netflix概览和架构设计  包含服务的相关异常  springcloud(九)：配置中心和消息总线  /bus/refresh 引起 Eureka 连接断开  微服务架构集大成者—Spring Cloud  包含各组件的详细介绍  史上最简单的 SpringCloud 教程  Spring.Component  Spring Cloud Gateway 入门 spring cloud task Spring Security  补充 CAP  CAP 定理的含义 CAP定理  其它  IaaS，PaaS，SaaS 的区别 BFF —— Backend For Frontend OAuth2（重点），参考文档 Spring Security OAuth2，参考文档  整理  Spring.Cloud.xmind  </content>
    </entry>
    
     <entry>
        <title>经典</title>
        <url>http://domain.yqjdcyy.com/post/%E7%BB%8F%E5%85%B8/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>经典</tag>
        </tags>
        <content type="html">  故事 梁思成&amp;amp; 林徽因  婚前，梁思成问林徽因：“有一句话，我只问这一次，以后都不会再问，为什么是我？” 林徽因答：“答案很长，我得用一生去回答你，准备好听我说了吗？ 两姓联姻，一堂缔约，良缘永结，匹配同称。看此日桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。谨以白头之约，书向鸿笺，好将红叶之盟，载明鸳谱. - 民国时期结婚证书
 落水  女生问：我和你妈掉水里了，你先救谁，只能救一个。男生应该这样答：救我妈，她给了我生命。然后和你一起死，因为没有你，生命对我没有意义”。
 52赫兹鲸鱼 | 52-hertz whale  一条在太平洋出没，发出不寻常52赫兹声音的鲸鱼。 由于它叫声的频率比起任何已知品种的鲸鱼都高很多（蓝鲸的频率为10-39赫兹；长须鲸为20赫兹），因此科学家认为它的叫声一直无法被其他鲸鱼接收得到，所以亦称它为“世界上最寂寞的鲸鱼”（The world&amp;rsquo;s loneliest whale）。
 她语  刘若英  《原来你也在这里》  爱是天时地利的迷信。   王菲  一个女人的美丽，一分姿色，二分打扮、三分聪明，四分淫荡。  冯唐  望着窗外,只要想起一生中后悔的事 梅花便落满了南山  张枣
 《镜中》  你没有如期归来，而这也正是离别的意义。   北岛  我在最深的绝望里，遇见最美丽的惊喜。  几米  《希望井》  她不需要做爱，但是可以做；他需要做爱，但是可以不做——这是美人与英雄的分野。   李敖  说来好笑。你千万别跟任何人谈任何事情。你只要一谈起，就会想念起每一个人。  J·D·塞林格
 《麦田里的守望者》  吵到最后，我们什么都骂出来了，就像一对不共戴天的仇敌。我们互相太熟悉了，因而我们刺向对方的刀刃格外锋利，弹无虚发，沉重打击了对方。   王朔  《过把瘾就死》  好的爱情是你通过一个人看到整个世界，坏的爱情是你为了一个人舍弃世界。   《两小无猜》  年轻吗 不要紧 听过几首歌 爱过几个人 就老了  独木舟  《深海里的星星Ⅱ》  我感到难过，不是因为你欺骗了我，而是因为我再也不能相信你了。   尼采  我来不及认真地年轻，待明白过来时，只能选择认真地老去。  三毛  如果你给我的，和你给别人的是一样的，那我就不要了。 人性本凉薄，又何介谁比谁更多。心，若没有栖息的地方，到哪里都是流浪&amp;hellip; 你说你喜欢雨，但是你在下雨的时候打伞。你说你喜欢太阳，但是你在阳光明媚的时候躲在阴凉的地方。你说你喜欢风，但是在刮风的时候你却关上窗户。这就是为什么我会害怕你说你也喜欢我。  莎士比亚  所有男孩子在发誓的时候都是真的觉得自己一定不会违背承诺，而在反悔的时候也都是真的觉得自己不能做到。所以誓言这种东西无法衡量坚贞，也不能判断对错，它只能证明，在说出来的那一刻，彼此曾经真诚过。  王小波  人的一切痛苦，本质上都是对自己的无能的愤怒。 我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。 我选择沉默的主要原因之一：从话语中，你很少能学到人性，从沉默中却能。假如还想学得更多，那就要继续一声不吭 。 不管我本人多么平庸，我总觉得对你的爱很美。  教父  第一步要努力实现自我价值，第二步要全力照顾好家人，第三步要尽可能帮助善良的人，第四步为族群发声，第五步为国家争荣誉 女人和小孩能够粗心大意，但男人不行  林语堂  孤独这两个字拆开来看，有孩童，有瓜果，有小犬，有蝴蝶，足以撑起一个盛夏傍晚间的巷子口，人情味十足。稚儿擎瓜柳棚下，细犬逐蝶窄巷中，人间繁华多笑语，惟我空余两鬓风。——孩童水果猫狗飞蝶当然热闹，可都和你无关，这就叫孤独。   反思  看破浮生过半，心情半佛半神仙， 走火入魔，就成功了一半。 将心比心，便是佛心。 处事谨慎如鼠，为人心狠如狼。 恕心养到极处，世间都无罪过。 博学审问慎思明辨笃行。 轻仇者寡恩，轻义者寡情，轻孝着最无情。 在你二十几岁的时候，给优秀的人工作；在三十几岁时跟优秀的人合作；在四十几岁时找优秀的人为你工作；而到了五十几岁时，努力使别人成为更加优秀的人. 喜不喜欢，适不适合，在不在一起，是三件不同的事情。 一命二运三风水四积阴德五读书六名七相八敬神九交贵人十养生十一择 少年贪玩，青年迷恋爱情，壮年汲汲于成名成家，暮年自安于自欺欺人。 世界是自己的，与他人毫无关系。 和男人相处，要义就是：若他情窦初开，你就宽衣解带；若他阅人无数，你就灶边炉台。  和女人相处，要义就是： 若她涉世未深，就带她看尽人间繁华； 若她心已沧桑，就带她坐旋转木马。  别人稍一注意你，你就敞开心扉，你觉得这是坦率，其实这是孤独。  </content>
    </entry>
    
     <entry>
        <title>Hello.Spring</title>
        <url>http://domain.yqjdcyy.com/post/hello.spring/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Spring</tag>
        </tags>
        <content type="html">  架构 架构图  4.2.x    x.x.x     模块  Core  BeanFactory  Dependency Injection  Utils  AOP  元数据 AOP 基础架构  ORM  对象关系映射 支持  Hibernate iBatis JDO   WEB DAO  事务 JDBC 抽象 DAO  WEB.MVC  MVC Framework views JSP/ Velocity PDF/ Excel  Context  应用上下文 UI Validation JDNI EJB Email 国际化  I18N    包  spring-aop spring-aspects spring-beans spring-context  IoC功能扩展服务  邮件 任务调度 JDNI EJB集成 远程访问 缓存 视图框架封装   spring-context-support  用于将第三方类引入至 Spring 应用上下文  ehcache JCA JMX JavaMail Quartz   spring-core spring-expression spring-instrument  服务器代理接口  spring-instrument-tomcat spring-jdbc spring-jms  Java Message Service  spring-messaging spring-orm spring-oxm  Object与 XML 的相互转换支持  spring-test spring-tx  事务  spring-web  Web 开发核心类  WebApplicationContext Struts JSF Resource.Upload Filter Utils   spring-webmvc  图际化 标签 Theme View  FreeMarker JasperReports Tiles Velocity XSLT   spring-websocket  支持 portlet 标准   原理 DI  全称  Dependency Injection  概念  将其参数的实例传递给所属对象  方式  构建函数 Setter  示例
public class Hunter { private Weapon weapon; public Hunter(Weapon weapon) { this.weapon = weapon; } } public class Hunter { private Weapon weapon; public void setWeapon(Weapon weapon) { this.weapon = weapon; } }  IoC  全称  Inversion of Control  概念  由系统内对象监管中心，将目标所需要的对象的引用传递给该目标对象  方式  依赖注入 依赖查找   AOP 描述  Aspect Orient Programming 面向方面（切面）编程，用于处理系统中分布中各模块的横切关注点，如事务、日志、缓存、对象池  类型  静态  使用 AOP 框架提供的命令进行编译，从而在编译阶段生成 AOP 代理类 编译时增强 AspectJ  动态  运行时借助于 JDK 动态代理、CGLIB等在内存临时生成动态代理类  通过注解以定义 方面（Aspect）、切入点（Pointcut）和增强处理（Advice）  运行时增强 Spring AOP  JDK 动态代理  要求被代理类必须有一个实现接口 通过 Proxy.newProxyInstance(ClassLoader, Class&amp;lt;?&amp;gt;[], InvocationHandler h) 实现  CGLIB 动态代理  底层通过 asm 来生成 生成类效率较低（但可通过将生成类缓存以提升效率），执行时效率较高 通过继承方式动态代理，若类被标记为 final 则无法使用 具体通过 implements MethodInterceptor 和 Enhancer 生成     实现  AspectJ
// 1.基类 public class Hello { public static void main(String[] args) { new Hello().say(); } public void say() { System.out.println(&amp;#34;Hello&amp;#34;); } } // 2.切面设置类 public aspect HelloAspect { void around():call(void Hello.say()){ System.out.println(&amp;#34;Hello.Aspect start&amp;#34;); proceed(); System.out.println(&amp;#34;Hello.Aspect end&amp;#34;); } } // 3. Intellij 为当前项目设置 Aspecj 处理  // 3.1 到 AspectJ 官网下载 Jar 包  // 3.2 参照 《Creating a Library for aspectjrt.jar》将 =aspectjrt.jar 作为 library 添加至当前项目  // 4.直接运行 Hello 项目即可  // Hello.Aspect start  // Hello  // Hello.Aspect end Spring.AOP
 Commons
// * 必须指定作用于方法，于运行时生效 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Timer { } @Aspect @Component public class Advice { // 指定横切点，此处为对指定注解生效  @Pointcut(&amp;#34;@annotation(com.yao.aop.spring.Timer)&amp;#34;) public void pointcut() { } // 对指定横切点增强  @Before(&amp;#34;pointcut()&amp;#34;) public void before() { System.out.println(&amp;#34;\tAdvice.before&amp;#34;); } } JDK
public interface Person { String say(String name); } // JDK 接口对象创建时，必须创建实现类以供 jdk 调用生成 @Component public class Chinese implements Person { @Timer @Override public String say(String name) { name = &amp;#34;中国人讲：&amp;#34; &#43; name; System.out.println(name); return name; } } CGlib
// 只需注意非 final 类型即可 @Component public class American { @Timer public String say(String name) { name = &amp;#34;American.say: &amp;#34; &#43; name; System.out.println(name); return name; } public void eat(String food) { System.out.println(&amp;#34;I&amp;#39;m eating &amp;#34; &#43; food); } }  Call
@SpringBootApplication @ComponentScan // 切面注解自动代理 @EnableAspectJAutoProxy @RestController public class AOPApplication { @Autowired private Person chinese; @RequestMapping(&amp;#34;/aop/spring/jdk&amp;#34;) public void jdk() { chinese.say(&amp;#34;Hi&amp;#34;); System.out.println(chinese.getClass()); } @Autowired private American american; @RequestMapping(&amp;#34;/aop/spring/cglib&amp;#34;) public void cglib() { american.say(&amp;#34;Hi&amp;#34;); american.eat(&amp;#34;potato&amp;#34;); System.out.println(american.getClass()); } public static void main(String[] args) { SpringApplication.run(AOPApplication.class, args); } }   详解 Spring.AOP 关键词  Aspect  横切关注点的抽象  JoinPoint  拦截点  方法 字段 构造函数  Spring 仅支持方法拦截  PointCut  对拦截点的定义  Advice  通知、增强 类型  Before After After-Returning After-Throwing Around   Target  代理的目标对象  Weave  织入 将切面应用到目标对象，并代理对象创建的过程  Introduction  运行期，动态地为类添加字段、方法   注解 PointCut  用法
 @Pointcut(&amp;quot;within(@org.springframework.stereotype.Repository *)&amp;quot;) @Around(&amp;quot;repositoryClassMethods()&amp;quot;) xml
&amp;lt;aop:config&amp;gt; &amp;lt;aop:pointcut id=&amp;#34;anyDaoMethod&amp;#34; expression=&amp;#34;@target(org.springframework.stereotype.Repository)&amp;#34;/&amp;gt; &amp;lt;/aop:config&amp;gt;  标示符
 execution  描述  通用匹配  格式  @Pointcut(&amp;quot;execution(&amp;lt;作用域&amp;gt; &amp;lt;返回值&amp;gt; &amp;lt;路径&amp;gt;.&amp;lt;类&amp;gt;.&amp;lt;方法&amp;gt;(&amp;lt;参数&amp;gt;))&amp;quot;)  参数  作用域  public private protected  返回值  Java 对象  路径  包路径  类  类名  方法  方法名  参数  Java 对象   示例  @Pointcut(&amp;quot;execution(* org.baeldung.dao.FooDao.*(..))&amp;quot;)  针对 FooDao 的任意返回值、任意参数的任意方法生效    within  描述  限制于指定匹配类型  格式  @Pointcut(&amp;quot;within(&amp;lt;路径&amp;gt;.&amp;lt;类&amp;gt;)&amp;quot;)  示例  @Pointcut(&amp;quot;within(org.baeldung..*)&amp;quot;)  匹配 org.baeldung 子目录下的任意类型    this|target  描述  匹配指定类型的子类实现 this 创建以 CGLIB 为基础的代理实现  不要求一定要实现接口  target 创建以 JDK 为基础的代理实现  要求一定要实现接口   格式  @Pointcut(&amp;quot;this|target(&amp;lt;路径&amp;gt;.&amp;lt;类&amp;gt;)&amp;quot;)  示例  public class FooDao implements BarDao {}  @Pointcut(&amp;quot;target(org.baeldung.dao.BarDao)&amp;quot;)  public class FooDao {}  @Pointcut(&amp;quot;this(org.baeldung.dao.FooDao)&amp;quot;)    args  描述  用于匹配指定的方法参数  格式  @Pointcut(&amp;quot;execution(* *..&amp;lt;方法&amp;gt;(&amp;lt;参数&amp;gt;))&amp;quot;)  示例  @Pointcut(&amp;quot;execution(* *..find*(Long))&amp;quot;)  匹配任意以 find 开头，且仅有一个 Long 型参数的方法  @Pointcut(&amp;quot;execution(* *..find*(Long,..))&amp;quot;)  匹配任意以 find 开头，且首个参数为 Long 型的方法    @target
 描述  指定包含指定注解的类  格式  @Pointcut(&amp;quot;@target(&amp;lt;注解&amp;gt;)&amp;quot;)  示例  @Pointcut(&amp;quot;@target(org.springframework.stereotype.Repository)&amp;quot;)  匹配添加有 Repository 注解的类    @args
 描述  匹配指定注解的对象作用入参类型的方法  格式  @Pointcut(&amp;quot;@args(&amp;lt;注解&amp;gt;)&amp;quot;)  示例
@PrintArgs(name = &amp;#34;input&amp;#34;) public class Input{} @Before(&amp;#34;@args(input)&amp;#34;)  @within
 描述  指定注解的方法于本类或子类中调用时匹配调用  格式  @Pointcut(&amp;quot;@within(&amp;lt;注解&amp;gt;)&amp;quot;)  示例  @Pointcut(&amp;quot;@within(org.springframework.stereotype.Repository)&amp;quot;)   @annotation
 描述  匹配拥有指定注解的方法  格式  @Pointcut(&amp;quot;@annotation(&amp;lt;注解&amp;gt;)&amp;quot;)  示例  @Pointcut(&amp;quot;@annotation(org.baeldung.aop.annotations.Loggable)&amp;quot;)    匹配
 * ..  作为参数时，代表任意参数形式 作用路径时，代表子目录  &#43;  指定类型的子类型  通过 &amp;amp;&amp;amp; || ! 以组合指示符
@Pointcut(&amp;#34;@target(org.springframework.stereotype.Repository)&amp;#34;) public void repositoryMethods() {} @Pointcut(&amp;#34;execution(* *..create*(Long,..))&amp;#34;) public void firstLongParamMethods() {} @Pointcut(&amp;#34;repositoryMethods() &amp;amp;&amp;amp; firstLongParamMethods()&amp;#34;) public void entityCreationMethods() {}   参考 Spring  Introduction to Spring Framework Introduction to the Spring Framework Spring 框架简介 Spring 模块组成  AOP  Spring AOP的实现原理 Spring AOP 实现原理与 CGLIB 应用 AspectJ 官网 IntelliJ Idea 下配置 AspectJ，及简单 demo Creating a Library for aspectjrt.jar Implementing a Custom Spring AOP Annotation Introduction to Pointcut Expressions in Spring Spring Aop（三）——Pointcut表达式介绍  针对 PointCut 的中文详解，包含示例  Spring AOP &#43; AspectJ annotation examp`le` AOP的底层实现-CGLIB动态代理和JDK动态代理  DI  What is dependency injection? Dependency Injection Demystified Inversion of Control Containers and the Dependency Injection pattern  IoC  http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/ 控制反转（IoC）与依赖注入（DI）  整理  Spring.xmind  </content>
    </entry>
    
     <entry>
        <title>Hello.GraphQL</title>
        <url>http://domain.yqjdcyy.com/post/graphql/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>GraphQL</tag>
        </tags>
        <content type="html">  简介 因果  大量并发请求和数据更新的二次请求，造成响应和维护的难度提升 不同 app 对相同资源的不同使用方法导致 API 爆炸性增长 大而全的通用性接口又不利于移动端使用  优点  足够描述性的数据抓取通用性 API 服务端解释后返回以特定形式  类型  Query  query { hero { name } droid(id: &amp;#34;2000&amp;#34;) { name } }  Mutation  mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) { createReview(episode: $ep, review: $review) { stars commentary } } { &amp;#34;ep&amp;#34;: &amp;#34;JEDI&amp;#34;, &amp;#34;review&amp;#34;: { &amp;#34;stars&amp;#34;: 5, &amp;#34;commentary&amp;#34;: &amp;#34;This is a great movie!&amp;#34; } } 请求即输出  请求格式与返回格式近似 任性地满足产品和开发的数据驱动要求  等级分层  遵循对象层级、关系  服务端需多次网络请求或复杂 SQL 查询  促进服务端以层次、图形化结构存储  强类型  每个层级的查询都对应着特定的类型，而每个类型都描述以一组可用的字段 允许 GraphQL 于执行查询前抛出描述性异常信息  协议而非存储  每个 Graphql 字段均有任意方法支持 复杂的排序、存储模型 依赖现有的实现，而不指定或提供任何备份存储  内省  提供强大的平台 帮助开发学习和探索 API，而不需要依赖代码库或 CURL 工具  版本无关  字段弃用等并不影响数据输出 渐进的向后兼容过程消除了版本号的需要  教程 查询&amp;amp;变更 请求 # 指定 **操作类型**[query|mutation|subscription]、**操作名称**(明确操作的意义、便于排查) query UserSystem{ # 参数传替 &amp;amp; 变量调用 human(id: $id) { name # 支持多级选择 ## 标量以枚举 `CUSTOM` 作为参数，实现服务端转换 ## 构建组件，通过参数控制 friends(type: CUSTOM) @include(if: $withFriends) { name }, # 别名 site: human(id: &amp;#34;2&amp;#34;){ # 无字段，获取该位置对象类型的名称 __typename name }, # 重复片段 admins: human(type: ADMIN){ ...complexFields }, users: human(type: USER){ ...complexFields }, } } # 变量定义 ## v1 variables{ &amp;#34;id&amp;#34;: 1, &amp;#34;withFriends&amp;#34;: true } ## v2 ### 声明类型值可为 标量| 枚举| Schema.Object ### ! 表示是否是可选项 ### = 指定默认值 query UserSystem($id: [声明类型][!]= &amp;#34;默认值&amp;#34;) # 片段定义 ## v1 fragment complexFields on human{ id name } ## v2 ### 内联片段，仅在返回类型是 `human` 情况下执行 ... on human{ id } # 指令 ## @include(if: Boolean) 仅当为 true 时包含 ## @skip(if: Boolean) 仅当为 true 跳过 输出 { &amp;#34;data&amp;#34;:{ # 多级 &amp;#34;human&amp;#34;:{ &amp;#34;name&amp;#34;: &amp;#34;R2-D2&amp;#34;, &amp;#34;friends&amp;#34;: [ {&amp;#34;name&amp;#34;: &amp;#34;Luke&amp;#34;}, {&amp;#34;name&amp;#34;: &amp;#34;Han&amp;#34;}, ] }, # 别名 &amp;#34;site&amp;#34;:{ &amp;#34;__typename&amp;#34;: &amp;#34;human&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;绝地神殿&amp;#34; }, # 片段 &amp;#34;admins&amp;#34;:[ { &amp;#34;id&amp;#34;: 1, &amp;#34;name&amp;#34;: R2-D2&amp;#34;, } ], &amp;#34;users&amp;#34;:[ { &amp;#34;id&amp;#34;: 2, &amp;#34;name&amp;#34;: Han&amp;#34;, } ], } } Schema 对象  GraphQL.newObject  type Character { # 非空文本 name: String! # 非空数组 appearsIn: [Episode]! } 参数 type User{ # 当 unit 参数未传值时，将其默认为 `METER` momey(unit: LengthUnit = METER): Float } 标量  对应 GraphQL 查询的子节点,系统最小颗粒 系统默认标题  Int 有符号 32 位整数。 Float 有符号双精度浮点值。 String UTF‐8 字符序列。 Boolean true 或者 false。 ID ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键，不可人为阅读类型  自定义标量 Date  scalar Date 枚举  可在 Schema 中任意处使用 定义  enum Role{ ADMIN USER } 列表 human{ # 数组本身可为空，但内容值不能为空 name: [String!] # 数组不能为空，但内容值可为空 phone: [String]! } 接口 interface Character{ id: ID! name: String! } # 可结合内联片段实现调用 type Human implements Character{ id: ID! name: String! friends: [Character] } 联合类型  不指定类型之前的共同字段，只表示返回联合类型的地方，可能得到其定义中的任一类型对象  union SearchResult = Human | Droid | Starship  输入类型 定义修改时的所需的复杂输入对象  mutation CreateInput($obj: InputObj){ create(obj: $obj){ id name } } input InputObj{ id: Int! Name: String! } variables{ &amp;#34;obj&amp;#34;{ &amp;#34;id&amp;#34;: 1, &amp;#34;name&amp;#34;: 10 } } 参考 官方  GraphQL 入门 GraphQL GraphQL: A data query language facebook/graphql  补充  Graphql入门 30分钟理解GraphQL核心概念  框架  GraphQL graphql-go/graphql Introduction to GraphQL  代码  golang-graphql-demo  </content>
    </entry>
    
     <entry>
        <title>Java.Collections 60%</title>
        <url>http://domain.yqjdcyy.com/post/java.collections/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  [TOC]
Structure Image    Text Iterable  Collection  List AbstractCollection  AbstractList  Vector  Stack  ArrayList SubList  RandomAccessSubList  AbstractSequentialList  LinkedList   ArrayDeque AbstractQueue  PriorityQueue  AbstractSet  EnumSet  RegularEnumSet JumboEnumSet  TreeSet HashSet  LinkedHashSet    Queue  Deque  Set  SortedSet  NavigableSet    ServiceLoader  Map  SortedMap  NavigableMap  Abstractmap  WeakHashMap IdentityHashMap EnumMap TreeMap HashMap  LinkedHashMap    Dictionary  Hashtable Properties  Utils  Collections Arrays  Tidy Iterable  methods  iterator() forEach(Consumer&amp;lt;? super T&amp;gt; action)   Collection  methods  check  contains(Object o) retainAll(Collection&amp;lt;?&amp;gt; c)  stream  iterator() Object[] toArray()  operate  add(E e) remove(Object o) addAll(Collection&amp;lt;? extends E&amp;gt; c) removeAll(Collection&amp;lt;?&amp;gt; c) clear()    List  description  extends Collection 排序数据，允许 重复或 空  methods  operate  get(int index) set(int index, E element) add(int index, E element) remove(int index) indexOf(Object o) lastIndexOf(Object o) containsAll(Collection&amp;lt;?&amp;gt; c) addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) default void replaceAll(UnaryOperator operator) sort(Comparator&amp;lt;? super E&amp;gt; c)  stream  subList(int fromIndex, int toIndex)    AbstractCollection  description  最小接口框架  methods  abstract Iterator&amp;lt;E&amp;gt; iterator() abstract int size() add(E e) {throw new UnsupportedOperationException();}   AbstractList  description  随机存取的最小框架 不强制要求提供 iterator 实现  methods  subList(int fromIndex, int toIndex) removeRange(int fromIndex, int toIndex)   Vector  description  可增长数组，自动进行扩容、收缩 通过 capacity 和 capacityIncrement 来控制容量的变化 iterator 在检测到异常时快速失败  iterator创建后， vector 在结构上发生了调整 无法确保非同步情况下的修改同步  在不需要保障线程安全的情况下，推荐使用 ArrayList 代替  params  Object[] elementData int elementCount  容器实际使用情况  int capacityIncrement  容器单次扩容值，若为负数则每次扩容一倍  int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8  允许分配的数组 最大尺寸，预留操作系统将头数据存于数组的情况 分配更大的数据情况下，抛出 OutOfMemoryError  transient int modCount = 0  transient 保障序列化前后不影响该值   methods
 iterator() elements() add(E e)
ensureCapacityHelper(elementCount &#43; 1) int newCapacity = oldCapacity &#43; ((capacityIncrement &amp;gt; 0) ?capacityIncrement : oldCapacity); elementData[elementCount&#43;&#43;] = e;   Stack  description
 先进后出栈  methods
 E push(E item) synchronized E pop()   ArrayList  description
 可扩展队列，允许空值 添加元素花费固定时间 O(n)，其它操作为线性时间 不支持多线程同步  必须于外部扩展支持多线程 如 List list = Collections.synchronizedList(new ArrayList(...));  iterator() 快速失败机制  params
 transient Object[] elementData  序列化时忽略该值，并通过 (write|read)Object 实现序列结果 保证序列时仅操作存储数据，而非完整数组  protected transient int modCount = 0  methods
 void ensureCapacity(int minCapacity)
if (minCapacity &amp;gt; minExpand) { ensureExplicitCapacity(minCapacity){ if (minCapacity - elementData.length &amp;gt; 0) grow(minCapacity){ int oldCapacity = elementData.length; int newCapacity = oldCapacity &#43; (**oldCapacity &amp;gt;&amp;gt; 1**); if (newCapacity - minCapacity &amp;lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } } } void writeObject(java.io.ObjectOutputStream s)
 void readObject(java.io.ObjectInputStream s)
 void sort(Comparator&amp;lt;? super E&amp;gt; c)
final int expectedModCount = modCount; // TODO if (modCount != expectedModCount) { // 判断是否值变更以确认是否有其它线程操作  throw new ConcurrentModificationException(); } modCount&#43;&#43;;   SubList  description
 子列表的相关操作  params
 final AbstractList l  存储初始化列表  final int offset  指定子列表相对初始化列表的开始位置  int size  指定子列表的长度   methods
 List.*
 E set(int var1, E var2)
public E set(int var1, E var2) { this.rangeCheck(var1); // check index out of boundary  this.checkForComodification(); // check other thread update the structure  return this.l.set(var1 &#43; this.offset, var2); }    RandomAccessSubList  description
 SubList 的重命名版  params
 methods
 RandomAccessSubList(AbstractList&amp;lt;E&amp;gt; list, int fromIndex, int toIndex)
class RandomAccessSubList&amp;lt;E&amp;gt; extends SubList&amp;lt;E&amp;gt; implements RandomAccess { RandomAccessSubList(AbstractList&amp;lt;E&amp;gt; list, int fromIndex, int toIndex){ super(list, fromIndex, toIndex); }   AbstractSequentialList  description
 序列化访问列表的最小实现框架  而随机访问的则是 AbstractList  列表，需要实现 listIterator 和size 无法修改的列表，需实现 hasNext、next、hasPrevious、previous、index 可修改的列表，需实现 set 可变长列表，需实现 remove、add  params
 methods
 get|set|add|remove|addAll iterator() abstract ListIterator&amp;lt;E&amp;gt; listIterator(int index)   LinkedList  description
 双向连接列表 不支持同步操作  需在外部进行同步支持 或使用 synchronizedList  于创建时使用，如 List list = Collections.synchronizedList(new LinkedList(...));    params
 transient int size = 0 transient Node first transient Node last  methods
 (link|unlink|get|remove|add)[(First|Last)] (write|read)Object
s.defaultWriteObject(); s.writeInt(size); for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) s.writeObject(x.item); Node&amp;lt;E&amp;gt; node(int index)
if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) { Node&amp;lt;E&amp;gt; x = first; for (int i = 0; i &amp;lt; index; i&#43;&#43;) x = x.next; return x; } else { Node&amp;lt;E&amp;gt; x = last; for (int i = size - 1; i &amp;gt; index; i--) x = x.prev; return x; }   ArrayDeque  description
 可扩展数组 非线程安全 禁止添加 Null 比 stack、LinkedList 更快  params
 transient Object[] elements transient int head transient int tail  methods
 private boolean delete(int i)
final Object[] elements = this.elements; final int mask = elements.length - 1; final int h = head; final int t = tail; final int front = (i - h) &amp;amp; mask; final int back = (t - i) &amp;amp; mask; // 判断序列值是否超过实际长度 if (front &amp;gt;= ((t - h) &amp;amp; mask)) throw new ConcurrentModificationException(); // 判断序列值处于前半段或后半段，从而进行最小量的数量移动 if (front &amp;lt; back) { if (h &amp;lt;= i) { System.arraycopy(elements, h, elements, h &#43; 1, front); } else { // Wrap around  System.arraycopy(elements, 0, elements, 1, i); elements[0] = elements[mask]; System.arraycopy(elements, h, elements, h &#43; 1, mask - h); } elements[h] = null; head = (h &#43; 1) &amp;amp; mask; return false; } else { if (i &amp;lt; t) { // Copy the null tail as well  System.arraycopy(elements, i &#43; 1, elements, i, back); tail = t - 1; } else { // Wrap around  System.arraycopy(elements, i &#43; 1, elements, i, mask - i); elements[mask] = elements[0]; System.arraycopy(elements, 1, elements, 0, t); tail = (t - 1) &amp;amp; mask; } return true; } private void allocateElements(int numElements)
if (numElements &amp;gt;= initialCapacity) { // 转为最接近该值的 2^n 次数值  initialCapacity = numElements; initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 1); initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 2); initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 4); initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 8); initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 16); initialCapacity&#43;&#43;; if (initialCapacity &amp;lt; 0) // Too many elements, must back off  initialCapacity &amp;gt;&amp;gt;&amp;gt;= 1;// Good luck allocating 2 ^ 30 elements } public void addFirst(E e)
elements[head = (head - 1) &amp;amp; (elements.length - 1)] = e; public void addLast(E e)
elements[tail] = e; if ( (tail = (tail &#43; 1) &amp;amp; (elements.length - 1)) == head) doubleCapacity();   AbstractQueue  description
 队列的实现框架 不允许空值，失败时直接抛出异常  params
 methods
 boolean add(E e)
if (offer(e)) return true; else throw new IllegalStateException(&amp;#34;Queue full&amp;#34;);   PriorityQueue  description
 无限制优先级队列  构建时通过自然排序或指定排序方式进行优先级调整  不允许空值、无法比较的对象 注意多个元素同为最小值情况 注意  iterator() 不保障队列以任意顺序排列  排序遍历情况可使用 Arrays.sort(pq.toArray())  非线程安全，可用 PriorityBlockingQueue 代替   params
 transient Object[] queue
平衡二进制堆，将队列以树形式进行对比存储，排序最低值存于[0]位 queue[n]= queue[2n&#43;1]&#43; queue[2*(n&#43;1)] 存储形式 [0] [1] [2] [3] [4] [5] [6] 记录形式 [0] [1] [2] [3] [4] [5] [6]  methods
 public PriorityQueue(int initialCapacity) public PriorityQueue(Collection&amp;lt;? extends E&amp;gt; c)
private void initFromCollection(Collection&amp;lt;? extends E&amp;gt; c) { // 拷贝集合元素，并进行非空判断  initElementsFromCollection(c); heapify(); } // 堆化 private void heapify() { for (int i = (size &amp;gt;&amp;gt;&amp;gt; 1) - 1; i &amp;gt;= 0; i--) siftDown(i, (E) queue[i]); } private void siftDown(int k, E x) { if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); } // 插入项，并与低级节点对比至小于等于 private void siftDownComparable(int k, E x) { Comparable&amp;lt;? super E&amp;gt; key = (Comparable&amp;lt;? super E&amp;gt;)x; // 递归到最后一种可能，2*(n&#43;1)  int half = size &amp;gt;&amp;gt;&amp;gt; 1; while (k &amp;lt; half) { // 替换父结点、父亲兄弟结点中的最小值  int child = (k &amp;lt;&amp;lt; 1) &#43; 1; Object c = queue[child]; int right = child &#43; 1; if (right &amp;lt; size &amp;amp;&amp;amp; ((Comparable&amp;lt;? super E&amp;gt;) c).compareTo((E) queue[right]) &amp;gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &amp;lt;= 0) break; queue[k] = c; k = child; } queue[k] = key; } public boolean offer(E e)
public boolean offer(E e) { if (e == null) throw new NullPointerException(); modCount&#43;&#43;; int i = size; if (i &amp;gt;= queue.length) grow(i &#43; 1); size = i &#43; 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; } // 扩容，小于64时加2，否则加一半容量 private void grow(int minCapacity) { int oldCapacity = queue.length; int newCapacity = oldCapacity &#43; ((oldCapacity &amp;lt; 64) ? (oldCapacity &#43; 2) : (oldCapacity &amp;gt;&amp;gt; 1)); if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0) newCapacity = hugeCapacity(minCapacity); queue = Arrays.copyOf(queue, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity &amp;lt; 0) // overflow  throw new OutOfMemoryError(); return (minCapacity &amp;gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } private void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); } // 向根节点递归比较、替换，siftDown 的简化版本 private void siftUpComparable(int k, E x) { Comparable&amp;lt;? super E&amp;gt; key = (Comparable&amp;lt;? super E&amp;gt;) x; while (k &amp;gt; 0) { int parent = (k - 1) &amp;gt;&amp;gt;&amp;gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &amp;gt;= 0) break; queue[k] = e; k = parent; } queue[k] = key; } E removeAt(int i)
private E removeAt(int i) { // assert i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; size;  modCount&#43;&#43;; int s = --size; if (s == i) // removed last element  queue[i] = null; else { E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved); if (queue[i] == moved) { siftUp(i, moved); if (queue[i] != moved) return moved; } } return null; } void (read|write)Object(Object(Input|Output)Stream s)
   AbstractSet  description
 Set 的最小化实现框架  methods
 boolean equals(Object o) int hashCode()
int h= 0 h &#43;= next().hashCode(); boolean removeAll(Collection&amp;lt;?&amp;gt; c)
   EnumSet  description
 创建时指定使用的枚举类型  内部将枚举值转换为位向量，以实现空间和时间执行上的优化  迭代器为弱关联，即生成迭代器时进行修改，不会抛出 ConcurrentModificationException 异常，但不一定会显示修改情况 非线程安全，推荐依赖对象进行同步限制，或使用 synchronizedSet 封装  Set&amp;lt;MyEnum&amp;gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));  所有基础方法均可在常量时间内执行  params
 final Class&amp;lt;E&amp;gt; elementType final Enum&amp;lt;?&amp;gt;[] universe  methods
 实现  EnumSet(Class&amp;lt;E&amp;gt;elementType, Enum&amp;lt;?&amp;gt;[] universe) EnumSet&amp;lt;E&amp;gt; clone()  初始化
 static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; （all|none)Of(Class&amp;lt;E&amp;gt; elementType) static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; copyOf((EnumSet|Collection)&amp;lt;E&amp;gt; s) static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; of(E first, E... rest)
// 将枚举类型设置至 elementType EnumSet&amp;lt;E&amp;gt; result = noneOf(first.getDeclaringClass()); // 添加枚举元素 result.add(first); for (E e : rest) result.add(e); return result;  抽象接口
 abstract void addAll() abstract void addRange(E from, E to) abstract void complement()    JumboEnumSet  description  EnumSet 的私有实现，针对超过64个元素大枚举类型使用 实现思路参照 RegularEnumSet，只是通过 Long 数组来支持更长纬度的数据  params  long elements[] int size = 0  methods
 void addAll() void addRange(E from, E to)
void addRange(E from, E to) { // 计算当前序列位于第几个 Long 的区间上  int fromIndex = from.ordinal() &amp;gt;&amp;gt;&amp;gt; 6; int toIndex = to.ordinal() &amp;gt;&amp;gt;&amp;gt; 6; // 同一区间的话，将该区间视同 RegularEnumSet 即可  if (fromIndex == toIndex) { elements[fromIndex] = (-1L &amp;gt;&amp;gt;&amp;gt; (from.ordinal() - to.ordinal() - 1)) &amp;lt;&amp;lt; from.ordinal(); // 不同区间情况下，需要填充中间区间，并于头尾处各自处理  } else { elements[fromIndex] = (-1L &amp;lt;&amp;lt; from.ordinal()); for (int i = fromIndex &#43; 1; i &amp;lt; toIndex; i&#43;&#43;) elements[i] = -1; elements[toIndex] = -1L &amp;gt;&amp;gt;&amp;gt; (63 - to.ordinal()); } size = to.ordinal() - from.ordinal() &#43; 1; } boolean add(E e)
/*** 通过移位跳转到对应区间，然后对该区间长整型 */ public boolean add(E e) { typeCheck(e); int eOrdinal = e.ordinal(); int eWordNum = eOrdinal &amp;gt;&amp;gt;&amp;gt; 6; long oldElements = elements[eWordNum]; elements[eWordNum] |= (1L &amp;lt;&amp;lt; eOrdinal); boolean result = (elements[eWordNum] != oldElements); if (result) size&#43;&#43;; return result; }   RegularEnumSet  description  EnumSet 的私有实现，针对元素于64位以内 用64位的 long 的各位来指定枚举值在枚举中的对应数值  params  long elements = 0L= 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  methods
 void addAll()
elements = -1L &amp;gt;&amp;gt;&amp;gt; -universe.length; /** -1L = 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 length = 6 &amp;gt;&amp;gt;&amp;gt; -6 = &amp;gt;&amp;gt;&amp;gt; (64&#43; (-6)) -1L&amp;gt;&amp;gt;&amp;gt;-6 = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00111111 */ void addRange(E from, E to)
void addRange(E from, E to) { elements = (-1L &amp;gt;&amp;gt;&amp;gt; (from.ordinal() - to.ordinal() - 1)) &amp;lt;&amp;lt; from.ordinal(); /** from= 5 to= 10 -1l= 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 -1l &amp;gt;&amp;gt;&amp;gt; (5- 10- 1) -&amp;gt; -1l &amp;gt;&amp;gt;&amp;gt; -6 -&amp;gt; -1l &amp;gt;&amp;gt;&amp;gt; (64- 6) // 根据结果推导，不确定 -&amp;gt; 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00111111 -&amp;gt; 63 (-1l &amp;gt;&amp;gt;&amp;gt; (5- 10- 1)) &amp;lt;&amp;lt; 5 -&amp;gt; 63 &amp;lt;&amp;lt; 5 -&amp;gt; 2016 */ } void complement()
 public Iterator&amp;lt;E&amp;gt; iterator()
public Iterator&amp;lt;E&amp;gt; iterator() { return new EnumSetIterator&amp;lt;&amp;gt;(); } private class EnumSetIterator&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; implements Iterator&amp;lt;E&amp;gt; { long unseen; long lastReturned = 0; EnumSetIterator() { unseen = elements; } public boolean hasNext() { return unseen != 0; } @SuppressWarnings(&amp;#34;unchecked&amp;#34;) public E next() { if (unseen == 0) throw new NoSuchElementException(); // 找出最后一位并抛出  lastReturned = unseen &amp;amp; -unseen; unseen -= lastReturned; return (E) universe[Long.numberOfTrailingZeros(lastReturned)]; } public void remove() { if (lastReturned == 0) throw new IllegalStateException(); elements &amp;amp;= ~lastReturned; lastReturned = 0; } } int size()
return Long.bitCount(elements); public static int bitCount(long i) { // 每格两位存储这两位的 1 的数量，等价于 i= i &amp;amp; 0x5555555555555555L &#43; (i&amp;gt;&amp;gt;&amp;gt;1) &amp;amp; 0x5555555555555555L  i = i - ((i &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 0x5555555555555555L); // 此后每次翻倍移位，进行数量累加  i = (i &amp;amp; 0x3333333333333333L) &#43; ((i &amp;gt;&amp;gt;&amp;gt; 2) &amp;amp; 0x3333333333333333L); i = (i &#43; (i &amp;gt;&amp;gt;&amp;gt; 4)) &amp;amp; 0x0f0f0f0f0f0f0f0fL; i = i &#43; (i &amp;gt;&amp;gt;&amp;gt; 8); i = i &#43; (i &amp;gt;&amp;gt;&amp;gt; 16); i = i &#43; (i &amp;gt;&amp;gt;&amp;gt; 32); return (int)i &amp;amp; 0x7f; } boolean contains(Object e)
return (elements &amp;amp; (1L &amp;lt;&amp;lt; ((Enum&amp;lt;?&amp;gt;)e).ordinal())) != 0; /*** elements = 0000 1111 e.ordinal = 3 1L&amp;lt;&amp;lt;3 = 0000 0100 elements&amp;amp;(1L&amp;lt;&amp;lt;3)= 0000 1111 &amp;amp; 0000 0100 0000 0100 = 4 != 0 *指定位比较，其它位清零* */ boolean add(E e)
 elements |= (1L &amp;lt;&amp;lt; ((Enum&amp;lt;?&amp;gt;)e).ordinal())  boolean remove(Object e)
 elements &amp;amp;= ~(1L &amp;lt;&amp;lt; ((Enum&amp;lt;?&amp;gt;)e).ordinal())    TreeSet  description  基于 TreeMap 的对 NavigableSet 的实现 add、remove、contains 均可在 log(n) 时间内完成 Set 的比较通过 TreeSet 的 compareTo 实现 非同步实现，须于外部进行同步扩展  SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));  迭代器在操作时碰到修改，会快速失败以避免数据风险  params  transient NavigableMap&amp;lt;E,Object&amp;gt; m static final Object PRESENT = new Object()  methods
 TreeSet([|NavigableMap|Comparator|Comparator|SortedSet])   HashSet  description params methods  LinkedHashSet  description params methods  Queue  description
 先进先出队列  params
 methods
 boolean add(E e)  插入元素 容量足够时返回 true，否则抛出 IllegalStateException 异常  boolean offer(E e)  插入元素 容量限制情况下，与 add 方法一样，无法插入时抛出异常  E remove()  获取并移除队列头部 队列空时 抛出异常  E poll()  获取并移除队列头部 队列空时返回 null  E element()  仅获取队列头部 队列空时 抛出异常  E peek()  仅获取队列头部 队列空时返回 null    Deque  description
 双端队列 允许空值   params
 methods
 (add|offer|remove|poll|get|peekLast)[First|Last] push/ pop   Set  description  不包含重复元素 元素为可变对象时，需小心元素的变更，影响到集合中对象的 equals 判断  禁止将自己作为元素加入到集合中 通过抛出 NullPointerException、ClassCastException 异常或 false 来限制填充元素   methods  int size() boolean contains(Object o) boolean add(E e) boolean remove(Object o) Iterator&amp;lt;E&amp;gt; iterator() Object[] toArray() boolean (contains|add|retain|remove)All(Collection&amp;lt;?&amp;gt; c) void clear() boolean equals(Object o) int hashCode()   SortedSet  description  迭代器按升序遍历 所有元素须实现 Comparable 接口，相互比较 默认四种标准构建函数  SortedSet()  空构建函数，创建空的排序集合  SortedSet(Comparator comparator)  仅提供比较器，并创建以此判断的空集合  SortedSet(Collection coleection)  将集合的元素通过原始排序初始化成新的集合  SortedSet(SortedSet set)  拷贝传入的排序器    params  Comparator&amp;lt;? super E&amp;gt; comparator()  methods  SortedSet&amp;lt;E&amp;gt; subSet(E fromElement, E toElement) SortedSet&amp;lt;E&amp;gt; (head|tail)Set(E toElement) E (first|last)()   NavigableSet  description  支持搜索、倒序输出，并可指定子集的上下边界是否包含 提供最接近匹配的搜索匹配 升序操作会比降序操作更快 允许添加 null，但鼓励实现时限制，以避免混淆不清  methods  E lower(E e); E floor(E e); E ceiling(E e); E higher(E e); E pollFirst(); E pollLast();   ## ServiceLoader
Map  description  用于映射键值对，不允许重复的键值 提供三种视图来查看映射内容：键的集合，值的列表和键值对的映射集合 极度小心键值为可变对象的情况，例如严禁将映射自己做为键值，但允许将自身做为值存储  对象的变化会影响到 equals 和 hashcode 的计算   methods
 Query
 int size() boolean containsKey(Object key) boolean containsValue(Object value) V get(Object key)  Modification
 V put(K key, V value) V remove(Object key)  Bulk
 void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; m) void clear()  Views
 Set&amp;lt;K&amp;gt; keySet() Collection&amp;lt;V&amp;gt; values() Set&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet()  Comparison
 boolean equals(Object o) int hashCode()  Default
 default V getOrDefault(Object key, V defaultValue) default void forEach(BiConsumer&amp;lt;? super K, ? super V&amp;gt; action) default void replaceAll(BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; function) default V putIfAbsent(K key, V value) default boolean remove(Object key, Object value)  仅当保存值为指定值时移除指定键值  default boolean replace(K key, V oldValue, V newValue)  仅当指定键对应值为指定值时，覆盖以新值  default V replace(K key, V value) default V computeIf(Absent|Present)(K key, Function&amp;lt;? super K, ? extends V&amp;gt; mappingFunction)  仅当键值（不存在|存在）情况下，覆盖以新计算值     SortedMap  description
 进一步在键值上进行整体性的排序 建议实现的构建函数  SortedMap() SortedMap(Comparator) SortedMap(Map) SortedMap(SortedMap)   methods
 Sub  SortedMap&amp;lt;K,V&amp;gt; subMap(K fromKey, K toKey)  [fromKey,toKey)  SortedMap&amp;lt;K,V&amp;gt; headMap(K toKey)  [,toKey)  SortedMap&amp;lt;K,V&amp;gt; tailMap(K fromKey)  [fromKey,]   Query  K firstKey() K lastKey()  View  Set&amp;lt;K&amp;gt; keySet() Collection&amp;lt;V&amp;gt; values() Set&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet()    NavigableMap  description
 在 SortedSet 的基础上扩展导航、搜索功能 支持正反向查询、遍历，但升序速度更快 新增 pollFirst 和 pollLast 方法，并可通过参数获取指定上下限数据 建议不允许添加 null  methods
 Query
 E lower(E e)  &amp;lt;  E floor(E e)  &amp;lt;=  E ceiling(E e)  &amp;gt;=  E higher(E e)  &amp;gt;  E pollFirst() E pollLast()  View
 Iterator&amp;lt;E&amp;gt; iterator() NavigableSet&amp;lt;E&amp;gt; descendingSet() Iterator&amp;lt;E&amp;gt; descendingIterator()  SubSet
 NavigableSet&amp;lt;E&amp;gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) NavigableSet&amp;lt;E&amp;gt; headSet(E toElement, boolean inclusive) NavigableSet&amp;lt;E&amp;gt; tailSet(E fromElement, boolean inclusive) SortedSet&amp;lt;E&amp;gt; subSet(E fromElement, E toElement) SortedSet&amp;lt;E&amp;gt; headSet(E toElement) SortedSet&amp;lt;E&amp;gt; tailSet(E fromElement)    Abstractmap  description params methods  WeakHashMap  description params methods  IdentityHashMap  description params methods  EnumMap  description params methods  TreeMap  description  基于 NavigableMap 的红黑树实现，键值根据指定比较器排序 红黑树算法保障了 containsKey、get、put 和 remove 的 long(n) 的复杂度 指定的比较器需支持相等判定 不支持同步操作，但可通过 SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...)); 支持 iterator 生成时遵从快速失败原则  params final Comparator&amp;lt;? super K&amp;gt; comparator transient Entry root transient int size = 0 methods  Constructor  TreeMap() TreeMap(Comparator&amp;lt;? super K&amp;gt; comparator) TreeMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) TreeMap(SortedMap&amp;lt;K, ? extends V&amp;gt; m)    HashMap  description params methods  LinkedHashMap  description params methods  Dictionary  description params methods  Hashtable  description params methods  Properties  description params methods  Utils  description params methods  Collections  description params methods  Arrays  description params methods  Reference 官方  15.19. Shift Operators []() []() []()  补充  ArrayList中elementData为什么被transient修饰？ rrayDeque集合的妙用 JDK源码解读之RegularEnumSet []() []()  </content>
    </entry>
    
     <entry>
        <title>Linux.Find</title>
        <url>http://domain.yqjdcyy.com/post/linux.find/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Find 描述  用于指定目录下的文件查找  格式  find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]  参数  -P  表示不追随符号链接  -L  表示追随符号链接  -H  表示只追随命令行中的符号链接  -D &amp;lt;debug.option&amp;gt;  debug的选项  -O &amp;lt;level&amp;gt;  开启查询的优化有1,2,3级   表达式  时间相关
 -[atime|mtime|ctime|amin|mmin|cmin] [&#43;||-]n  指定时间内被存取、修改、更新权限的文件或目录，单位为 天、分钟  其中数字前缀分别代表 n单位时间之前、恰好n单位时间前、n单位时间之内被访问 的情况   -daystart  特指今天内进行访问、修改、更新权限的文件或目录  -[anewer|cnewer|newer] &amp;lt;file&amp;gt;  查找存取、更新时间近于指定文件或目录时间的文件或目录  -used \d  查找指定天数内查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算   类型
 -typ &amp;lt;type&amp;gt;  过滤指定类型文件 类型列表  f  一般正规档案  b, c  装置档案  d  目录  l  连结档  s  socket  p  FIFO    -xtype &amp;lt;type&amp;gt;  针对符号连接进行检查  -fstype &amp;lt;type&amp;gt;  只寻找该文件系统类型下的文件或目录   大小
 -size (&#43;|-)&amp;lt;size&amp;gt;  查找符合指定的文件大小的文件，其中正负号指定范围外、内类型 单位  c  字节 byte  w  字= 2c  b  块= 512c  k  1024 byte  M  兆字节= 1024k  G  吉字节= 1024M    -expty  寻找0字节文件或空目录   范围
 -(xdev|mount)  仅在 当前文件分区下搜索  -(user|group|uid|gid) &amp;lt;filter&amp;gt;  指定用户或群组名下的文件或目录  -(nouser|nogroup)  指定不属于当前用户或群组的文件或目录  -prune  跳过指定目录   权限
 -perm &amp;lt;权限数值&amp;gt;  查找指定权限配置的文件或目录   正则
 -[regex|name|path] &amp;lt;regrex&amp;gt;  查找符合指定格式的字符串、文件名或路径的文件或目录  -[iregex|iname|ipath] &amp;lt;regrex&amp;gt;  同上式，较之 忽略大小写   指定
 -inum&amp;lt;inode编号&amp;gt;  查找指定 inode 的文件或目录  -links &amp;lt;连接数目&amp;gt;  查找指定硬连接数目的文件或目录   输出
 -print|print0|printf|ls  find返回值为 true 时以多行、单行或指定格式、ls格式输出 printf为预设动作，且含有前缀 ./  -fprint|fprint0|fprintf|fls &amp;lt;file&amp;gt;  将上述数据保存至指定文件   执行
 -exec &amp;lt;command&amp;gt;  find 执行结果为 true 时执行，格式如 find path -exec command {} \;  -ok &amp;lt;command&amp;gt;  较 -exec 在执行指令前会先询问用户是否执行   限制
 -[maxdepth|mindepth] &amp;lt;level&amp;gt;  设置最大或最小目录层级  -noleaf  不去考虑目录至少需拥有两个硬连接存在   其它
 -help或——help  在线帮助  -version或——version  显示版本信息  -depth  指定查询顺序，从最深层子目录开始  -false|true  强制设置指令的返回值  -follow  排除符号连接    示例  权限过滤
ls -lh | grep &amp;#34;\-rw\-r\-\-r\-\-&amp;#34; -rw-r--r-- 1 appuser appuser 2 May 2 11:24 chattr-test.dat -rw-r--r-- 1 appuser appuser 1.5M Jan 18 12:08 from.gif find -perm 644 ./from.gif ./chattr-test.dat 大小过滤
# 过滤大于 50KB 的文件 find -size &#43;50k 文件名过滤
# 寻找前缀为 `slide-rId3` 的文件 find -name &amp;#34;slide-rId3*&amp;#34; 跳过
# 搜索当下目录下的 txt 文件，但跳过 sk 目录 find . -path &amp;#34;./sk&amp;#34; -prune -o -name &amp;#34;*.txt&amp;#34; -print 执行
# 优化100K以上图片的分辨率 find /data/cdn -regex &amp;#39;.*\(jpg\|JPG\|png\|PNG\|jpeg\|JPEG\)&amp;#39; -size &#43;100k -exec convert resize &amp;#34;1024x768&amp;#34; -strip -quality 75% {} {} \;  对比 locate  搜索自建数据库 /var/lib/slocate/，且仅每天建立一次预设 更新 /etc/updatedb.conf 中 DAILY_UPDATE 进行默认建立  结果  whereis= locate &amp;gt; find  参考 官方  man.find  补充  find命令 linux中find命令的详细用法 Linux的五个查找命令 15个极好的Linux find命令示例   </content>
    </entry>
    
     <entry>
        <title>Hello.YAML</title>
        <url>http://domain.yqjdcyy.com/post/yaml/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>YAML</tag>
        </tags>
        <content type="html">  YAML 描述  专业配置文件语言  规则  大小写敏感 使用缩进表示层级关系  不允许 Tab，只允许空格 缩进空格数无关，同层左侧对齐即可 冒号后面须跟空格  支持类型  对象 数组 纯量   示例 # 对象 article: title: &amp;#39;title&amp;#39; content: &amp;#39;content&amp;#39; article: {title: title, content: content} # 数组 array: - &amp;#39;item-1&amp;#39; - &amp;#39;item-2&amp;#39; - &amp;#39;item-3&amp;#39; array: [&amp;#39;item-1&amp;#39;, &amp;#39;item-2&amp;#39;] # 纯量 ## 文本行 str: - string # 字符串默认不加引号 - &amp;#39;string&amp;#39;&amp;#39;string&amp;#39; # 文本中引入单引号 - &amp;#34;string&amp;#34; ## 文本块 # xxx\nyyy\n 其中(&#43;|-) 用于指定是否保留文本块末尾的换行 str: |[&#43;|-] xxx yyy # xxx yyy\n str: &amp;gt; xxx yyy bool: true int: 1 float: 1.1 null: ~ time: 2018-08-08t21:59:43.10-05:00 date: 2018-08-08 # 强制类型转换 str: !!str 123 # 引用 ## `&amp;amp;v0` 用于创建 v0 锚点，而 `*vo` 用于引用 v0 锚点  v0: &amp;amp;v0 detail: v0.detail log: v0.change.logs v1: detail: v1.detail log: change.logs history: *v0 ### history: ### detail: v0.detail ### log: v0.change.logs 参考  YAML 简介 YAML 语言教程 %YAML 1.2 YAML Ain’t Markup Language (YAML™) Version 1.2 go-yaml/yaml golang yaml配置文件解析  </content>
    </entry>
    
     <entry>
        <title>Linux.Install</title>
        <url>http://domain.yqjdcyy.com/post/linux.install/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  方式 RPM 描述  全称为 Redhat Package Manager，支持安装、卸载、升级、查询和验证  指令  cmd  rmp [option] &amp;lt;soft.rpm|soft&amp;gt;  option  -a  查询所有套件  -b&amp;lt;stage&amp;gt;&amp;lt;soft&amp;gt;&#43;或-t &amp;lt;stage&amp;gt;&amp;lt;soft&amp;gt;&#43;  设置包装套件的完成阶段，并指定套件档的文件名称  -e&amp;lt;soft&amp;gt;或--erase&amp;lt;soft&amp;gt;  删除指定的套件  -f&amp;lt;file&amp;gt;&#43;  查询拥有指定文件的套件  -h或--hash  套件安装时列出标记  -i  显示套件的相关信息  -i&amp;lt;soft&amp;gt;或--install&amp;lt;soft&amp;gt;  安装指定的套件档  -l  显示套件的文件列表 -c  只列出组态配置文件，本参数需配合&amp;rdquo;-l&amp;rdquo;参数使用  -d  只列出文本文件，本参数需配合&amp;rdquo;-l&amp;rdquo;参数使用  -s  显示文件状态，本参数需配合&amp;rdquo;-l&amp;rdquo;参数使用   -p&amp;lt;soft&amp;gt;&#43;  查询指定的RPM套件档  -q  使用 询问模式，当遇到任何问题时，rpm指令会先询问用户  -R  显示套件的关联性信息  -U&amp;lt;soft&amp;gt;或--upgrade&amp;lt;soft&amp;gt;  升级指定的套件档  -v  显示指令 执行过程  -vv  详细显示指令执行过程，便于排错    示例  安装 rpm 包
 rpm -ivh soft.rmp rpm --force --nodeps -ivh soft.rmp  覆盖安装 忽略未安装此包需要的一些软件   安装 .src.rpm 包
 该软件包含源代码，需在安装时进行编译  # 方法一 rpm -i soft.src.rpm cd /usr/src/redhat/SPECS &amp;amp;&amp;amp; rembuild -bp soft.specs cd /usr/src/redhat/BUILD/soft/ &amp;amp;&amp;amp; ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install # 方法二 rpm -i soft.src.rpm cd /usr/src/redhat/SPECS &amp;amp;&amp;amp; rembuild -bp soft.specs cd /usr/src/redhat/RPM/(i386|i686|noarch) &amp;amp;&amp;amp; rpm -8 &amp;lt;new-soft&amp;gt;.rpm 卸载 rpm 包
 rpm -e &amp;lt;soft[-version]&amp;gt; rpm -e --nodeps &amp;lt;soft[-version]&amp;gt;  该软件为其它软件所须，但仍强制删除   罗列系统中安装过的 rpm 包
 rpm -qa  查看指定软件的安装目录
 rpm -ql &amp;lt;soft&amp;gt;   tar.gz | tar.bz2 描述  源代码方式安装  默认安装目录为 /usr/local/bin  但具体参见该软件的 INSTALL 和 README    示例 # tar.gz wget http://downloads.xiph.org/releases/ogg/libogg-1.3.3.tar.gz tar **xzvf** libogg-1.3.3.tar.gz cd libogg-1.3.3 ## 配置，根据需求调整生成目录 ./configure --prefix=&amp;#34;/usr/local/ffmpeg&amp;#34; --disable-static ## 编译 make ## 安装 make install ## 移除安装时产生的是临时文件 make clean # tar.bz2 tar **-jxvf** libogg.tar.bz2 YUM 描述 用于解决普通 RPM 包安装时关联性太大的问题 自动下载并安装 RPM 包
指令  cmd
 yum [option] [args] [&amp;lt;soft&amp;gt;]  option
 -h  显示帮助信息  -y  对所有的提问都回答 “yes”  -c  指定配置文件  -q  安静模式  -v  详细模式  -d  设置调试等级（0-10）  -e  设置错误等级（0-10）  -R  设置yum处理一个命令的最大等待时间  -C  完全从缓存中运行，而不去下载或者更新任何头文件   args
 install  安装rpm软件包  update  更新rpm软件包  check-update  检查是否有可用的更新rpm软件包  remove  删除指定的rpm软件包  list  显示软件包的信息  search  搜索软件包的信息  info  显示指定的rpm软件包的描述信息和概要信息  clean  清理yum过期的缓存  shell  进入yum的shell提示符  resolvedep  显示rpm软件包的依赖关系  localinstall  安装本地的rpm软件包  localupdate  显示本地rpm软件包进行更新  deplist  显示rpm软件包的所有依赖关系    示例  安装
yum install yum install &amp;lt;soft&amp;gt; yum groupinstall &amp;lt;group&amp;gt; 更新
yum update yum update &amp;lt;soft&amp;gt; yum check-update yum groupupdate &amp;lt;group&amp;gt; 查看
yum info &amp;lt;soft&amp;gt; yum list yum list &amp;lt;soft&amp;gt; # 查看软件的依赖情况 yum deplist &amp;lt;soft&amp;gt; yum groupinfo &amp;lt;group&amp;gt; 删除
yum remove &amp;lt;soft&amp;gt; yum groupremove &amp;lt;group&amp;gt; 清除缓存
yum clean &amp;lt;soft&amp;gt; # 清除已下载的 rpm 包 yum clean packages # 清理 /var/cache/yum 中的 headers 信息 yum clean headers yum clean oldheaders  参考  Linux安装软件总结（二.几种安装命令介绍） rpm命令 yum命令 Centos Ram缓存清理  </content>
    </entry>
    
     <entry>
        <title>FFmpeg.Upgrade</title>
        <url>http://domain.yqjdcyy.com/post/ffmpeg.upgrade/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>FFMPEG</tag>
        </tags>
        <content type="html">  系统情况 cat /proc/version Linux version 3.10.0-123.9.3.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.2 20140120 (Red Hat 4.8.2-16) (GCC) ) #1 SMP Thu Nov 6 15:06:03 UTC 2014  lsb_release -a LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 7.0.1406 (Core) Release: 7.0.1406 Codename: Core Make - Fail 情况  安装指定编解码器时，部分必须组件[FriBidi]无法正常安装，导致 FFmpeg 无法正常配置安装  流程 下载  到官网下载最新版本 解压安装
tar -jxvf ffmpeg-4.0.2.tar.bz2 -C ffmpeg-4.0.2 cd ffmpeg-4.0.2 &amp;amp;&amp;amp; ./configure --prefix=/usr/local/ffmpeg &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install 实际线上测试后发现少安装编码解码器
 Unknown encoder &#39;libx264&#39;  重新安装并配置相关编解码器
./configure \  --extra-cflags=&amp;#34;-I/usr/local/ffmpeg/include&amp;#34; \  --extra-ldflags=&amp;#34;-L/usr/local/ffmpeg/lib&amp;#34; \  --pkg-config-flags=&amp;#34;--static&amp;#34; \  --prefix=/usr/local/ffmpeg \  --disable-debug \  --enable-gpl \  --enable-libvorbis \  --enable-libvpx \  --enable-libx264 \  --enable-libx265 \  --enable-libmp3lame **ERROR: vorbis not found using pkg-config** 安装相关的必须组件
 详情可参照 FFmpeg-4.0 指令如下
libogg wget http://downloads.xiph.org/releases/ogg/libogg-1.3.3.tar.gz tar xzvf libogg-1.3.3.tar.gz cd libogg-1.3.3 &amp;amp;&amp;amp;./configure --prefix=&amp;#34;/usr/local/ffmpeg&amp;#34; --disable-static &amp;amp;&amp;amp; make make install make distclean libvorbis wget http://downloads.xiph.org/releases/vorbis/libvorbis-1.3.6.tar.gz tar xzvf libvorbis-1.3.6.tar.gz cd libvorbis-1.3.6 &amp;amp;&amp;amp; ./configure --prefix=&amp;#34;/usr/local/ffmpeg&amp;#34; --disable-static &amp;amp;&amp;amp; make make install make distclean fribidi wget https://github.com/fribidi/fribidi/releases/download/v1.0.5/fribidi-1.0.5.tar.bz2 tar xjf fribidi-1.0.5.tar.bz2 cd fribidi-1.0.5 &amp;amp;&amp;amp; ./configure --prefix=&amp;#34;/usr/local/ffmpeg&amp;#34; --disable-static &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install // cd fribidi-1.0.5 &amp;amp;&amp;amp; ./configure --prefix=&amp;#34;/usr&amp;#34; --disable-static &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install // cd fribidi-1.0.5 &amp;amp;&amp;amp; mkdir -p build &amp;amp;&amp;amp; cd build &amp;amp;&amp;amp; meson --prefix=&amp;#34;/usr/local/ffmpeg&amp;#34; .. &amp;amp;&amp;amp; ninja &amp;amp;&amp;amp; ninja stall // /usr/local/ffmpeg/lib/pkgconfig libass wget https://github.com/libass/libass/releases/download/0.14.0/libass-0.14.0.tar.xz tar xvJf libass-0.14.0.tar.xz cd libass-0.14.0 &amp;amp;&amp;amp; ./configure --prefix=&amp;#34;/usr/local/ffmpeg&amp;#34; --disable-static &amp;amp;&amp;amp; make make install libass 需要 fribidi 0.19 以上版本，但已安装 1.0.5 却并未被识别到   FFmpeg-install - Success  下载脚本 - https://raw.githubusercontent.com/q3aql/ffmpeg-install/master/ffmpeg-install 更新脚本内参数「PATH_INSTALL」至你须安装路径  vim ffmpeg-install  调整权限  chmod 733 ffmpeg-install  安装
# 查看帮助 ./ffmpeg-install -h ./ffmpeg-install: line 68: axel: command not found axel disabled ./ffmpeg-install: line 76: aria2c: command not found aria2c disabled ** ffmpeg-install v.1.2 ** * How to install: ffmpeg-install --install (Latest git version) ffmpeg-install --install release (Latest stable version) * How to update: ffmpeg-install --update (Latest git version) ffmpeg-install --update release (Latest stable version) * How to uninstall: ffmpeg-install --uninstall * Show help: ffmpeg --help # 安装最新稳定版本 ffmpeg-install --install release  补充
 使用 make 方式安装，执行文件路径为 /usr/local/ffmpeg/bin/ffmpeg 而使用 ffmpeg-install 被安装，执行文件路径为 /usr/local/ffmpeg，且无 include 等相关目录   参考 资源  FFmpeg 官方 FFmpeg-4.0  libogg-1.3.3 Ninja ninja-build/ninja-Release  xiph.org  教程  FFMpeg Install On CentOS 7  一键化部署，须按需更新脚本中的目录位置  在CentOS上编译安装FFmpeg  内有 Yum 安装和自行编译安装两种模式，后者有详尽的指令  2017年12月14日ubuntu下ffmpeg安装过程记录  </content>
    </entry>
    
     <entry>
        <title>互联网产品的运营模式</title>
        <url>http://domain.yqjdcyy.com/post/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81%E7%9A%84%E8%BF%90%E8%90%A5%E6%A8%A1%E5%BC%8F/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>商务</tag><tag>运营</tag>
        </tags>
        <content type="html">  类型  定位
   特点 类型 用户特征 运营核心关注点 示例     一次性消费 培训、婚庆 有付费意愿和习惯 转化、销售、成交、高客单价 哈德
广告投放，搜索用户的客服跟进   低频消费 招聘、婚恋 周期恒定、 频率较低 品牌、PR、增值 Boss直聘
世界杯广告投放   高频非消费 日历、闹钟、播放器、新闻 使用频率高，但无付费意愿 增强体验、打造口碑 网易云音乐
口碑提升后尝试于评论中插入广告   高频消费 外卖、打车 使用频率高且付费意愿强 活动、补贴 饿了么、滴滴
会员机制、套餐   用户创建价值 UGC、社交、平台 本身内容、服务源自用户 用户生态搭建、种子用户运营 抖音、Instgram
排序、人工审核     运营参考 曲线阅读    示例 工具类  快手   历史拐点  增加相框、画笔等玩法 性能效率优化 创建社区，增加社交、互动和关系建立功能  核心思路  体验 效率 社交场景打通    内容类  懂球帝   历史拐点  内部生成原创优质内容 在知乎推广其优质内容以吸引优质球迷用户 深度开发独特内容  助攻榜 杯赛榜   核心思路  内容品质 独特性 互动    社交类  微信   历史拐点  消息&#43; 语音 导入 QQ 已有好友 摇一摇、漂流瓶、附近的人  核心思路  关系链 氛围  比如本产品的用途，如陌陌  玩法    社区类  IN   历史拐点  内容质量 个性化塑造 话题  核心思路  氛围 内容质量 话题    平台类  滴滴   历史拐点  切强需求用户  偏远、叫车不易  交叉补贴  核心思路  细分价值点 交叉补贴    思考 产品形态  历程  初始定位为工具，意为演讲工具 后觉发展不易，上限明显，转型作教育型辅助工具 而后为了生存，进行平台尝试未果 最后发挥领导商务能力，转型为企业服务提供商  结论  工具类   运营方式  前提  自觉现在功能混杂，工具&#43; 机构&#43; 平台&#43; 企业服务，业务复杂，定位不清 觉得需先进行业务的划分，精简集中或业务分离  方式  工具角度  首先集中核心技术人员进行工具产品的抽离、优化 丰富工具的使用方式 提升用户体验，降低使用难度  服务提供  提升口碑，二次传播  目前较为薄弱，基本纯靠销售（总监级）堆  进行广告投放  百度推广，经费有限 但推广转化率较高  知乎、微博宣传  佛系推广，纯看运营人民     备注  公司组织报名学习 3节课，觉得思路、结构清晰，特记录如下 如有不当，请告知，当立即配合处理  # 参考
 不同互联网产品背后的运营玩法  </content>
    </entry>
    
     <entry>
        <title>厦门云开云有限公司</title>
        <url>http://domain.yqjdcyy.com/post/%E5%8E%A6%E9%97%A8%E4%BA%91%E5%BC%80%E4%BA%91%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>商业</tag>
        </tags>
        <content type="html">  发展历程  2015.10  创业想法诞生  2016.7  云开演示者  2016.9.5  基础团队构建完成  2016.10.3  转型机构|老师版  2016.12.31  天使轮  坚果资本 500万   2017.3  云开名师 v1.0  2017.6  云开名师 v2.0  2017.12.29  礼遇|尊享版  2018.4  云开名师 v3.0  2018.7  布课版|大企业版   初始员工  0001 徐光泽 0002 崔峻 0003 徐小明 0004 彭冲 0005 吴剑南 0006 张涛 0007 姚清居 0008 周华山 0009 金梦
 2018.4.26已离职  0010 李志高 0011 黎佳佳 0012 陆妙梅 0013 林臻  产品 云开演示者  客户群
 各类会议主办方（包括企业市场宣传会、路演会、专题会议、行业大会等）  解决问题
 提升现场用户的参与感、扩大会议传播覆盖面、提升会议传播转化率  功能
 现场用户在手机上同步观看演讲内容 通过弹幕参与现场互动 远程用户通过直播观看会议内容 会后对会议内容进行回看，并在微信上进行传播分享 尾页广告链接宣传页面 会议传播多维度统计数据分析 会议信息发布及议程管理 现场用户签到 演讲嘉宾在线邀请协作 自动生成会议微官网  备注
 业务调整，该系列 已取消   云开名师  客户群
 个人老师  解决问题
 帮助老师快速实现线上线下结合的混合式教学  功能
 课前测试、问题收集 课中破冰游戏、课堂互动、实时交流、学习反馈 课后通过频道进行学员运营 课后辅导、在线训练 课程直播，学员通过微信端直接在线实时学习 课后实时生成课程回顾，供学员多次学习 微信一键将课程分享 学员打赏 作业在线发放，老师在线批改点评 课程留存在云开的云平台上   云开致课  客户群
 个人老师  解决问题
 方便老师快捷进行已有课程的剪辑并转换为微课  功能
 历史课程的音、视频剪辑 生成微课  备注
 原本为独立工具设定，目前 已合并至云开名师   客户群体 机构 面向学员 模式  给予  提供直播、公众号对接工具，赋予线下机构以线上教学模式的能力  收取  平台（套餐）费用 流量（观看、使用）费用   核心客户  学赞教师 在线课堂 云开学堂 哈德教育 闽试教育  面向企业 模式  给予  提供直播、微课剪辑工具，方便快速进行课程创建 提供平台，将课程分发至其客户，实现快捷有效的客户对接  收取  平台（套餐）费用 流量（观看、使用）费用 收费课程推广分销费用   核心客户  AMA 秦训  企业 自营 模式  给予  提供直播工具，方便进行各地员工的同步培训  收取  平台（套餐）费用  大企业针对员工数等进行收费  流量费用  针对企业内部员工不收取流量费用 针对企业外需单独收取流量（观看、使用）费用    核心客户  新时代国珍商学院 徐福记国际集团 鸿星尔克（厦门）实业有限公司  思考  方向定位需明确，转型时回顾并适当取舍 明确优势（资本、渠道、商务、技术等），依据上下限进行强化或补充 公司存活主要还是依靠决策层  公司氛围影响，但不决定 个人发展与企业一致，或明确过渡作用以决定投入方式、程度  创业公司，期权等建议一开始就谈清楚，先小人后君子  备注  以上分析均来源于网上资料和个人整理，如有出入，请告知更正 该分析仅用于对公司运营的推理、学习  参考  http://yunkai.com/ 用大客户案例来讲，「云开科技」的云平台在企业培训垂直领域的潜力 2017新浪教育盛典候选机构：云开科技  </content>
    </entry>
    
     <entry>
        <title>我与地坛</title>
        <url>http://domain.yqjdcyy.com/post/%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>思考</tag>
        </tags>
        <content type="html">  作者 史铁生 经历  1951年1月4日生于北京 1969年1月13日18岁时上山下乡运动展开，自愿到陕北延安农村插队 1969年4月因腰腿病返京治病，6月回村，生产队照顾他，让他担任饲养员，放牛喂牛 1971年9月，史铁生腰疼加重，回北京治病 1972年1月5日住友谊医院，一年有半，治疗结束之时即轮椅生涯开始之日 1981年因患肾病回家疗养后从事写作 1998年被确诊为尿毒症 2010年12月31日凌晨3点46分，因突发脑溢血在北京宣武医院去世  根据他的遗愿，不举行遗体告别仪式，器官捐献给医学研究 31日凌晨6时许，其肝脏已移植给天津的一位病人   作品&amp;amp;荣誉  1979年发表第一篇小说《法学教授及其夫人》 成名作是《我的遥远的清平湾》，获1983年全国优秀短篇小说奖 小说《老屋小记》获首届鲁迅文学奖 2002年获华语文学传媒大奖年度杰出成就奖  《病隙碎笔》（之六）获首届“老舍散文奖”一等奖  2009年荣获首届残疾人“绽放文学艺术成就奖”  经典  一个人，出 生了，这就不再是一个可以辩论的问题，而只是上帝交给他的一个 事实；
上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以 死是一件不必急于求成的事，死是一个必然会降临的节日。
  由谁去充任那些苦难的角色？又有谁去体现这世间的幸福，骄傲和快乐?
只好听凭偶然，是没有道理好讲的。
  因为人想活着，说到底是这么回事，人真正的名字叫作：欲望。
  在人为灵魂的安宁寻找种种理由的过程即是写作行为，不非用纸笔不可。
值生而写作如春雨点滴，向死而作则如惊天雷鸣 他们（像鲁迅那样）爱极了也恨透了，别的办法没有便洒一天一地自己的鲜血，用纯真的眼睛问每一个人：你们看到了吗？
  三种文学：纯文学、严肃文学和通俗文学
纯文学是面对着人本的困境。
人当然不可能无视社会、政治、阶级，严肃文学便是侧重于这一层面。
通俗文学主要是为着人的娱乐需要，人不能没有娱乐。
  现实主义的写作方法，源于现实反映现实
它是把形式和内容分开来对待的，认为内容就是内容是第一位的，形式单是形式位在其次，最多赞成内容与形式的和谐
  中国的文化传统中，有一种怕孩子长大失了质朴干脆就 不让孩子长大的倾向，这是极糟糕的事。
  人的根本标志是精神，所以人道主义应是主要对此而言。
  所谓“空观人道主义”大概是说：目的皆是虚空，人生只有一个实在的过程，在此过程中唯有实现精神的步步升华才是意义之所在。
 </content>
    </entry>
    
     <entry>
        <title>Java.FunctionInterface</title>
        <url>http://domain.yqjdcyy.com/post/java.functioninterface/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>Java8</tag>
        </tags>
        <content type="html">  Effect  用于在 Java 8 中 支持 Lambda 表达式 Java8 中新特性  Introduce Function.Interface  接口 只有一个抽象方法  SAM 接口（Single Abstract Method interfaces）   Annotation  @FunctionalInterface  用于 检测编译级错误  提醒编译器 检测接口是否 有且仅有一个抽象方法 对是否支持函数式接口 无影响    Situation.allow  定义 默认方法 定义 静态方法 覆盖实现 Object.public 方法 声明可检查异常  List  java.lang.Runnable  public abstract void run()  java.util.Comparator  int compare(T o1, T o2)  java.util.concurrent.Callable  V call() throws Exception   Change Interface.Default  为 Iterable/ Collection 增加方法  为保障接口的向后兼容，增加了 default function   Example Define&amp;amp; Use - Define @FunctionalInterface public interface FInterface { // 抽象方法  void print(); // 默认方法  default void printDefault() { System.out.println(&amp;#34;FInterface.default&amp;#34;); } // 静态方法  static Object printStatic() { System.out.println(&amp;#34;FInterface.static&amp;#34;); return &amp;#34;&amp;#34;; } // 覆盖 Object 的 public 方法  @Override String toString(); } - Use public static void main(String[] args) { FInterface fi = () -&amp;gt; System.out.println(&amp;#34;FInterface.print&amp;#34;); fi.print(); fi.printDefault(); FInterface.printStatic(); System.out.println(fi); } Iterable.default-function public interface Iterable&amp;lt;T&amp;gt; { **default** void forEach(Consumer&amp;lt;? super T&amp;gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } } Reference  什么是函数式接口（Functional Interface） Java 8函数式接口functional interface的秘密 Java8学习笔记（1） &amp;ndash; 从函数式接口说起 Java 8 函数式接口  </content>
    </entry>
    
     <entry>
        <title>HTTP.Header.Connection</title>
        <url>http://domain.yqjdcyy.com/post/http.header.connection/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>HTTP</tag>
        </tags>
        <content type="html">  Introduce 作用  指定网络连接于请求完成后保持连接，允许同一服务器对后续请求的处理 使 客户端到 服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能 避免了建立或者重新建立连接  多个请求 共用同一 TCP 链接  减少重复请求时所需要的 TCP 握手 异常上报也直接通过 TCP 上传     优点  减少 CPU 和内存的使用 减少 TCP 的链接和请求延迟  缺点  CPU 转耗在众多的一次性连接上  建议  客户端与任务服务器之间不应维持超过 2个 链接  Option close  指定客户端、服务端都将关闭链接 HTTP/1.0 的默认选项  keep-alive  HTTP 1.1 的默认选项 除非请求头中指定 Connection: Close  Supplement 判断数据是否传输完成  Content-Length
 指定实体内容长度  Transfer-Encoding: chunk
Chunked-Body = *chunk &amp;#34;0&amp;#34; CRLF footer CRLF chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF hex-no-zero = &amp;lt;HEX excluding &amp;#34;0&amp;#34;&amp;gt; chunk-size = hex-no-zero *HEX chunk-ext = *( &amp;#34;;&amp;#34; chunk-ext-name [ &amp;#34;=&amp;#34; chunk-ext-value ] ) chunk-ext-name = token chunk-ext-val = token | quoted-string chunk-data = chunk-size(OCTET) footer = *entity-header  默认配置    服务 超时时长     Apache 2.0 httpd 15s   Apache 2.2 httpd 5s    HTTP.Keep-Alive 与 TCP.Keep-Alive 的区别  前者是为了让 TCP 戚时间更长，以便在同一 TCP 连接上进行多次请求 后者仅是为了检测 TCP 的连接状态
 通过向客户端发送空包，以判断连接状态
   配置项 数值 作用     /proc/sys/net/ipv4/tcp_keepalive_time 1800 TCP 连接链接后，闲置指定时间后发送空包以检测连接状态
单位为秒   /proc/sys/net/ipv4/tcp_keepalive_intvl 15 未收到请求方 ACK 请求情况下的间隔请求时间
单位为秒   /proc/sys/net/ipv4/tcp_keepalive_probes 5 未收到请求方 ACK 请求情况下的尝试检测次数上限      Reference 官方  Connection RFC 2616 Transfer-Encoding  补充  HTTP Keep-Alive是什么？如何工作？ HTTP Keep-Alive模式 http的keep-alive和tcp的keepalive区别 KeepAlive，你优化了吗  </content>
    </entry>
    
     <entry>
        <title>HTTP.Header.Keep-Alive</title>
        <url>http://domain.yqjdcyy.com/post/http.header.keep-alive/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>HTTP</tag>
        </tags>
        <content type="html">  Introduce  参见 HTTP.Header.Connection  Parameters timeout  指明空闲链接的 最短保持链接 时间 单位为秒 当 TCP 未设置保持连接时，超时时长比 TCP 超时时长更长情况下则忽略  max  指明关闭前 最多可请求的 次数  Example HTTP/1.1 200 OK Connection: Keep-Alive Content-Encoding: gzip Content-Type: text/html; charset=utf-8 Date: Thu, 11 Aug 2016 15:23:13 GMT **Keep-Alive: timeout=5, max=1000** Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT Server: Apache (body) Reference 官方  Keep-Alive  </content>
    </entry>
    
     <entry>
        <title>浮生三记</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B5%AE%E7%94%9F%E4%B8%89%E8%AE%B0/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>思考</tag>
        </tags>
        <content type="html">  作者 沈君山  国立清华大学前校长 物理学家 围棋棋士  连续三届荣获美国本因坊冠军 为著名的旅日围棋棋士张栩之义父 与吴清源、木谷实、林海峰、曹薰铉及聂卫平相熟  桥牌高手  获两届世界桥牌大赛百慕大杯亚军   章节 打菩萨  母亲详细地讲解这个故事，并且援引了《孟子》上的一句话：“自反而缩，虽千万人吾往矣。”她解释道，缩的意思是直，自己想想道理直时，便不要顾忌世俗的反对。小时候能打破村民们迷信的偶像，大起来才能领导革命，不折不挠、不畏强权而获得最后的成功。
 怀念见美  Ben台美两地来回地跑，在台的时间，就都在医院陪妈妈。见美的几位朋友，代课的代课，陪伴的陪伴，三百余天如一日。这样的子女，这样的朋友，今天世上实在很少见了，有人赞赏羡慕，说是福气因缘。其实胡适之先生常说的两句话——“要怎样收获，先怎样栽”更为透彻。
  林语堂为《浮生六记》作序，向往沈三白笔下的芸娘，十分期望也有朋友有这样的妻子 - 得意时往访，宾主开怀畅谈，深宵露冷，她会拿一条毯子来盖在你们膝上； - 失意时往访，她也会温一壶淡酒，听你发尽牢骚，用静静的了解来慰藉。
林语堂说，这才是人生的福分。 现在时代不同，但是见美的朋友，无论男女老幼，和她相交久了，或者一通四五十分钟的电话，或者半瓶残存的威士忌，也多曾从她那儿分享过她common
 万古人间四月天  徐志摩的故事，和胡适之正是一个对比
胡韦在讨论父母之命的婚姻时，胡就指出有两条路，一是容忍迁就，一是独行其是，胡选择了前者，而徐选择了后者。
徐的不恤人言，不谅父母，以一己真诚的感情为惟一指标，在《人间四月天》的影剧中，鲜明地显示出来。
而胡的容忍迁就，不只是为江冬秀，更主要为他母亲，他不愿意伤害她们，胡在作此抉择时，引用了康德的一段话，作为价值判断的依据：“无论是对自己，还是对别人，都要将人道本身视为目的，而不仅是手段。”“要以人道作为最终的裁判。”
  现在父母之命的婚姻早就过去，今日男女都要做独立自主的人。
良人者仰仗终身者，红盖头掀起来，终身便从一而终的情形再不复见，但新的婚姻有新的困扰，一个人一生大多要经过几次痛苦的抉择，几次悲欢离合。完美的爱情和完美的婚姻完全不一定能画上等号，有情人当然最好成为眷属，但不必也不一定要成眷属，婚姻的形式在改，将来也许契约的形式都会改掉，但终久是共同相处的伴侣，有灵性的伴侣，有知性的伴侣，有事业的伴侣，更有生活的伴侣。
所谓生活包括柴米油盐日常相处。聪慧才情的男女，在爱情中沉湎于前两者，而婚姻的基石却往往在后两者。
林徽音选择梁思成，徐志摩得到陆小曼，在爱情层面上，也许后者更“美”，更罗曼蒂克，但在婚姻层面上，成败得失是十分显然。
  真正懂得爱情的人，不只在获得，更在如何转化，失败了，如何化爱情为友情，成功结果了，也要化激情为温情，使之可长可久。
当然，分手总是痛苦的，情感的伤害难免，但时间会让它痊愈，最重要是不要伤害对方的自尊，也不必伤害自己的自尊。
尤其是年轻的男女，往往分不开爱情和自信。失恋的时候，最伤心的往往不是缘分已尽，而是“我真的那么差吗？”事实上，爱情是盲目的，人生一生的成败和情场一时的得失，并没有关联，只是太上何能忘情，必须分手时，一定要互相帮助，重建自信的帮助。
  我曾经问起过梁公，金岳霖为林徽音终生不娶的事。
梁公笑了笑说:“
我们住在总布胡同的时候，老金就住在我们家后院，但另有旁门出入。
可能是在一九三一年，我从宝坻调查回来，徽音见到我哭丧着脸说，她苦恼极了，因为她同时爱上两个人，不知怎么办才好。她和我谈话时一点不像妻子对丈夫谈话，却像个小妹妹在请哥哥拿主意。听到这事我半天说不出话，一种无法形容的痛苦紧紧地抓住了我，我感到血液也凝固了，连呼吸都困难。但我感谢徽音，她没有把我当一个傻丈夫，她对我是坦诚和信任的。
我想了一夜该怎么办？我问自己，徽音到底和我幸福还是和老金一起幸福？我把自己、老金和徽音三个人反复放在天平上衡量。我觉得尽管自己在文学艺术各方面有一定的修养，但我缺少老金那哲学家的头脑，我认为自己不如老金。于是第二天，我把想了一夜的结论告诉徽音。我说她是自由的，如果她选择了老金，祝愿他们永远幸福。我们都哭了。
当徽音把我的话告诉老金时，老金的回答是：‘看来思成是真正爱你的，我不能去伤害一个真正爱你的人。我应该退出。’
从那次谈话以后，我再没有和徽音谈过这件事。因为我知道老金是个说到做到的人，微音也是个诚实的人。后来事实也证明了这一点，我们三个人始终是好朋友。我自己在工作遇到难题也常去请教老金，甚至连我和徽音吵架也常要老金来‘仲裁’，因为他总是那么理性，把我们因为情绪激动而搞糊涂的问题分析得一清二楚。”
  在《林徽音文集》中，后期的诗文常常提到金岳霖，很多全家福或朋友出游的照片里，全有老金，斜着头仰起脸非常神气的样子。林去世后，他写了副有名的挽联：“一身诗意千寻瀑，万古人间四月天。”后来金和梁的友情一直维持到文革时期，都受尽折磨，也互相激励。我们可以说，在世俗眼光里，他是“退出”了，但在更高一个层次上，他是“进去”了。
 知识的突破  科学知识的另外一个特征就是“征而后信”，这也是自然科学知识与人文、宗教等知识最大的分别。
征验的方法随时代进步，最初是靠经验，然后是观测，再后是实验；经验是无心的累积，观测是有心的留意。实验就更进一步，是创造一个人为的环境，使此一环境中所有的条件符合观察者的要求而进行的观察。
经由经验、观测和实验这三个不同层次方式所得出的结果便是实证。实证是判别一切科学知识最后的权威。
 后科技时代文明和中国  理性和信仰是人类本性中的两部分。
- 科学是理性具体的表现，它的特征是验而后信，它的最后权威是实证。
- 信仰有认知和规范两个层面，西方的宗教将之兼容在内，儒家的文化强调规范，将之独立出来，成为一般性的伦理道德。
信仰的基础建立在一些先验性原则上，它的最后权威或者行诸经典，如《圣经》、《可兰经》。或者是一些不成文的金科玉律，如“百善孝为先，万恶淫为首”等。这些先验性的原则，最初当然也是反映了当时的现实经验而建立，但一旦建立，就不能再验而后信。
  第三第四两点是最值得仔细思考推敲的。过去两三百年，从新教伦理和达尔文思想发展出来，以个人为主体，竞争为主轴的西方文明，是世界上最强势的文明，也是非常适合科技突破的文明，但是在科技高度发展，人定可以胜天以后，它必然会面临我称之为“大角鹿困境”的本质性矛盾：
- 大角鹿用角打架，角越大，越打越赢，物竞天择的结果，角越来越大，大到一个地步，转动不灵，吃不到东西也照顾不了自己，一下子就灭亡了。
- 这个例子和现代西方竞争的社会所面临的问题非常相似 - 首先，鹿看不到自己的角，大部分鹿，只能自觉到角对帮助打架的即刻好处，却难以体会它过分发展潜在的危机，所以即使有一两只聪明有远见的鹿，能看出问题，也难以获得群鹿“民意”的共鸣与支持。
- 其次，这少数的鹿也面临一种辩证的困境，假若角长不大，马上被别种鹿淘汰，如果长大，又可能被自然淘汰。 - 物竞与天择，变成对立的两面。如何处理这两难的困境呢？ - 我个人的看法，中国文化以调和代替征服，以均衡和谐的追求，代替优胜劣败的丛林法则，或者会是一个在后科技时代，较西方文明更适合处理这个困境的文明。当然，寻求后科技时代的普世价值体系是一个极基本的大课题。西方学者早已在西方文明的框架中，对它做深刻的探讨。也许中国的学者也可以在东方文明的框架中加以深究。在这儿，我只想强调三点： - 首先，整体而言，科技带给人类绝对是正面的。这是首先要有的基本认识。今人受了现代生活紧张匆忙之苦，兴思古之幽情，常怀念葛天神农之世。但不要忘记，现在因科技之助，已渐渐为人遗忘的饥馑瘟疫，在那个时代经常使成千上万的人死亡，绝大多数人每天都要为维持自己的基本生存挣扎。类似的例子不胜枚举，此处不赘。总之，无论从理论还是实际来看，后科技时代寻求的规范，不是遏止迟缓科技的发展，而是对它引发的问题，用更新的科技来克服，至于少数真正不可逆而又无法克制的，就必须寻求集体的对策。大角鹿式的困境，只有用集体的理性智慧来解决。像最近针对全球温升现象而达成的京都议定书便是一例。人之异于禽兽者，在其理性，这点我个人是颇有信心的。至于对东方文化，我们要取的是其“调和”的价值观，但在其源自老庄的自然主义思想中，常存绝圣弃智则天下大同的反智心态，则并不可取。 - 其次，新规范是动态的（dynamic），而非静态的。中国常讲伦常、纲常，有一个“常”字，因此一旦定下，便期望它千百年不变。但科技本身日新月异，像现在基因工程，资讯传媒几乎每月每年都有新的突破。因此所谓规范，只能就个体与群体，人与自然等基本互动作一些原则性的规定，细则则必然是要随时间改变的。 - 第三，科技是普世性的，普世文明必须与科技文明协和，但在普世的文明下，还应包含区域性的文明，每个区域文明的文化特质，不必要也不可能将之一致化。
 一着而为天下法  围棋是胜负的世界，善胜负者日人称之为胜负师。胜负师常有，但没世而名不称者居多。
吴先生在五十年代前后，对日本一流高手作个别十局比赛，将之全部降级，专就成绩而言，足够资格称得上第一流的胜负师。
但在吴清源先生棋的世界中，胜负只是一个附带的因素。对吴先生而言，围棋是一种艺术，也是一种哲理，反复争棋的最后的目的，是从中领悟建立调和的道。吴先生髫龄度日，纵横棋坛四十年，所创布局定式，不知凡几，这些新布局新定式，对当时的胜负未必有助，但却为后来者开辟一片新天地。此所以吴先生卓立于群彦之上，而为围棋史上划时代的人物。
  然吴先生之赢得日本举国之尊敬，又不仅在棋艺。
凡继往开来为一代宗师者，必有其特殊之气质，曾与爱因斯坦共事并为爱氏立传的一位科学家曾说：爱氏是他所识人中，最自由、最不妥协和最有自信者。自由、自信和不妥协是真正天才共通的特性，也正是吴清源围棋一生的写照。
  独立自由的心灵是开启创新之门的钥匙，执著坚持则是底定于成的动力。
吴先生昭和八年对本因坊秀哉一局，以三·三、星、天元起局。围棋之美原在海阔天空，盘上任何一点都可落子。
但日本棋坛的规章建制成于封建之幕府时代，故虽至昭和年代，仍遗留许多陋规，譬如三·三称之为鬼门打，便是忌讳之着。
吴先生以十八岁之少年，面对代表传统君临日本棋坛已三十年之秀哉毅然以三·三起手，向不合理之陋习挑战。吴先生在决定如此起局之前，也必衡量过会因此引来多少批评指摘。从时代潮流而言，此封建遗习最后必将随幕府制度而俱去。但在将去未去之际，以异国少年一人，挑战三百年绝对之传统，不挠不沮，此局后来称为“昭和之名局”，其时代意义或更在棋局本身内容之上也。
  若无充分自信，几番挫折，生趣略尽，必然难以为继。
吴先生首创雪崩定式，其中某些变化，一般都认为不利，但吴先生却屡屡尝试，而且愈是重要的比赛，愈加以使用。或以此相问，吴先生总说：还有些演变，没有研究透彻，或者未必不利，其所以必要在重要比赛场合试用，乃因为只有真剑决胜，全力以赴，才能窥前所未窥。吴先生自信之充分，对真理的执著，有若此者。
 莫教浮云遮望眼  宋朝有位大政治家王安石，做过两句诗：“只缘身在最高层，不畏浮云遮望眼。”
  二十五年前，我路过东京，曾拜访吴清源先生，那时吴先生仍活跃棋坛，而林国手到日本六七年了，成绩也蒸蒸日上。我问吴先生，他怎样教海峰的，吴先生说：“现在弈棋都是公开下，也没什么秘手可教，我只和海峰下过两盘棋，告诉他一句话：‘追二兔不得一兔’；
作为一个华侨，要在异国出人头地，只有追一只兔子。”
 怀念魏重庆  这是用庄子“无能者无所求，蔬食而遨游，泛若不系之舟”的典故，正是对过去的一些感叹。
  《庄子》一书是极为注重个人价值的，心内之物远远贵重于外物，外物于我何所加？外物于我何所减？所有对外的追求都是无谓的和无意义的，要知道，灵巧，聪明，富贵，权势这些为世人所看重的东西，庄子并不看重也并不不看重，只要无损于内心，不为物所累就可以，因为许许多多的东西都是上天赋予你的，是你本身属性的一部分，一定要执着于某一点就无法解脱。对于外物无所执，无所求，物来则应，过去不留，也就可以了。   这是和李义山那首著名的五言古诗： 向晚意不适， 驱车登古原。 夕阳无限好， 只是近黄昏。
 桥游散记  因此，大家都不急，酒酣饭饱之后，十点多钟才去夜访达姬玛哈，玛哈是梵文宫殿的意思。
背负着一条浩瀚的河，三面庭园，由宫墙围着，占地约百甲。我们先沿着宫墙走，黑黝黝的，一个转折，穿过正门，才进入庭园，视界蓦然地一变；玛哈遥遥地浮在那里。大理石的殿堂，圆圆的拱顶，浴在月光下。银白色的月光，银白色的殿堂，连天也是银白色的，全溶在一块。庄严、妩媚，可望而不可即，朦朦胧胧的一片。达姬玛哈是动员两万奴工，造了二十年才造成的。全部用纯白透明的大理石。殿堂内部，每块大理石上都雕了花草鸟兽；却不只是雕，是磡，把大理石按着图案雕空了，再用配好了颜色的玛瑙、宝玉嵌进去，精致生动如鬼斧神工。 但是达姬最美的还是那建筑本身，埃及的金字塔，巴黎的凡尔赛宫，希腊的雅典娜神庙，秘鲁的印加皇宫，雄伟典雅，各擅胜场，和白天的达姬，可相伦比；但是浸浴在月光下的达姬，便和它们都不同了，达姬是女性的，四周庭园的布置，护柱的设计，都衬托出玛哈的雍容华贵。月光洒下来，整个达姬玛哈便似有了生命，如下凡的仙子，绰约妩媚令人不敢逼视。
  建筑达姬玛哈的故事，几乎和玛哈本身一样的美。 十五世纪帖木尔的子孙侵入印度，建立了回教皇朝，三传而至萨将，萨将原非嫡出，娶了国舅的女儿——就是后来的达姬——才得势，婚后宫廷争权，东征西讨，两人形影不离，患难中更增恩爱。结缡十七年，生了十四位子女。生最后一位王子时，达姬难产去世。此后萨将即未再娶，穷举国之力，历二十余载，遍延名匠，亲自策划，筑成了纪念爱妻的达姬玛哈。 墓成之后，每逢亡妻的忌辰，便携了长公主——达姬易篑之际，在病榻前叮嘱长女，代她照顾老父，这位长公主遵母遗命，便终身未嫁——来朝祭。达姬的忌日也是当时一年一度的大典，全国各地的王子大将，都骑了宝象骏马，先期聚集列阵宫墙之外。薄暮时分，大帝缓缓而来，向诸侯略表谢意，便和长公主两人进入庭园。据长公主后来的描述：每次父王总要先抚摸遗棺，痛恸一番，然后依棺向她娓娓地道述当年夫妇两人共同奋斗患难恩爱的事情，直到玉兔东上，月光从雕缝中漏洒下来——当时印度用的是太阴历，达姬的忌辰正在月圆——父王才由她服侍着在简陋的厢房里就寝，陪伴爱妻度过一夕。次晨，祭拜之后，方才离去。
 “做我所能，爱我所做”  在急诊室的那一晚，心情是很可怕的，因为可以明显地感觉到手、脚的能力愈来愈差，讲话也愈来愈不方便。生命正一点一滴地从身上流逝出去。那时我曾想到生死的问题。平常我总以理性的态度思考问题，也几次主持参与和医师心理学家一起讨论生死的问题，但那时是以一个学者的身份，看一大堆统计数字，超脱悠然地讨论，现在却是一个病患，自己是统计数字中的“惟一”，没了就没了。从群体的角度，个人的生死是整体生命延续的一个过程，但身历其境，没了就没了，一切都没了，思考的角度是很不一样的。
 </content>
    </entry>
    
     <entry>
        <title>Linux.AWK</title>
        <url>http://domain.yqjdcyy.com/post/linux.awk/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Description AWK  1977年，贝尔实验室开发的文本处理神器 命名取自其创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan 的姓的首字母 推荐书籍 《The AWK Programming Language》
GAWK GNU Project 的 AWK 解释器
  Command Format  awk [options] [-f program-file|program-text] file... awk &#39;BEGIN{ &amp;lt;commands&amp;gt; } pattern{ &amp;lt;commands&amp;gt; } END{ &amp;lt;commands&amp;gt; }&#39;  执行 BEGIN 逐行扫描匹配 PATTERN 执行 END   Options    类型 变量 含义     常用      -F 
&amp;ndash;field-separator  指定字段分隔符    -v =
&amp;ndash;assign = 设置变量值，在 BEGIN 模块开始执行前执行    -E 
&amp;ndash;exec  类似 -f，针对于脚本、 CGI 应用
将禁用命令行变量赋值    -e 
&amp;ndash;source  在命令行中执行源代码   文件      -d[file]
&amp;ndash;dump-variables[=file] 将全局变量打印至文件
默认打印至 awkvars.out    -p 
&amp;ndash;profile  保存性能分析数据
默认为 awkprof.out    -g
&amp;ndash;gen-pot 描述并解析 AWK 程序至 GNU .pot（Portable Object Template） 文件中    -V
&amp;ndash;version 打印详细的版本信息   可选      -O
&amp;ndash;optimize 启用优化    -h
&amp;ndash;help 打印帮助文档    -P
&amp;ndash;posix 开始兼容模式
\x不被解析    -n
&amp;ndash;non-decimal-data 识别数据中的八进制、十六进制数据
谨慎使用    -b
&amp;ndash;characters-as-bytes 将所有输入均当成单字节字符    -t
&amp;ndash;lint-old 针对不可移植于 Unix AWK 的结构的警告    -L [value]
&amp;ndash;lint[=value] 针对可疑、不可移植的结构代码提供警告    -S
&amp;ndash;sandbox 开启沙盒模式
使用 system() 方法，使用 getline 进行输入，使用 print[f] 进行输出
有效地阻止脚本对本地资源的访问    -N
&amp;ndash;use-lc-numeric 解析输入数据时，强制 GAWK 使用本地十进制的点   版本相关      -c
&amp;ndash;traditional 兼容模式，不使用 GAWK 扩展    -r
&amp;ndash;re-interval 允许在正则表达式中使用区间表达式
默认允许，需配合 --traditional 使用    -C
&amp;ndash;copyright 打印简短的 GNU 版权信息    -R
&amp;ndash;command file 从文件中读取命令
仅 DGAWK 可用    Built-in Variables    类型 变量值 含义     常用      $0 当前记录行    $1~$n 当前记录的第n个字段，字段间由FS分隔    FS 输入字段分隔符
默认为空格或Tab    RS 输入的记录分隔符
默认为换行符    OFS 输出字段间分隔符
默认为空格    ORS 输出行间分隔符
默认为换行符   补充      ENVIRON 当前环境属性拷贝列表，使用如 ENVIRON[&amp;quot;HOME&amp;quot;]    NF 当前记录行的列数    NR 已读记录行数，从1开始
跨多文件    FNR 当前文件的已读记录行数    FILENAME 当前输入文件的名字    OFMT 输出数据格式
默认为%.6g    RT 输出行分隔符
默认同 RS    ARGC 命令行参数的数目    ARGIND 命令行中当前文件的位置(从0开始算)    ARGV 包含命令行参数的数组    CONVFMT 数字转换格式
默认为%.6g    ERRNO 最后一个系统错误的描述    FIELDWIDTHS 字段宽度列表
用空格键分隔    IGNORECASE 忽略大小写的匹配    RLENGTH 由 match 函数所匹配的字符串的长度    RSTART 由 match 函数所匹配的字符串的第一个位置    SUBSEP 数组下标分隔符
默认为 /034    Printf.*    类型 变量 含义     基础      %c 字符
若输入数字，则转为对应字符
若输入为文本，则仅输出首字符    %d, %i 小数，整数    %e, %E [-]d.dddddde[&#43;-]dd 形式浮点数    %f, %F [-]ddd.dddddd 形式浮点数    %g, %G 彩 %e 和 %f 形式数据中短者    %o 无符号八进制数    %u 无符号十进制数    %s 字符文本    %x, %X 无符号十六进制数
%X 则将使用大写字母显示    %% %   补充      - 左对齐    space 数值转换时，正值无符号，负数补-    &#43; 于宽度修饰符前使用，正数时补&#43;    # 修饰符，如八进制前补0，十六进制前补0x    0 数值显示时，值小于字段宽度时，补0    width 字段填充至指定宽度    .prec 指定数值的小数位精度    *.Functions  详见 Reference/ Man  Numeric String Time Bit Manipulations Type Internationalization   Example Data  cat netstat.log
Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 1 0 localhost:59796 localhos:macromedia-fcs CLOSE_WAIT tcp 0 0 localhost:55125 localhost:mysql ESTABLISHED tcp 1 0 localhost:59184 localhos:macromedia-fcs CLOSE_WAIT tcp 0 0 iZ94nvigjtdZ:scp-config iZ94nvigjtdZ:35778 ESTABLISHED tcp 0 720149 localhost:47634 localhost:20100 FIN_WAIT1  netstat.log
  Show  awk &#39;{print $1, $6}&#39; netstat.log
Active Proto Foreign tcp CLOSE_WAIT tcp ESTABLISHED tcp CLOSE_WAIT tcp ESTABLISHED tcp FIN_WAIT1  Format  awk &#39;{printf &amp;quot;%-8s %-22s\n&amp;quot;, $1, $6}&#39; netstat.log
Active Proto Foreign tcp CLOSE_WAIT tcp ESTABLISHED tcp CLOSE_WAIT tcp ESTABLISHED tcp FIN_WAIT1   Filter  awk &#39;$2&amp;gt;0 &amp;amp;&amp;amp; $6==&amp;quot;ESTABLISHED&amp;quot; &amp;amp;&amp;amp; $5 ~ /47400|42785/ || NR== 2 {printf &amp;quot;%&#43;d\t%20s\t%-20s\n&amp;quot;,$2,$5,$6}&#39; netstat.log | less
&#43;0 Address Foreign &#43;205414 localhost:47400 ESTABLISHED &#43;223733 localhost:42785 ESTABLISHED   File  awk &#39;NR!= 1 { if($6 ~ /FIN_WAIT|ESTABLISHED|CLOSE_WAIT/) printf &amp;quot;%s\n&amp;quot;, $0 &amp;gt; $6;}&#39; ../netstat.log
-rw-rw-r-- 1 appuser appuser 5840 Jul 11 16:31 CLOSE_WAIT -rw-rw-r-- 1 appuser appuser 41840 Jul 11 16:31 ESTABLISHED -rw-rw-r-- 1 appuser appuser 3280 Jul 11 16:31 FIN_WAIT1 -rw-rw-r-- 1 appuser appuser 480 Jul 11 16:31 FIN_WAIT2 awk -f sum.awk ../netstat.log
 cat sum.awk
#!/bin/awk -f BEGIN{ wait= 0 printf &amp;#34;TYPE NUM\n&amp;#34; printf &amp;#34;-------------------\n&amp;#34; } { wait&#43;=$6 ~ /WAIT/? 1: 0 printf &amp;#34;%10s\t%d\n&amp;#34;, $6, ($6 ~ /WAIT/? 1: 0) } END{ printf &amp;#34;--------------------\n&amp;#34; printf &amp;#34;\tWAIT.NUM:%10d\n\tWAIT.AVG: %10f\n&amp;#34;,wait, wait/NR } result
TYPE NUM ------------------- 0 Foreign 0 CLOSE_WAIT 1 ESTABLISHED 0 .... CONNECTED 0 -------------------- WAIT.NUM: 136 WAIT.AVG: 0.176853  awk &#39;{print $1}&#39; access.log |sort|uniq -c|sort -nr|head -10
  Reference Man  gawk.log  More  AWK 简明教程 linux awk命令详解 awk、nawk、mawk、gawk的简答介绍 Linux awk 命令 awk命令  </content>
    </entry>
    
     <entry>
        <title>Hello.FFmpeg</title>
        <url>http://domain.yqjdcyy.com/post/hello.ffmpeg/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>FFmpeg</tag>
        </tags>
        <content type="html">  概要  ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...  流程 _______ ______________ | | | | | input | demuxer | encoded data | decoder | file | ---------&amp;gt; | packets | -----&#43; |_______| |______________| | v _________ | | | decoded | | frames | |_________| ________ ______________ | | | | | | | output | &amp;lt;-------- | encoded data | &amp;lt;----&#43; | file | muxer | packets | encoder |________| |______________| 示例 图片.* 截图  ffmpeg -i dest/png_mp3.mp4 dest/png_mp3-mp4/%d.jpg  **必须** 先创建[dest/png_mp3-mp4]文件夹   动态图  ffmpeg -i video/bike.mp4 -ss 0 -t 2 -vf &amp;quot;fps=15,scale=320:-1&amp;quot; -y dest/bike-vf.gif
file[fps=15,scale=320:-1].size= 825K ffmpeg -i video/bike.mp4 -ss 0 -t 2 -r 24 -s 320:260 -y dest/bike-rs.gif
file[-s 320:260].size= 2,252K file[-r 24 -s 320:260].size= 1,824K  视频.* 格式转换  ffmpeg -i old.video -vcodec libx264 -r 24 -s 640x360 -acodec libmp3lame -write_xing 0 -ar 22050 -ab 24k -y new.mp4  -vcodec libx264  设置视频视频编解码器，未设置时则使用与输入文件相同之编解码器  -r 24  每秒帧数 frames per second，默认25  -s 640x360  设置帧尺寸 WXH 与来源一致 640x360 指定尺寸  -acodec libmp3lame  设置音频编解码器  -ar 22050  设置音频采样频率,默认24000  -ab 24k  设置声音比特率，32/ 64/ 96/ 128  -y  覆盖输出文件    转 M3U8  ffmpeg -i origin.wmv -codec:v libx264 -codec:a mp3 -map 0 -f ssegment -segment_format mpegts -segment_list ./m3u8/index.m3u8 -segment_time 10 ./m3u8/’%04d.ts’  -codec:v libx264  针对视频使用 H.264/MPEG-4 AVC encoder  -codec:a mp3  针对音频使用 mp3 编码器  -map 0  指定你所要从输入流中 选择或拷贝 到输出流中的片段 -map [-]input_file_id[:stream_specifier][?][,sync_file_id[:stream_specifier]] | linklabel 如 -map 1:0 -map 1:1 表示将第二个输入文件的第一个流和第二个流写入输出文件  -f ssegment  强制使用 ssegment 格式  -segment_format mpegts  重置内部容器格式，默认通过文件后缀自动选定  -segment_list ./m3u8/index.m3u8  生成指定名称的列表目录信息文件，默认不生成  -segment_time 10 &#39;./m3u8/’%4d.ts&#39;  指定分割片段的时长，必须为延续时间段 默认值为 2 秒，且分割不一定是精确的，除非给定指定时间上的参照流的关键帧    M3U8 转  常用
 ffmpeg -i index.m3u8 [-c copy -bsf:a aac_adtstoasc] -y output.mp4  Result ts.time: 603.386| 10:03 mp4.time: 04:50.55 **实际时长与转换后时长不一致** 偶现 Error Non-monotonous DTS in output stream 0:0; previous: 26142599, current: 24141600; changing to 26142600. This may result in incorrect timestamps in the output file. ResultDuration is less than real duration Duration ffmpeg -i index.m3u8 -y output.mp4 1:53.81 ffmpeg -i index.m3u8 -c copy -bsf:a aac_adtstoasc -y output.mp4 0:05.51 优化
 针对常用可能出现的 TS 片长度与 m3u8 文件中记录值存在偏差，导致合成 时长不足的异常 ffmpeg -i all.ts -codec copy -y output.mp4  ls -v *.ts | grep &amp;#34;[0-9]&amp;#34; | xargs cat &amp;gt; all.ts 阿里云存在使用 `ls` 无法正常获取所有 ts 的偶然情况 cat index.m3u8 | grep &amp;#34;.ts&amp;#34; | xargs cat &amp;gt; all.ts 兼容处理以上异常 针对 **大文件**，会有一定的 **效率提升**  ffmpeg -f concat -safe 0 -i list -codec copy -y output.mp4
cat index.m3u8 | grep &amp;#34;.ts&amp;#34; | awk &amp;#39;{printf &amp;#34;file %s\n&amp;#34;, $0}&amp;#39; &amp;gt; list 速度较 all.ts **慢差不多一倍** 异常 ts 无法处理的情况 0.ts: Invalid data found when processing input 效率可参见 补充 - all.ts 与 ts.list 方案对比
  其它格式
 ffmpeg -i index.m3u8 -vcodec libvpx -acodec vorbis -strict -2 -ac 2 -ar 22050 -ab 24k -y common.webm ffmpeg -i index.m3u8 -vn -acodec libmp3lame -write_xing 0 -ar 22050 -ab 24k -y common.mp3 ffmpeg -i index.m3u8 -vn -acodec vorbis -strict -2 -ac 2 -ar 22050 -ab 24k -y common.ogg ffmpeg -i index.m3u8 -codec copy -y common.mp4   图音合成  ffmpeg -i img/bg.png -i audio/bgm-min.mp3 [-acodec copy] -y dest/png_mp3.mp4 ffmpeg -i dest/png_mp3_loop-mp4/%d.jpg -i audio/bgm-min.mp3 -y dest/jpgs_mp3.mp4 ffmpeg -i img/loop/%d.png -r 24 -i audio/bgm-min.mp3 -y dest/pngs_r24.mp4
imgs(25)&#43; audio(3s)= video(3s) ffmpeg -framerate 6 -i img/loop/%d.png -i audio/bgm-min.mp3 -y dest/pngs_framerate6.mp4
imgs(25)&#43; audio(3s)= video(4s, 6 frame/second)  音频.* 解码  ffmpeg -i old.audio -vn -acodec libmp3lame -write_xing 0 -ar 22050 -ab 24k -y new.audio  -vn  禁止视频记录    其它 裁剪  ffmpeg -i old.mp3 -ss 56.808 -t 999 -write_xing 0 new.mp3  -i old.mp3  来源  -ss 56.808  起始时间点，单位秒  -t 999  结束时间，单位秒  -write_xing 0  微信-IOS 音频支持    定时请求代理  指令  ffmpeg -re -i big.mp3 -f mp3 http://rtmp.com/proxy/dc6af2ec  解析  -re 以本机帧速率来读取输入 -f mp3 强制输入或输出的文件格式 http://rtmp.com/proxy/dc6af2ec 代理请求接口   参考 官网  ffmpeg FFmpeg Formats Documentation FFmpeg - wiki FFmpeg - github  IMG-&amp;gt; Video  Combine one image &#43; one audio file to make one video using FFmpeg Useful ‘FFmpeg’ Commands for Video, Audio and Image  How do I convert a video to GIF using ffmpeg, with reasonable quality?  M3U8-&amp;gt; Video  FFMPEG mp4 from http live streaming m3u8 file? Proper command to convert m3u8 to mp4 利用ffmpeg合併m3u8串流影片，並且轉成MP4格式  其它  使用ffmpeg将视频转ts
  细节  yqjdcyy/Hello_Ffmpeg  </content>
    </entry>
    
     <entry>
        <title>注册资本</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B3%A8%E5%86%8C%E8%B5%84%E6%9C%AC/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>商业</tag>
        </tags>
        <content type="html">  注册资本 作用  定义公司最高能承担的债务值 有限责任公司  公司的股东对公司的债务承担 有限的责任 责任上限就是公司的注册资本   法规  除了仍旧实行法定注册资本的行业外(比如银行、保险、证券、融资租赁、建筑施工、典当、外商投资、劳务派遣等十四类行业)，注册资本 随意设定都是可以的 由 实缴制 调整为 认缴制  之前在实缴制的时候，注册资本是需要验资报告 现在只有一些招投标项目或者比较大型的合作伙伴，为了确认合作公司的注册资本已经实缴，需要合作公司出具验资报告   注意事项  参考所在行业资质要求
 互联网公司申请ICP经营许可证时，ICP经营许可证要求公司注册资本在100万以上 天猫、京东也对入驻平台的商家提出注册资本为200万以上的要求 其他需要资质/资格的，如招投标等，参照行业通行做法  注册资本越大，承担的风险/责任就越大
 参见「示例一」  印花税
 每年年底，企业要按实收资本和资本公积缴纳 万分之五的印花税   示例  「A」占70%股权，公司最后欠了1000万的外债
 注册资本为100万  「A」最多只需用他70万的出资额来承担责任  欠了1000万的外债  「A」承担700万的责任   注册资本最多
 安徽玉龙地智慧餐饮 50,000 亿  注册了一家100万注册资本的公司，后来不想经营了，是否需要补全这100万
 没有外债  不需要 直接走 正常的注销流程即可  有外债  按照你所占的股权比例，承担对应的债务责任 认缴制  不用现在一次性把钱掏出来，但是承担的法律责任是在的    注册资本可以 使用吗
 可以  个人  相应的发票报销  工资 劳务费用 奖金   合作价值较高项目，通常需重新设立项目公司
 土地开发  情况  「A」有土地 「B」有开发能力和钱  合作模式  「B」借钱给「A」  缺点  资金 不安全  如果「B」方违约不给「A」钱，就会导致「A」方的项目运营不下去，使其陷入窘境 收益受到民间借贷法规的束缚    「A」「B」共同设立项目公司，「A」投入土地，「B」承诺出资  优点  保证「B」的资金安全和相应收益的 合法性，也让项目的负债不至于波及到「A」，对「B」的投资承诺予以法律上的确认 100% 认缴也允许「B」在项目工程 需要时再投钱进来，而不是开公司就要往里放钱 这种操作方式很好的弥补了合同在对承诺投资的约束上的薄弱。因为一般来讲不履行对投资的承诺，支付少量违约金即可。甚至于自然人之间的借款属于实践合同，不给就不给了       参考  一个公司注册资金多少才是最好 公司注册资本多少是什么概念？  </content>
    </entry>
    
     <entry>
        <title>Linux.Time</title>
        <url>http://domain.yqjdcyy.com/post/linux.time/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Command Function  测量指定指令执行所消耗的时间、系统资源  Format  time [options] &amp;lt;command [arguments...]&amp;gt;  result /usr/bin/time -p ls -l total 2104 -rw-rw-r-- 1 appuser appuser 218 Aug 14 2017 curl-cookie-test real 0.00 user 0.00 sys 0.00 options  option
   选项 描述     -f &amp;lt;FORMAT&amp;gt;
&amp;ndash;format=&amp;lt;FORMAT&amp;gt; 指定输出格式
重写环境变量 TIME 指定的模式   -p
&amp;ndash;portability 使用 POSIX 的默认格式   -o &amp;lt;FILE&amp;gt;
&amp;ndash;output=&amp;lt;FILE&amp;gt; 将结果 重定向至指定文件   -a
&amp;ndash;append 结合 -o &amp;lt;FILE&amp;gt; 使用；表示以追加形式写入   -v
&amp;ndash;verbose 输出 详细结果   &amp;ndash;help 打印帮助文档   -V
&amp;ndash;version 打印版本信息    option.format
   类型 选项 描述     时间      %E 消耗时间，格式为 [hours:]minutes:seconds    %e 实时运行用时，以秒为单位    %S System Time
内核运行的总体 CPU 时间，以秒为单位    %U User Time
用户模式运行下的总体 CPU 时间，以秒为单位    %P 当前任务所占 CPU 百分比
公式为 (%U &#43; %S) / %E   内存      %M 进程生命周期内的 最大驻留大小，单位为 KB    %t 进程 平均驻留大小，单位为 KB    %K 进程 平均总内存使用情况，单位为 KB； 公式为 数据&#43; 堆栈&#43; 文本    %D 进程的 非共享数据区域大小，单位为 KB    %p 进程的 非共享堆栈空间 平均值，单位为 KB    %X 进程的 共享文本空间的 平均值，单位为 KB    %Z 系统的 页面大小，以字节为单位
各系统预设常量值不同    %F 进程运行时发生 错误的主 页面（必须由硬盘中读取）数量    %R 小、可恢复的页面错误的数量，特指其它虚拟页面未声明但无效的错误；因此页面数据仍然有效，但系统页面分配表需要更新    %W 进程被 调换出主内存的次数    %c 进程被动进行 上下文切换的次数
时间片过期的情况    %w 进程主动进行 上下文切换后的等待时长
例如 等待 I/O操作的完成   I/O      %I 进程中进行文件 输入的数量    %O 进程中进行文件 输出的数量    %r 进程 接收 socket 消息的数量    %s 进程 发送的 socket 消息的数量    %k 提交给进程的 信号数量    %C 正在被講的命令的名称和命令行参数    %x 命令行的 退出状态码     option.format.exit_status
   类型 状态值 描述     成功      0 正常结束   失败      64 命令行使用错误    65 数据格式错误    66 无法打开输入流    67 地址未知    68 主机名未知    69 服务不可用    70 内部软件错误    71 系统错误    72 关键系统文件缺失    73 无法创建输出文件    74 输入输出错误    75 重试
临时错误    76 远程协议错误    77 权限不足    78 配置错误    126 命令无法执行    127 命令未找到      command  正常调用指定，如 ll  但需要使用完整路径  ll 需使用 ls -l 调用文件时，使用完整路径名    Example  /usr/bin/time -v ps -aux
 显示指令的完整信息
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 2 0.0 0.0 0 0 ? S 2017 0:06 [kthreadd] Command being timed: &amp;#34;ps -aux&amp;#34; User time (seconds): 0.00 System time (seconds): 0.01 Percent of CPU this job got: 78% Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.01 Average shared text size (kbytes): 0 Average unshared data size (kbytes): 0 Average stack size (kbytes): 0 Average total size (kbytes): 0 Maximum resident set size (kbytes): 1736 Average resident set size (kbytes): 0 Major (requiring I/O) page faults: 0 Minor (reclaiming a frame) page faults: 532 Voluntary context switches: 2 Involuntary context switches: 240 Swaps: 0 File system inputs: 0 File system outputs: 0 Socket messages sent: 0 Socket messages received: 0 Signals delivered: 0 Page size (bytes): 4096 Exit status: 0  /usr/bin/time -f &amp;quot;\ntime: %E&amp;quot; /usr/local/ffmpeg -i /data/090913f7-b3e3-4050-ba7b-a9d7d664fd8d/record.m3u8 -c copy -bsf:a aac_adtstoasc -y /data/090913f7-b3e3-4050-ba7b-a9d7d664fd8d/090913f7-v2.mp4
 定制显示数据格式
[mp4 @ 0x291f020] Non-monotonous DTS in output stream 0:0; previous: 26142599, current: 24141600; changing to 26142600. This may result in incorrect timestamps in the output file. frame=12746 fps=2334 q=-1.0 Lsize= 27848kB time=00:04:50.71 bitrate= 784.7kbits/s speed=53.2x video:25851kB audio:1731kB subtitle:0kB other streams:0kB global headers:1kB muxing overhead: 0.966411% time: 0:05.51   Supplement  页面错误
 由系统硬件引起的异常类型，当进程访问内存页面，MMU 未映射到进程的虚拟地址空间  MMU
 Memory Management Unit 内存管理单元   Reference 官方  time.main  man time   参考  Page fault Linux命令详解 — time shell 程序 返回码 退出码 sysexits.h  </content>
    </entry>
    
     <entry>
        <title>Hello.Docker.Network</title>
        <url>http://domain.yqjdcyy.com/post/hello.docker.network/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Docker</tag>
        </tags>
        <content type="html">  Driver Bridge 描述  软件形式的网络桥接，允许同一网桥内的容器互相通信，并隔离未连接网桥的容器  通过驱动在主机自动安装规则实现 启动 Docker 时默认创建，并将新启动的容器连接到它  默认 网络驱动类型  场景  同一 Docker 运行实例中运行的容器  示例 docker network create \  --driver bridge \  alpine-net 补充  user-defined bridge
 区别  用户自定义桥接网络，优于 默认桥接网络 提供了容器间以更好的隔离性与互操作性  容器连接到用户自定义桥接网络，对桥接网络 内 的所有容器 开放所有端口，对网络 外的 屏蔽所有端口  自动通过容器的名称或别名，实现类似 DNS 的链路解析  示例
# 创建用户定义桥接网络docker network create my-net# 创建容器并指定于用户定义桥接网络docker create --name my-nginx \ --network my-net \ --publish 8080:80 \ nginx:latest# 将已运行的容器(连接|取消连接)于用户定义桥接网络docker network (connect|disconnect) my-net my-nginx   Host 描述  移除容器间的网络隔离，直接使用主机的网络  于 Docker 17.06 及更高版本的 集群配置 中可用   场景  略  示例 docker run \  --net=host \  -v $PWD:/data corfr/tcpdump \  -i any \  -w /data/dump.pcap \  &amp;#34;icmp&amp;#34; Overlay 描述  在 Docker 守护进程之间创建了分布式网络  确保链接到它的容器安全、准确地通信 主要用于删除容器之前执行系统级路由的需求  创建集群或加入已有集群时，会创建如下网络  ingress 用于处理服务控制和数据传输，默认连接 docker_gwbridge网桥，用于将集群中涉及的 Docker 守护进程连接起来  默认开放规则  TCP 2377  集群管理通信  TCP|UDP 7946  节点间通信  UDP 4789  覆盖网络流量    场景  支持服务 集群 彼此通信 支持服务集群与独立容器之间的通信 支持位于 不同 Docker 守护进程 的独立容器之间的通信  示例 docker network create \  --driver overlay \  --ingress \  --subnet=10.11.0.0/16 \  # 子网 --gateway=10.11.0.2 \  # 网关 --opt com.docker.network.driver.mtu=1200 \  # MTU 1200 my-ingress Macvlan 描述  为容器指定 MAC 地址，于自己网络中暴露为一物理设备  Docker 守护进程支持通过 MAC 地址将通信路由到容器 可使用不同的物理网络接口来隔离 Macvlan 网络  模式  网络桥接  通过主机上的物理设备通信  802.1q  更细粒度地控制路由和过滤   注意事项
 合理规划 单物理接口可分配多 MAC 地址
场景  需要 直连物理网络 情况
 监视网络通信的应用程序
  示例 docker network create \  -d macvlan \  --subnet=172.16.86.0/24 \  --gateway=172.16.86.1 \  -o parent=eth0 pub_net None 描述  禁用所有网络  集群配置中不可用   场景  适用于与 自定义网络驱动 一同使用  示例 docker run \  --rm -dit \  --network none \  --name no-net-alpine \  alpine:latest \  ash Reference 官方  大纲
 Overview Docker container networking docker network  明细
 bridge networks use the host network overlay networks Macvlan networks disable container networking  指令
 docker network   补充  docker 容器的网络模式 Docker Reference Architecture: Designing Scalable, Portable Docker Container Networks Docker container networking  </content>
    </entry>
    
     <entry>
        <title>追诉时效</title>
        <url>http://domain.yqjdcyy.com/post/%E8%BF%BD%E8%AF%89%E6%97%B6%E6%95%88/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>法律</tag>
        </tags>
        <content type="html">  追诉时效 民事时效  民事案件是有诉讼时效的，在诉讼 时效之内未起诉，超过时效之后再起诉，就会 丧失胜诉权 &amp;gt; 法院会给你立案，法官会开庭审理 &amp;gt;&amp;gt; 在对方不主张原告超过诉讼时效的情况下，法官不会主动适用时效规定判决原告败诉。
但如果被告主张原告超过诉讼时效的，不管原告的主张多么合情合理，证据多么充分，都不会胜诉的。
 法律不保护躺在权利上睡觉的人
  刑事时效 设置  《规范刑法学》 &amp;gt; 刑法上的时效，是指刑事法律规定的国家对犯罪人行使刑事追诉权和刑罚执行权有效期限的制度。
在有效期内，国家如果不行使刑事追诉权和刑罚执行权，超过期限刑事追诉权和刑罚执行权即归于消灭。对犯罪人就不能再追诉或者执行刑罚。
  刑事司法中，超过追诉时效的，追诉权、求刑权、审判权及行刑权 一并消灭，不 能 再 对犯罪人启动刑事 诉讼 程序  原则 稳定  刑罚的 目的来说，刑罚是改造犯罪人，令其弃恶从善、回归社会  如果一个人在犯罪之后，很多年都不再有任何违法犯罪行为，时间已经证明了这个人已经弃恶从善，不会再对社会有任何危害，将其投入监狱恐怕没有好处只有坏处了  刑罚有一般预防和特殊预防两个 作用
 特殊预防是指将犯罪人本人关起来，使他不得继续犯罪 一般预防是指通过惩罚犯罪的人对社会公众进行警告  犯罪侵害的社会秩序，多年修复后已然平复、稳定
 翻旧案容易引发新的社会矛盾，不利于社会稳定   省钱  在证据搜集、人员抓捕等等事宜上需花费更加巨大的人力物力 成本，占用更多的司法资源  这样的情况下还 容易产生冤假错案，得不偿失   期限  【追诉时效期限】犯罪经过下列期限不再追诉： &amp;gt; (一)法定最高刑为不满五年有期徒刑的，经过五年;
&amp;gt; (二)法定最高刑为五年以上不满十年有期徒刑的，经过十年;
&amp;gt; (三)法定最高刑为十年以上有期徒刑的，经过十五年;
&amp;gt; (四)法定最高刑为无期徒刑、死刑的，经过二十年。如果二十年以后认为必须追诉的，须报请最高人民检察院核准。
 法定最高刑  如果是同一条文中，有几个量刑幅度时，即按其罪行应当适用的 量刑幅度的法定最高刑计算 示例  故意伤害罪  处三年以下有期徒刑或者拘役 致人重伤的三到十年 致人死亡或者以特别残忍手段致人严重残疾的十年以上有期徒刑、无期徒刑或者死刑    追诉延长  刑法第八十八条 &amp;gt; 在人民检察院、公安机关、国家安全机关立案侦查或者在人民法院受理案件以后，逃避侦查或者审判的，不受追诉期限的限制。
被害人在追诉期限内提出控告，人民法院、人民检察院、公安机关应当立案而不予立案的，不受追诉期限的限制。
 </content>
    </entry>
    
     <entry>
        <title>Linux.User</title>
        <url>http://domain.yqjdcyy.com/post/linux.user/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  参考  创建、删除用户 Linux系统中切换用户身份su与sudo的用法与实例 useradd命令 Linux 用户和用户组管理 更改Linux用户的登录shell环境  指令 adduser  DESCRIBE  为创建的用户指定主目录、系统 shell 版本，并要求输入密码  主动调用 /etc/adduser.conf 默认创建 /home/user.name目录   FORMAT  adduser &amp;lt;user.name&amp;gt;  OPTIONS  --home  指定创建主目录的路径，默认是在 /home 目录下创建用户名同名的目录，这里可以指定； 如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。  --quiet  即只打印警告和错误信息，忽略其他信息。  --debug  定位错误信息。  --conf  在创建用户时使用指定的 configuration 文件。  --force-badname  默认在创建用户时会进行 /etc/adduser.conf 中的正则表达式检查用户名是否合法  如果想使用弱检查，则使用这个选项 如果不想检查，可以将 /etc/adduser.conf 中相关选项屏蔽     useradd  DESCRIBE  默认无密码、目录和指定 shell 版本  FORMAT  useradd [option]   OPTIONS  c &amp;lt;备注&amp;gt;  加上备注文字。备注文字会保存在 passwd 的备注栏位中；  d &amp;lt;登入目录&amp;gt;  指定用户登入时的启始目录；  D  变更预设值；  e &amp;lt;有效期限&amp;gt;  指定帐号的有效期限；  f &amp;lt;缓冲天数&amp;gt;  指定在密码过期后多少天即关闭该帐号；  g &amp;lt;群组&amp;gt;  指定用户所属的群组；  G &amp;lt;群组&amp;gt;  指定用户所属的附加群组；  m  自动建立用户的登入目录；  M  不要自动建立用户的登入目录；  n  取消建立以用户名称为名的群组；  r  建立系统帐号；  s&amp;lt;shell&amp;gt;  指定用户登入后所使用的shell；  u&amp;lt;uid&amp;gt;  指定用户id。 ID 值尽量 &amp;gt; 500，以避免冲突   EXAMPLE  useradd tmpuser -c &#39;useradd.c for passwd&#39; -u 8888 -M -e 1 passwd tmpuser   usermod  参数同 useradd EXAMPLE  usermod -s /bin/sh tmpuser  cat /etc/shells  查看本机支持的 shell 版本     userdel  DESCRIBE  删除用户 将用户账号从 /etc/passwd 等系统文件中的删除  FORMAT  userdel [option]   OPTIONS  -r  连同用户的主目录一并删除   EXAMPLE  userdel tmpuser   passwd  DESCRIBE  口令管理 密码保存在 /etc/passwd  用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell   FORMAT  passwd [option]   OPTIONS  -l  锁定口令，即禁用账号  -u  口令解锁  -d  使账号无口令  -f  强迫用户下次登录时修改口令   EXAMPLE  passwd -l tmpuser   su  DESCRIBE  切换用户 switch user  FORMAT  su [-]   OPTIONS  -  是否切换至新用户工作环境   EXAMPLE  su - appuser  切换用户后，同时切换到新用户的工作环境  su appuser  切换用户后，不改变原用户工作目录、环境变量目录  拥有原用户权限     sudo  DESCRIBE  允许其它用户以管理员权限执行指令 需要 Root 使用 visudo 编辑 /etc/sudoers 才可以授权其它用户  whereis sudoers chmod u&#43;w /etc/sudoers vim /etc/sudoers chmod u-w /etc/sudoers   FORMAT  sudo [-bhHpV] [-s] [-u ] [command]  OPTIONS  -b  在后台执行指令。  -h  显示帮助。  -H  将HOME环境变量设为新身份的HOME环境变量。  -k  结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。  -l  列出目前用户可执行与无法执行的指令。  -p  改变询问密码的提示符号。  -s  执行指定的shell。  -u  &amp;lt;用户&amp;gt; 以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。  -v  延长密码有效期限5分钟。  -V  显示版本信息。  -S  从标准输入流替代终端来获取密码    </content>
    </entry>
    
     <entry>
        <title>Hello.Docker.Compose</title>
        <url>http://domain.yqjdcyy.com/post/hello.docker.compose/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Docker</tag>
        </tags>
        <content type="html">  简介  Compose  定义和运行多个 Docker 容器的应用  Service  应用容器，包括若干运行相同镜像的容器实例  Project  一组关联的应用容器组成的完整业务单元 于 docker-compose.yml 文件中定义   安装  pip install -U docker-compose
Successfully installed backports.ssl-match-hostname-3.5.0.1 cached-property-1.4.3 certifi-2018.4.16 docker-3.3.0 docker-compose-1.21.2 docker-pycreds-0.3.0 dockerpty-0.4.1 docopt-0.6.2 enum34-1.1.6 functools32-3.2.3.post2 idna-2.6 ipaddress-1.0.22 jsonschema-2.6.0 requests-2.18.4 six-1.11.0 texttable-0.9.1 urllib3-1.22 websocket-client-0.48.0 docker-compose version
/usr/lib/python2.7/site-packages/requests/__init__.py:80: RequestsDependencyWarning: urllib3 (1.22) or chardet (2.2.1) doesn&amp;#39;t match a supported version! RequestsDependencyWarning) docker-compose version 1.21.2, build a133471 docker-py version: 3.3.0 CPython version: 2.7.5 OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013  使用 示例  docker-compose up -d
/usr/lib/python2.7/site-packages/requests/__init__.py:80: RequestsDependencyWarning: urllib3 (1.22) or chardet (2.2.1) doesn&amp;#39;t match a supported version! RequestsDependencyWarning) Starting server_redis_redis_1 ... done Starting server_redis_server_1 ... done docker container ls --all
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b533d0f273ec server_redis_server &amp;#34;/bin/sh -c &amp;#39;./serve…&amp;#34; About a minute ago Up 21 seconds 0.0.0.0:8031-&amp;gt;3000/tcp server_redis_server_1 8b4b70a02f29 redis &amp;#34;docker-entrypoint.s…&amp;#34; About a minute ago Up 22 seconds 0.0.0.0:8030-&amp;gt;6379/tcp server_redis_redis_1  docker-compose stop  /usr/lib/python2.7/site-packages/requests/__init__.py:80: RequestsDependencyWarning: urllib3 (1.22) or chardet (2.2.1) doesn&#39;t match a supported version! RequestsDependencyWarning) Stopping server_redis_server_1 ... done Stopping server_redis_redis_1 ... done   docker-compose rm
/usr/lib/python2.7/site-packages/requests/__init__.py:80: RequestsDependencyWarning: urllib3 (1.22) or chardet (2.2.1) doesn&amp;#39;t match a supported version! RequestsDependencyWarning) Going to remove server_redis_server_1, server_redis_redis_1 Are you sure? [yN] y Removing server_redis_server_1 ... done Removing server_redis_redis_1 ... done  指令 docker-compose [-f &amp;hellip;] [options] [COMMAND] [ARGS&amp;hellip;]  Options  -f, --file FILE  指定配置文件，默认为 docker-compose.yml  -p, --project-name NAME  指定项目名称，默认为目录名  --project-directory PATH  指定工具目录，默认于组件的目录  --verbose  显示更多输出  --log-level LEVEL  设置日志等级，可选项为 DEBUG, INFO, WARNING, ERROR, CRITICAL  --no-ansi  不打印 ANSI 控制字符  -v, --version  打印版本信息  -H, --host HOST  实例连接的套接字  --tls  使用 TLS  --tlscacert CA_PATH  仅通过 CA 信任签证  --tlscert CLIENT_CERT_PATH  指定 TLS 证书文件  --tlskey TLS_KEY_PATH  指定 TLS 键值文件  --tlsverify  使用 TLS并以此校验远程请求  --skip-hostname-check  不拿守护进程实例名与客户端证书中指定的名称进行校验  --compatibility  如果设置，则表示将转换 V3 文件中的部署值至非群集等价物   Commands  build  [重新]构建服务  bundle  用组件生成 Docker 包  config  校验、查看组件  create  创建服务  down  停止并删除容器、网络、镜像和  events  从容器接收实时事件  exec  于运行的容器中执行指令  help  获取命名的帮助信息  images  展示所有镜像  kill  杀死容器  logs  显示容器输出  pause  暂停服务  port  展示指定端口绑定的开放端口  ps  展示容器列表  pull  拉取服务镜像  push  推送服务镜像  restart  重启服务  rm  移除已关闭的容器  run  执行一次性的命令  scale  设置服务中的容器数量  start  启动服务  stop  停止服务  top  显示运行中的进程  unpause  不停止服务  up  创建并启动服务  version  展示 Docker-Compose 版本信息    模板 参考  Compose 模板文件  注意事项  默认模板文件名为 docker-compose.yml 每个服务都要经过 image 指定镜像或 build 等以自动构建镜像  build 情况需要 Dockerfile 文件 其中 Dockerfile 中设置的选项，如CMD, EXPOSE, VOLUME, ENV 等会自动被获取   参考 Project  Hello_Docker/server_redis
Compose 官方
 Docker Compose docker/docker.github.io compose-file reference   参考
 Docker 微服务教程 Docker Compose 项目 docker/compose
Python  Installing Python 3 on Linux
 Linux安装python3.6
  </content>
    </entry>
    
     <entry>
        <title>Hello.Docker.Dockerfile</title>
        <url>http://domain.yqjdcyy.com/post/hello.docker.dockerfile/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Docker</tag>
        </tags>
        <content type="html">  Work  Docker 镜像是由只读的层一层层封装而成的，而其中的层均代码着 Dockerfile 指令  Guidlines  保持支持容器可补停止、摧毁，然后重新构建并替换的最小化配置 不管实际执行的 Dockerfile 在哪，当前目录下的文件和目录都将发送至 Docker 守护进程中作为构建上下文中  执行 docker build 的当前所在目录，称为构建上下文 默认 Dockerfile 文件存放于构建上下文中，但也可通过 -f 指令指定   Command Parser directives  作用  用于指定 Dockerfile 中的转义字符或换行  默认为 \ 重新定义转义字符为 `，主要用于支持 Windows PowerShell脚本，为 c:\\ 情况 编译时不添加至 Docker 层，也不显示作为编译的其中一个步骤 位置应该置于文件顶部，不然当处理完注释、空行或构建指令后, Docker 将不再寻找解析器指令   指令  # directive=value  仅可使用一次 非大小写敏感，允许空格等非断行型空白 无效情况  \(续行符) 重复多次    使用  # escape=[\|`]   ENV  作用  变量定义  定义  ENV variable.name variable.value  使用  ${variable}= $variable ${variable:-default}  = nul!= $variable ? $variable : default  ${variable:&#43;default}  = nul!= $variable ? default : &amp;quot;&amp;quot;    FROM  作用  指定的构建基础，来源可由任意公共存储库的有效镜像  Dockerfile 必须以 FROM 开始   指令  FROM &amp;lt;image&amp;gt;[:&amp;lt;tag&amp;gt;|@&amp;lt;digest&amp;gt;] [AS &amp;lt;name&amp;gt;]  AS &amp;lt;name&amp;gt;  可选项，设置当前引用在新构建阶段的名称  可于后续的 FROM 和 COPY FROM=   :&amp;lt;tag&amp;gt;|@&amp;lt;digest&amp;gt;  可选项，用于指定对应的版本  默认为 lastest 当构建器找不到指定版本时，返回异常      RUN  作用  于 Docker 新层中中执行脚本  RUN 的缓存不会在下一步构建操作中自动失效  RUN apt-get dist-upgrade -y 可于下一步构建中重用 docker build --no-cache 构建中使用 --no-cache 排除 RUN 构建中的缓存影响   执行命令并 创建新镜像层，经常用于 安装软件包  指令  RUN [[&amp;lt;shell&amp;gt;] &amp;lt;command&amp;gt;|[[&amp;lt;shell&amp;gt;,]&amp;quot;&amp;lt;command&amp;gt;&amp;quot;, &amp;quot;&amp;lt;args...&amp;gt;&amp;quot;]]  使用  RUN /bin/bash -c &#39;source $HOME/.bashrc; echo $HOME&#39; RUN [&amp;quot;c:\\windows\\system32\\tasklist.exe&amp;quot;] RUN [&amp;quot;echo&amp;quot;, &amp;quot;$HOME&amp;quot;]  相较下例，不会将 $HOME变量 替换为实际值  RUN [&amp;quot;/bin/bash&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $HOME&amp;quot;]   CMD  作用  执行版本，目的于提供运行容器的默认启动语句或入口点  Dockerfile 仅执行一次 CMD 语句  存在多条指令的情况， 执行最后一条  支持 ENTRYPOINT 情况下，需指定 JSON 数组格式  设置容器启动后，默认执行的命令及参数  可被 docker run 语句后的命令行参数 替换   指令  CMD [[&amp;lt;shell&amp;gt;] &amp;lt;command&amp;gt;|[[&amp;lt;shell&amp;gt;,]&amp;quot;&amp;lt;command&amp;gt;&amp;quot;, &amp;quot;&amp;lt;args...&amp;gt;&amp;quot;]]  使用  CMD [&amp;quot;executable&amp;quot;,&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]  执行模式，推荐  执行不调用命令解析器，导致正常脚本执行无法正常运行  CMD [ &amp;quot;echo&amp;quot;, &amp;quot;$HOME&amp;quot; ] 中 $HOME 将不会被替换 可使用 脚本模式 或 CMD [ &amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $HOME&amp;quot; ] 方式实现    CMD [&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]  ENTRYPOINT 使用情况  CMD command param1 param2  脚本模式 linux 默认使用 /bin/sh -c，windows 默认使用 cmd /S /C    LABEL  作用  为镜像添加标签信息  指令  LABEL ( &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;)&#43;  使用  添加标签 Docker LABEL version=&amp;quot;1.0&amp;quot; LABEL description=&amp;quot;This text illustrates \ that label-values can span multiple lines.&amp;quot;  查看标签  docker inspect &amp;lt;image.name&amp;gt; Docker &amp;quot;Labels&amp;quot;: { &amp;quot;version&amp;quot;: &amp;quot;1.0&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;This text illustrates that label-values can span multiple lines.&amp;quot;, },     MAINTAINER  作用  为镜像添加作者信息  指令  MAINTAINER &amp;lt;name&amp;gt;  使用  建议使用 LABEL 代替  LABEL maintainer=&amp;quot;docker@gmail.com&amp;quot;    EXPOSE  作用  声明 容器服务监听的特定网络 端口  指令  EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;/&amp;lt;protocol&amp;gt;...]  协义支持 TCP 和 UCP  默认为 TCP  仅声明占用端口，实际开放请参考 docker run 的 -p 标签   使用  EXPOSE 80/tcp   ADD  作用  将指定的文件、目录或 远程文件 拷贝至镜像文件系统中的相对位置  指令  ADD [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;  [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] 仅于 Linux 操作系统中有效  将该文件或文件夹指定给指定的用户名、级名或 UID/GID 组合  默认指定给 UID= GID= 0 通过 /etc/passwd 和 /etc/group 将用户名、级名转换为 UID 和 GID   仅能 拷贝构建上下文中 的数据，且针对目录只 拷贝目录内内容 而不包括文件夹本身   使用 Docker ADD hom* /dest/ # 将以 `hom` 开头的文件都拷贝至 `/dest/` ADD --chown=bin files* /dest/ # 将以 `files` 开头的文件均垧上至 `/dest/`，并授权给 `bin:bin` 用户 ADD test dest/ # 将 `test` 文件拷贝至 `WORKDIR`/dest/ ADD test /dest/ # 将 `test` 文件拷贝至 `/dest/ `   COPY  作用  将指定的文件、目录拷贝至镜像文件系统中的相对位置  指令  COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;  与 ADD 基本相同  较之不支持 远程文件 较之支持将可识别的压缩格式（tar/ gzip/ bzip2/ etc）源文件， 自动解压 至指定目录    使用  参照 ADD   ENTRYPOINT  作用  配置容器启动时运行的命令 容器启动需 CMD 和 ENTRYPOINT 中任意一个  指令  ENTRYPOINT [&amp;quot;executable&amp;quot;, &amp;quot;param1&amp;quot;, &amp;quot;param2&amp;quot;]  执行模式 docker run 的参数将于 ENTRYPOINT 后追加，并覆盖元素  ENTRYPOINT command param1 param2  脚本模式 阻止 CMD 和 RUN 中的命令行参数被使用 默认以 /bin/sh -c 形式运行，导致无法正常地接收 docker stop 的信号   使用 | | NULL | ENTRYPOINT entry v1 | ENTRYPOINT [&amp;ldquo;entry&amp;rdquo;, &amp;ldquo;v1&amp;rdquo;] | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-| | NULL | ERROR | /bin/sh -c entry v1 | entry v1 | | CMD [&amp;ldquo;cmd&amp;rdquo;, &amp;ldquo;c1&amp;rdquo;] | cmd c1 | /bin/sh -c entry v1 | entry v1 cmd c1 | | CMD [&amp;ldquo;c1&amp;rdquo;, &amp;ldquo;c2&amp;rdquo;] | c1 c2 | /bin/sh -c entry v1 | entry v1 c1 c2 | | CMD cmd c1 | /bin/sh -c cmd c1 | /bin/sh -c entry v1 | entry v1 /bin/sh -c cmd c1 |  VOLUME  作用  指定挂载的主机目录  指令  VOLUME [&amp;quot;/data&amp;quot;]  Windows 情况下，需指定 C盘外 的 不存在或空 的文件夹 目录数据改变的操作需 于声明之前 无法指定主机上的对应目录，由 系统自动生成   使用  VOLUME [&amp;quot;/var/log&amp;quot;, &amp;quot;/var/db&amp;quot;]  JSON 形式，以「&amp;rdquo;」包围，以「,」分隔  VOLUME /var/log /var/db  Plain String 形式，以「空格」分隔   对比  docker run -v /data:/app docker run --volumes-from &amp;lt;image.id&amp;gt;    USER  作用  用于指定镜像运行或 RUN/ CMD/ ENTRYPOINT 的用户[群组]  指令  USER &amp;lt;user|UID&amp;gt;[:&amp;lt;group|GID&amp;gt;]  当用户未配置组的情况下，默认以 root 群组名义 Windows 环境下，用户需先行创建    WORKDIR  作用  为 RUN/ CMD/ ENTRYPOINT/ COPY/ ADD 等指令指定工作目录  指令  WORKDIR &amp;lt;/path/to/workdir&amp;gt;  多次使用情况下，均以上一命令结果作为 相对目录    ARG  作用  运行时传入参数  构建时以 --build-arg &amp;lt;varname&amp;gt;=&amp;lt;value&amp;gt; 形式传入   指令  ARG &amp;lt;name&amp;gt;[=&amp;lt;default value&amp;gt;]  使用  定义
FROMbusyboxUSER ${user:-some_user}ARG user# ARG.user.defaultValue= some_user, realValue= what_userUSER $user  构建
docker build --build-arg user=what_user .   SHELL  作用  指定默认执行的脚本编译器  指令  SHELL [&amp;quot;powershell&amp;quot;, &amp;quot;-command&amp;quot;] SHELL [&amp;quot;cmd&amp;quot;, &amp;quot;/S&amp;quot;, &amp;quot;/C&amp;quot;]   Dockerignore    规则 行为     #comment 注释   /temp 根目录下任何以 temp 开头的文件或目录都将被排除
例如 /somedir/temporary.txt 文件和 /somedir/temp 文件夹都将被过滤   //temp* 根目录下第三层任意以 temp 开头的文件或目录都将被排除
例如 /somedir/subdir/temporary.txt   temp? 根目录下任意以 temp 开头，相差以一个字符的文件或目录都将被排除
例如 /tempa and 和 /tempb   !README.md 排除例外情况    Example Basic # 以镜像 `ubuntu:15.04` 为基础进行封装FROMubuntu:15.04# 将当前目录文件拷贝至 `Docker` 客户端文件夹中COPY . /app# 执行命令，编译文件RUN make /app# 指定在容器内运行，启动服务CMDpython /app/app.py Basic.Windows # 将转义字符设置为 `，便于在路径描述中正常使用 \ # escape=`FROMmicrosoft/nanoserverCOPY testfile.txt c:\ RUN dir c:\ Variable FROMbusyboxENVfoo /barENVabc=hello # abc= helloENVabc=bye def=$abc # abc= bye; def= helloENVghi=$abc # ghi= helloWORKDIR${foo} # WORKDIR /barADD. $foo # ADD . /barCOPY \$foo /quux # COPY $foo /quux Build.Multiple ARG CODE_VERSION=latest # 唯一可以列于 FROM 之前的结构FROMbase:${CODE_VERSION}CMD/code/run-appFROMextras:${CODE_VERSION}CMD/code/run-extras  Basic.Run WORKDIR/aWORKDIRbWORKDIRcRUN pwd # ./a/b/c/pwd Reference 官方  Dockerfile reference Best practices for writing Dockerfiles .dockerignore file  整理  Docker镜像构建文件Dockerfile及相关命令介绍 Docker入门教程（三）Dockerfile Dockerfile: ADD vs COPY 每天5分钟玩转 OpenStack docker学习笔记18：Dockerfile 指令 VOLUME 介绍  </content>
    </entry>
    
     <entry>
        <title>Linux.Java</title>
        <url>http://domain.yqjdcyy.com/post/linux.java/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Java</tag>
        </tags>
        <content type="html">  参考  Java SE CentOS 7 下安装jdk1.8 Download Oracle Java JRE &amp;amp; JDK using a script  安装  查询  Java SE Downloads 使用 Oracle 账号登录  下载  获取下载链接  jdk-8u171-linux-x64.rpm  F12 获取 Cookie 「gpw_e24」「oraclelicense」 拼链接调用  wget --no-cookies --no-check-certificate --header &amp;quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Fjdk8-downloads-2133151.html;oraclelicense=accept-securebackup-cookie&amp;quot; &amp;quot;http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.rpm&amp;quot;   安装  sudo yum localinstall jdk-8u171-linux-x64.rpm -y  检查  java -version   </content>
    </entry>
    
     <entry>
        <title>Linux.Jenkins</title>
        <url>http://domain.yqjdcyy.com/post/linux.jenkins/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Jenkins</tag>
        </tags>
        <content type="html">  参考  Centos yum install jenkins jenkins实战之jenkins安装部署 Tomcat 部署方式 jenkins.io jenkins.war jenkins集成git，构建项目报错，做了ssh的认证，还是提示 Host key verification failed [WARNING] Failed to create parent directories for tracking file  流程 war  DOWNLOAD  wget http://mirrors.jenkins-ci.org/war/latest/jenkins.war  COPY  cp jenkins.war /data/service/webapps/jenkins/webapps/ROOT.war  CONFIG.JENKINS.TOMCAT  CATALINA_OPTS=&amp;quot;-server -DJENKINS_HOME=/root/.jenkins -Xms528m -Xmx528m -XX:PermSize=256m -XX:MaxPermSize=358m&amp;quot; export CATALINA_OPTS   yum  YUM.CONFIG  wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key  YUM  yum install jenkins  JENKINS.CONFIG  /etc/sysconfig/jenkins  JENKINS_PORT=&amp;quot;8016&amp;quot;   START  service jenkins start  FIREWALL  firewalld  firewall-cmd --permanent --zone=public --add-port=8016/tcp firewall-cmd --reload  aliyun  将 8016 添加至安全策略里   INIT  login  http://39.108.103.85:8016/  input init password  less /var/lib/jenkins/secrets/initialAdminPassword  Install suggested plugins create first admin user start using jenkins  *.CONFIG  http://39.108.103.85:8016/configureTools/  JAVA MAVEN GIT  http://39.108.103.85:8016/pluginManager/available  安装「Maven Integration plugin」插件   CREATE
[General] Project.name=dev-0-umay-core [Code] type= git Reposiotry.Url= https://gitee.com/Jeval/umay.git Credentials= User[name/ password] Branch= */dev [Build] Root.POM= umay-core/pom.xml Goals&amp;amp;Options  user  JENKINS_USER
vim /etc/sysconfig/jenkins JENKINS_USER=&amp;#34;jenkins&amp;#34; -&amp;gt; JENKINS_USER=&amp;#34;appuser&amp;#34; chown -R appuser:appuser /var/lib/jenkins /var/log/jenkins ReStart
 service jenkins restart   异常 Could not read from remote repository.  尝试 SSH 方式无果  ~/.ssh &#43; ssh-keygen /var/lib/jenkins/.ssh &#43; ssh-keygen  转为使用 HTTP &#43; 账号密码  Failed to create parent directories for tracking file  设置 repo 至有权限目录  -Dmaven.repo.local=/var/lib/jenkins/.m2/repo   </content>
    </entry>
    
     <entry>
        <title>Hello.Docker</title>
        <url>http://domain.yqjdcyy.com/post/hello.docker/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Docker</tag>
        </tags>
        <content type="html">  现状  环境配置困难  操作系统 库与组件的安装   简介  Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口  用途  提供一次性的环境 提供弹性的云服务 组建微服务架构  版本  社区版 / Community Edition / CE 企业版 / Enterprise Edition / EE  关键字  镜像  image root 文件系统  提供容器运行时所需的程序、库、资源、配置文件和运行时的相关参数（匿名卷、环境变量与用户等）  分层存储  逐层构建， 上层构建完成后将不再发生变更  某层删除文件，最终容器运行时虽查看不到该文件，但实际文件仍跟随镜像 利于镜像的利用、定制    容器
 实质是 进程，运行于属于自己的独立命名空间  仓库
 集中存储、分发镜像的服务 [/][:]  version  默认为 lastest     对比    服务 原理 启动速度 资源占用 补充     虚拟机 在一种操作系统里面运行另一种操作系统 慢
完整操作系统，系统级别操作步骤无法跳过 占用多
独占一部分内存和硬盘空间    Linux 容器 对进程进行隔离 快 启动进程 占用少
仅占用需要的资源，多个容器可共享资源 Linux Containers 缩写为 LXC    入门 安装 Linux  消除历史版本  yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine  配置 Repository
 安装必要组件  yum install -y yum-utils \ device-mapper-persistent-data \ lvm2  配置 Reposiotry 地址  yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo  禁用或开启相应版本更新  yum-config-manager --[disable|enable] docker-ce-[edge|stable|test]   安装社区版
 安装最新版本
yum install docker-ce Retrieving key from https://download.docker.com/linux/centos/gpg Importing GPG key 0x621E9F35: Userid : &amp;#34;Docker Release (CE rpm) &amp;lt;docker@docker.com&amp;gt;&amp;#34; Fingerprint: 060a 61c5 1b55 8a7f 742b 77aa c52f eb6b 621e 9f35 From : https://download.docker.com/linux/centos/gpg 校验
 确认安装完成后，提示的 Fingerprint 是否与官方提供编码（下行）一致  060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35   查询安装指定版本
yum list docker-ce --showduplicates | sort -r docker-ce.x86_64 `17.06.2.ce`-0.1.rc1.el7.centos docker-ce-test docker-ce.x86_64 `17.06.1.ce`-1.el7.centos docker-ce-test yum install docker-ce-&amp;lt;VERSION STRING&amp;gt; yum install docker-ce-`17.06.2.ce`  启动
 systemctl [start|enable|disable] docker systemctl restart docker.service  HelloWorld
 docker run hello-world ``` Unable to find image &amp;lsquo;hello-world:latest&amp;rsquo; locally latest: Pulling from library/hello-world 9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77 Status: Downloaded newer image for hello-world:latest
Hello from Docker! This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
 The Docker client contacted the Docker daemon. The Docker daemon pulled the &amp;ldquo;hello-world&amp;rdquo; image from the Docker Hub. (amd64) The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.  To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/
For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ ```
  检测运行状况
 ps aux | grep dockerd  Mirror vim /etc/docker/daemon.json  { &amp;quot;registry-mirrors&amp;quot;: [ &amp;quot;https://registry.docker-cn.com&amp;quot; ] }  systemctl daemon-reload service docker restart docker info  Registry Mirrors: https://registry.docker-cn.com/ 
  指令 Repository  types  docker-ce-edge docker-ce-stable docker-ce-test  command  yum-config-manager --[enable|disable] [repository.type]   Docker 示例  docker version  Client: Version: 18.05.0-ce API version: 1.37 Go version: go1.9.5 Git commit: f150324 Built: Wed May 9 22:14:54 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarm  docker image ls
REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest e38bc07ac18e 2 months ago 1.85kB docker container run hello-world ``` Hello from Docker! This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
 The Docker client contacted the Docker daemon. The Docker daemon pulled the &amp;ldquo;hello-world&amp;rdquo; image from the Docker Hub. (amd64) The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.  To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/
For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ ```
 docker container ls --all
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5465dca0bd3a hello-world &amp;#34;/hello&amp;#34; 3 minutes ago Exited (0) 2 minutes ago objective_williams dae54d95f428 hello-world &amp;#34;/hello&amp;#34; 11 minutes ago Exited (0) 11 minutes ago pedantic_fermi 3f17224734de hello-world &amp;#34;/hello&amp;#34; 16 minutes ago Exited (0) 16 minutes ago adoring_johnson  Dockerfile 异常  Error response from daemon: No build stage in current context
 信息  Dockerfile lacks FROM instruction  更正  Dockerfile 中必输包含有 FROM XXX 信息   OCI runtime create failed: container_linux.go:348: starting container process caused &amp;quot;exec: \&amp;quot;/bin/sh\&amp;quot;: stat /bin/sh: no such file or directory&amp;quot;: unknown
 信息  当前配置  FROM scratch  资料  FROM scratch which is an empty filesystem  repository scratch 中无任何信息  In addition, the scratch image has no tooling at all in it, it&#39;s a completely empty filesystem. A tool like mkdir would not exist, and likewise using the shell syntax of RUN mkdir foo would not work because it tries to run this in /bin/sh -c &amp;lt;cmd&amp;gt;, which also does not exist in scratch.  更正  FROM centos  更改信息源自当前操作系统      参考  官方
 Web  Docker  Docs  Get Docker CE for CentOS Install Docker for Windows Post-installation steps for Linux Dockerfile reference  Repository  Docker.Hub OFFICIAL REPOSITORY hello-world kubernetes CentOS.quay Google.CONTAINER REGISTRY 阿里云镜像库 DaoCloud 镜像市场 网易云镜像服务 时速云镜像仓库  Repository.Mirror  阿里云加速器 DaoCloud 加速器  指令  Docker run reference    补充
 Docker 入门教程 Docker 微服务教程 Docker Docker 教程 构建自己的 Docker 映像文件 談談 docker network-alias   异常
 exec: &amp;ldquo;/bin/sh&amp;rdquo;: stat /bin/sh: no such file or directory Is it possible to use a “blank” docker container without any install on it?P   </content>
    </entry>
    
     <entry>
        <title>Hello.Docker.Command</title>
        <url>http://domain.yqjdcyy.com/post/hello.docker.command/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Docker</tag>
        </tags>
        <content type="html">  Docker.* Outline    指令 描述     docker attach 将本地输入、输出和异常流附加到运行状态中的容器   docker build 使用 Dockerfile 构建镜像   docker checkpoint 管理检查点   docker commit 将容器的变更构建为新镜像   docker config 管理 Docker 配置   docker container 管理 Docker 容器   docker cp 进行容器和本地文件系统间的文件/文件夹的拷贝   docker create 创建新容器   docker deploy 发布新堆或更新已存在的堆   docker diff 检查容器的文件系统中，文件或文件夹的变更情况   docker events 获取服务的实时事件   docker exec 在运行的容器中执行指令   docker export 将容器的文件系统打包至 tar 文件   docker history 显示指定镜像的历史   docker image 管理镜像   docker images 列表展示镜像   docker import 由 原始码(tarball) 中引入内容以创建新的文件系统镜像   docker info 展示系统纬度信息   docker inspect 展示 Docker 的低等级信息   docker kill 摧毁容器   docker load 将 tar/STDIN 中加载镜像   docker login 登录   docker logout 登出   docker logs 抓取容器日志   docker manifest 管理镜像的 manifest 列表   docker network 管理网络   docker node 管理集群节点   docker pause 暂停指定容器中的所有进程   docker plugin 管理插件   docker port 列表展示端口映射或指定容器的映射情况   docker ps 展示所有进程   docker pull 拉取注册镜像   docker push 推送镜像注册   docker rename 为容器重命名   docker restart 重启容器   docker rm 移除容器   docker rmi 移除镜像   docker run 在新容器中执行命令行操作   docker save 将镜像通过 STDOUT（默认）打包至 tar文件中   docker search 于 Docker Hub中搜索镜像   docker secret 管理 Docker 密钥   docker service 管理服务   docker stack 管理 Docker 堆   docker start 将关闭的容器重新开启   docker stats 通过容器的实时流进行统计   docker stop 关闭运行中的容器   docker swarm 管理集群   docker system 管理 Docker   docker tag 创建标签以指向源镜像   docker top 展示容器内部运行状态的进程   docker trust 管理镜像的信用记录   docker unpause 取消容器中进程的暂停状态   docker update 更新容器的配置信息   docker version 显示 Docker 的版本信息   docker volume 管理 volumes   docker wait 阻塞至镜像停止，并输出其退出状态    Docker.Run docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]  OPTIONS  运行设置  -d  以分离模式，在后台运行 默认为 -f，在前台运行，并可将其附加至控制台  --rm  指定容器关闭时，自动清除容器，并移除文件系统；一般用于测试的前台运行程序 默认持久化容器，保存所有的用户数据  --name  用于定位容器，可作用于容器名、UUID 短标识和 UUID 长标识  --pid  为容器设置进程命名模式，将容器并入其它容器进程（PID）的命名空间 host  在容器内使用 host的 PID 命名空间   --uts  为容器设置 UTS 命名空间模式 host  在容器内使用 host的 UTS 命名空间   --ipc  为容器设置 IPC 模式 模式类型 | Value | Description | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;| | `| 使用实例的默认配置 | |none| 个人私有的 IPC 命名空间, 在/dev/shm未安装情况 | |private| 个人私有的 IPC 命名空间 | |shareable| 个人私有的 IPC 命名空间, 可与其它容器一起使用 | |container: | 加入其它容器的 IPC 命名空间 | |host` | 使用当前系统的 IPC 命名空间 |  --restart  指定容器的重启策略 策略模式 | 策略 | 结果 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-| | no | 退出时不自动重启；默认配置 | | on-failure[:max-retries] | 仅当退出时异常，并设置相应的重启次数 | | always | 无关退出状态，无限重启 | | unless-stopped | 无关退出状态，重复重启；仅在容器收到停止指令于实例停止前 |
  --log-driver  配置日志驱动 驱动类型 | 驱动 | 描述 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;| | none | 禁用容器日志 | | json-file | JSON 格式文件形式；默认日志驱动 | | syslog | 日志格式输出至 syslog（网络传输日志消息的标准格式） | | journald | 日志输出至 journald（Linux的全新系统日志格式） | | gelf | 日志输出至 Graylog 或Logstash 的 GELF（Graylog Extended Log Format）节点 | | fluentd | 日志以追加形式输出至 Fluentd 软件 | | awslogs | 日志输出至 Amazon CloudWatch Logs |   网络设置  --dns=[] --network-alias=[]  设置网络作用哉别名 便于通过别名找到该容器  --mac-address  不校验 MAC 是否唯一  --ip --ip6 -p &amp;lt;ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort | containerPort&amp;gt;  将容器暴露的端口转到系统的指定端口   配置设置  --memory=&amp;lt;number&amp;gt;[b|k|m|g]  分配内存值；默认最小值为 4M  --memory-swap=&amp;lt;number&amp;gt;[b|k|m|g]  分配 内存&#43; 交换区大小；默认交换区大小同内存  --memory-reservation=&amp;lt;number&amp;gt;[b|k|m|g]  交换内存的 非强制设置，仅确保不会长时间占用值超过该值  --kernel-memory=&amp;lt;number&amp;gt;[b|k|m|g]  分配内核内存大小  -c, --cpu-shares=[0-1]  相对 CPU 比例  --cpus=&amp;lt;number&amp;gt;  分配可用 CPU 个数 number为分数，其中值为 0.000 表示不限制  --cpu-period=0  设置 CPU CFS（Completely Fair Scheduler 完全公平调度） 周期限制  --cpu-quota=0  设置 CPU CFS（Completely Fair Scheduler 完全公平调度） 周期内，最大调度比例 示例  --cpu-quota=200,000  表示最多可使用 200% 的 CPU 资源    --cpuset-cpus=&amp;quot;indexes&amp;quot;  允许使用的 CPU 集合 示例  --cpuset-cpus=&amp;quot;1-3&amp;quot;   --cpuset-mems=”indexes“  允许使用的内存节点集合 针对于 NUMA 框架的 CPU  其它暂略 用户内存限制 | 设置 | 效果 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-| | | memory=inf, memory-swap=inf
默认配置 | | memory=L, memory-swap= -1 | memory=L&amp;lt;inf, memory-swap=inf | | memory=L | memory=L&amp;lt;inf, memory-swap=2*L | | memory=L&amp;lt;, memory-swap=S | memory=L&amp;lt;inf, memory-swap=S&amp;lt;inf, L&amp;lt;=S |   TAG  版本号  ARG  ; echo $?  打印进程结束时的状态码 docker run busybox /bin/sh -c &#39;exit 3&#39;; echo $?  3     Image.* Outline    命令行 描述     docker image build 根据 Dockerfile 来构建镜像   docker image history 显示指定镜像的历史   docker image import 引入 tarball 的内容来创建文件系统镜像   docker image inspect 显示镜像的详细信息   docker image load 由 tar 或 STDIN 来加载镜像   docker image ls 展示镜像列表   docker image prune 移除未使用的镜像   docker image pull 拉取镜像   docker image push 推送镜像   docker image rm 移除镜像   docker image save 将镜像通过 STDOUT（默认）打包至 tar文件中   docker image tag 创建标签以指向源镜像    docker image build [OPTIONS] [PATH | URL | -]  OPTIONS | 名称，缩写 | 默认描述 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;| | &amp;ndash;compress | 使用 gzip 压缩构建内容 | | &amp;ndash;disable-content-trust true | 跳过镜像校验 | | &amp;ndash;file , -f | 指定 Dockerfile 路径；默认为 PATH/Dockerfile | | &amp;ndash;no-cache | 构建时不使用缓存 | | &amp;ndash;quiet , -q | 构建成功时，不打印镜像 ID | | &amp;ndash;rm true | 构建成功后，移除移除中间状态容器 | | &amp;ndash;tag , -t | 以 [:] 形式命名 | | &amp;ndash;target | 设置构建的目标层次 |  Images.* docker images [OPTIONS] [REPOSITORY[:TAG]]  OPTIONS
 Outline | 名称,缩写 | 描述 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;| | &amp;ndash;all , -a | 展示所有镜像
默认隐藏暂停或停止的镜像 | | &amp;ndash;digests | 显示摘要信息 | | &amp;ndash;filter , -f | 根据条件进行输出过滤 | | &amp;ndash;format | 使用 Go 模板进行图像形式打印 | | &amp;ndash;no-trunc | 不进行输出流截取 | | &amp;ndash;quiet , -q | 仅显示数值型 ID |
 --format | 占位符 | 描述 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;| | .ID | 镜像 ID | | .Repository | 镜像仓库 | | .Tag | 镜像标签 | | .Digest | 镜像摘要 | | .CreatedSince | 镜像的创建历史时间 | | .CreatedAt | 镜像的创建时间 | | .Size | 镜像所占硬盘大小 |
   示例  获取未打标签的镜像，并进行删除操作  docker images --filter &amp;quot;dangling=true&amp;quot;  展示所有未打标签的镜像（REPOSITORY:TAG= :）  REPOSITORY TAG IMAGE ID CREATED SIZE &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 8abc22fbb042 4 weeks ago 0 B &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 48e5f45168b9 4 weeks ago 2.489 MB &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; bf747efa0e2f 4 weeks ago 0 B &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 980fe10e5736 12 weeks ago 101.4 MB &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; dea752e4e117 12 weeks ago 101.4 MB &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 511136ea3c5a 8 months ago 0 B   docker rmi $(docker images -f &amp;quot;dangling=true&amp;quot; -q)  8abc22fbb042 48e5f45168b9 bf747efa0e2f 980fe10e5736 dea752e4e117 511136ea3c5a   过滤显示创建于镜像 image1 之前的镜像信息
 docker images --filter &amp;quot;before=image1&amp;quot;  REPOSITORY TAG IMAGE ID CREATED SIZE image1 latest eeae25ada2aa 4 minutes ago 188.3 MB image2 latest dea752e4e117 9 minutes ago 188.3 MB   获取过滤符合 image*:*est 规则的镜像信息
 docker images --filter=reference=&#39;image*:*est&#39;  REPOSITORY TAG IMAGE ID CREATED SIZE image1 latest eeae25ada2aa 4 minutes ago 188.3 MB image2 latest dea752e4e117 9 minutes ago 188.3 MB image3 latest 511136ea3c5a 25 minutes ago 188.3 MB 
  指定格式展示镜像信息
 docker images --format &amp;quot;table {{.ID}}\t{{.Repository}}\t{{.Tag}}&amp;quot;
IMAGE ID REPOSITORY TAG 77af4d6b9913 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; b6fa739cedf5 committ latest 30557a29d5ab docker latest docker image ls
 docker image rm 
 docker image pull [/]
 offical.image.group= library default.group= library  docker image build -t [:] 
  container.*
 docker container ls [&amp;ndash;all] docker container [run|exec|rm|start|stop|kill|logs]   run  新建容器 未找到指定 image 文件时，自动调用 docker image pull 从仓库抓取  exec  进入一个正在运行的容器  rm  终止运行的容器仍会占据硬盘空间   docker container cp :  将正在运行的容器中的文件，拷贝到本机    参考  官方  指令  Docker run reference
   补充
 Docker 运行时资源限制-内存memory、交换机分区Swap、CPU Docker: 限制容器可用的 CPU Docker 资源限制之 CPU NUMA简介 Docker run参考(10) – 资源使用限制 Docker容器对CPU资源隔离的几种方式 Linux服务器管理员Journald初级指南 systemd-journald.service 简介   </content>
    </entry>
    
     <entry>
        <title>跳出码农职业的生命周期</title>
        <url>http://domain.yqjdcyy.com/post/%E8%B7%B3%E5%87%BA%E7%A0%81%E5%86%9C%E8%81%8C%E4%B8%9A%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>职业规划</tag>
        </tags>
        <content type="html">  跳出码农职业的“生命周期” 参考  The one essential skill that will set you apart from other developers - Isabel Nyo   目标  培养像CEO一样思考和行动的能力  只有专业技能在职场中是走不远的   细节 了解公司衡量商业成功的标准  处于不同发展阶段的公司会有不同的标准衡量商业成功与否  初创公司成立早期，成功的衡量指标就是订阅客户数 上市公司的指标则会是它们的股价 有些公司把员工跳槽率看作指标   有效利用数据  用数据支持你的发现和解决方案 示例  CEO 角度  公司不偿还科技债务，它对企业有什么影响  员工角度  通过数据分析，让 CEO 意识到这会影响企业关键服务的可用性和数据点的可移植性，团队就会把清偿科技债务看作重要事项    学会委派工作  交给其他人完成的琐碎任务上，他还能把多余的时间精力投放在公司规划和发展策略研究上 学会适当地“放手”，和同事们多交流，分担工作中的困难，共享经验，你将很快突破工作上的瓶颈  着眼于长远发展  无论对风险的偏好如何，都必须做得比以前更优秀  成为正能量源  尤其在企业面对难关时，充分利用每个人的才干，为工作环境提供积极向上的氛围  </content>
    </entry>
    
     <entry>
        <title>别独自用餐</title>
        <url>http://domain.yqjdcyy.com/post/%E5%88%AB%E7%8B%AC%E8%87%AA%E7%94%A8%E9%A4%90/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>社交</tag>
        </tags>
        <content type="html">  别独自用餐 《别独自用餐》  85%的成功来自高效的社交能力 表面在讲机巧的人脉运用术，实际上说的却是朴实的为人处世之道。  社交的本质  标签
 热衷见名人、见大佬，喜欢在饭局上晒合影、讲内幕。他们常把牛逼的兄弟挂在嘴边，听起来气势十足。
 无意于结交人脉，一心只在埋头奋斗。他们心里想的是，“我不必费心勾搭谁，等我强了，自然会有大把的人脉资源
  思考
 上例标签都偏离了社交的本质。 社交源自交换，互相关心 富人最强大的力量来自他们的社交圈  而穷人，不仅穷在没钱，还穷在没办法接触到那些可以帮助他们成功的人。   示例 &amp;gt; 在俱乐部里，我是波兰特太太的球童。我事无巨细，努力让波兰特太太赢得每一场比赛。每场比赛的当天早上，我都会走遍整座球场，找到每一处果岭，测试球在草地上滚动的速度和方向。她于是战无不胜，也开始在她的朋友面前夸我。 我在球场上帮她，她在生活上帮我
 本质
 首先你要关心他人  多数人在人际交往中都是在关心自己。 关心他人的人，是凤毛麟角。但往往也是这些人，更能成功。    如何关心  示例 &amp;gt;一朋友跟法拉奇聊天，说自己正考虑在洛杉矶买房。
法拉奇听完第一反应就是“我有没有朋友可以帮忙？”，然后顺手就拨通洛杉矶一位中介的电话，当场介绍他俩认识。
 一家小型背包公司产品销不出去，公司的CEO去找法拉奇寻求建议（此前两人并不相熟）。法拉奇本可以提些建议了事，可他却先后找来了锐步公司的营销主管、《快公司》的编辑，一起商量营销策略，最终盘活了公司。十年后，这家小公司被收购时，价值1.1亿美元。
 辩证
 从不吝啬分享自己的人脉。  “不要等着别人请你帮忙。直接帮吧。”  人际交往并不是随机的，而是与人生目标紧密相连。  行动
 计划
 列出你三年后的目标，并拆分成年度目标、季度目标； 列出完成目标所需的人、事物、地点； 找到一个最佳方案，接近那些有助于达成目标的人。  示例  比如三年后，你想当一名老板，那么，也许三个月后，你就要确定从事的领域了。依照这个短期目标， 你就要找到身边的老板、相关行业的从业者，来了解相应情况。    如何结交  机会
 这是一个不缺知识的时代，而知识是社交中最有价值的现金资产。 利用知识提供价值，构建信任  示例 &amp;gt; 马克是公司的普通员工，但他做了件不普通的事——在公司采访了包括创始人在内的重要人物，并把它做成一份新员工的入职培训资料。这样，马克不仅能对新同事产生影响，还在公司所有重要人物面前留下了深刻印象，无形中扩大了自己的人脉圈。 而马克所凭借的社交资产，正是那份人人都能整理出来的资料。
 比如在和人聊天时，你听到他拿自己十几岁的孩子没办法，你就应该从中听出问题。如果你自己给不出什么建议，你就要问问自己：我的朋友能提供哪些帮助呢？谁家也有个十几岁的孩子，而且教子有方？打电话给这个人，问问他们有什么建议，有没有借助过这方面的书籍或文章。然后，把这些东西传播出去。
  </content>
    </entry>
    
     <entry>
        <title>Java.Tools.JHat</title>
        <url>http://domain.yqjdcyy.com/post/java.tools.jhat/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>tools</tag>
        </tags>
        <content type="html">  JHat 作用  打印出进程内存中，所有对象的情况  调用  jhat [ options ] heap-dump-file  示例  jmap -dump:format=b,file=d:/block-jmap.dump 15240 jhat d:/block-jmap.dump  Reading from d:/block-jmap.dump... Dump file created Wed Jun 06 08:34:24 CST 2018 Snapshot read, resolving... Resolving 851039 objects... Chasing references, expect 170 dots......... Eliminating duplicate references............ Snapshot resolved. Started HTTP server on port 7000 Server is ready.   Dump查看界面 OQL执行界面   Reference  官方  jmap
  整理  Java命令学习系列（五）——jhat  OQL  OQL帮助信息 虚拟机学习系列 - 附 - OQL（对象查询语言）   </content>
    </entry>
    
     <entry>
        <title>Java.Tools.Javap</title>
        <url>http://domain.yqjdcyy.com/post/java.tools.javap/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>tools</tag>
        </tags>
        <content type="html">  JAVAP 作用  对 class 文件进行反编译 查看 java 编译器生成的字节码  调用  javap [options] classfile 参数  -help| --help| -?  打印 JAVAP 命令的帮助文档  -version  打印发布版本信息  -l  打印类中变量和方法及其参数列表  -public  仅显示公有类型的类和成员  -protected  仅显示保护或公有类型的类和成员  -private| -p  显示所有的类和成员  -Joption  显示 JVM 相关的特定参数  -s  显示内部类型签名  -sysinfo  显示该类执行时的相关系统信息，如路径、大小、日期和 MD5 签名值  -constants  显示最终的静态常量  -c  为每个方法打印组成的 Java 字节码指令  -verbose  打印堆大小、局部变量的数量、方法的参数    示例  javap CourseVo.class
Compiled from &amp;#34;CourseVo.java&amp;#34; public class com.yunkai.training.portal.course.course.vo.CourseVo { public com.yunkai.training.portal.course.course.vo.CourseVo(); public java.lang.String getOrgName(); public void setOrgName(java.lang.String); } javap -c CourseVo.class
Compiled from &amp;#34;CourseVo.java&amp;#34; public class com.yunkai.training.portal.course.course.vo.CourseVo { public com.yunkai.training.portal.course.course.vo.CourseVo(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V 4: return public java.lang.String getOrgName(); Code: 0: aload_0 1: getfield #23 // Field orgName:Ljava/lang/String; 4: areturn public void setOrgName(java.lang.String); Code: 0: aload_0 1: aload_1 2: putfield #23 // Field orgName:Ljava/lang/String; 5: return } javap CourseController.class
Compiled from &amp;#34;CourseController.java&amp;#34; public class com.yunkai.training.portal.course.course.controller.CourseController { com.yunkai.training.portal.course.course.service.CourseService courseService; public java.util.Map&amp;lt;java.lang.String, java.lang.Object&amp;gt; configLimitation(java.lang.Long, java.lang.Long); } javap -c CourseController.class
Compiled from &amp;#34;CourseController.java&amp;#34; public class com.yunkai.training.portal.course.course.controller.CourseController { com.yunkai.training.portal.course.course.service.CourseService courseService; public java.util.Map&amp;lt;java.lang.String, java.lang.Object&amp;gt; configLimitation(java.lang.Long, java.lang.Long); Code: 0: aload_0 1: getfield #12 // Field courseService:Lcom/yunkai/training/portal/course/course/service/CourseService; 4: aload_1 5: aload_2 6: invokevirtual #45 // Method com/yunkai/training/portal/course/course/service/CourseService.limitation:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/util/Map; 9: areturn } javap -s CourseController.class
public void remove(java.lang.Long, java.lang.Long); descriptor: (Ljava/lang/Long;Ljava/lang/Long;)V javap -sysinfo CourseController.class
Classfile /D:/work/git/yk/java/mgmt_server/code/basic-portal/target/classes/com/yunkai/training/portal/channel/circulation/course/controller/CirculationCourseController.class Last modified 2018-6-5; size 9352 bytes MD5 checksum f41f036052304f6eb835711ccb32e12d Compiled from &amp;#34;CirculationCourseController.java&amp;#34; public class com.yunkai.training.portal.channel.circulation.course.controller.CirculationCourseController { com.yunkai.training.commons.course.course.service.CourseService courseService;  Reference  官方  javap  其它  Java命令学习系列（七）——javap   </content>
    </entry>
    
     <entry>
        <title>降噪耳机</title>
        <url>http://domain.yqjdcyy.com/post/%E9%99%8D%E5%99%AA%E8%80%B3%E6%9C%BA/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>耳机</tag>
        </tags>
        <content type="html">  原理 可识别声音类型  交谈 音乐 可听见声音  降噪即消除此区域声音   衰减  扩散衰减  单位面积上的声波能量随着声源距离的平方而递减  吸收衰减  在固体介质中传播时，部分声能转化为热能  散射衰减  介质颗粒导致衰减   技术 主动降噪  使用 「极低延迟的DNC（Digital Noise Cancelling ）电路」对 「1~3 kHz」噪声实现主动降噪  被动降噪  吸声材料  硅胶耳塞 厚实服帖的耳罩   注意事项 佩戴感  熟悉自己的佩戴形式  入耳式 耳罩式 压耳式  耳压
 飞机起降时的耳朵不适感 长期佩戴主动降噪类型耳机时会出现  续航
 保修
  音质  测试  Eminent Technology&amp;rsquo;s Multimedia Speaker Test   推荐  Bose QC 20
 特点  入耳式 降噪效果最好的耳机  价格  ￥ 1999    Able Planet Sound Clarity
 特点  耳罩式 降噪、音质兼顾 收纳便利 性价比较高  价格  ￥ 1379   Bose QC 35
 特点  耳罩式 消费级旗舰  舒适&#43; 降噪等级高  蓝牙支持  价格  ￥ 1899   Sennheiser PXC550
 特点  耳罩式 支持手势操作 蓝牙 音质优秀  价格  ￥ 1999    补充  Bose A20
 特点  耳罩式 军用级 轻  价格  ￥ 9998   AKG N90Q
 特点  耳罩式  价格  ￥ 11998   Bose QC 25
 特点  耳罩式 次旗舰定位 较 QC35 缺少蓝牙支持，降噪等级更低  价格  ￥ 999   B&amp;amp;O H8
 特点  压耳式 白噪声明显 功能较 Bose 不足，但设计感更强  价格  ￥ 2198   Sennheiser PXC 550
 特点  耳罩式 品质与 QC 35相近，但胜在高音 支持手势操作  价格  ￥ 2499   Samsung Level On Wireless
 特点  压耳式 手势操作 较冷门  价格  ￥ 无   Sony MDR-1000X
 特点  耳罩式 降噪指数较 QC35低，但音质更好  价格  ￥ 2499   MDR-100ABN
 特点  耳罩式 多种配色可选  价格  1499   Audio-technica ATH-ANC7B
 特点  耳罩式 性价比较高  价格  ￥ 698   Bose QC 30
 特点  套脖&#43; 入耳式 相比前代降噪体验有所下降 不推荐  价格  ￥ 1799    Sennheiser CXC700
 特点  入耳式 品质与 QC 20 相近 佩戴舒适性不足  价格  ￥ 1999    MDR EX750NA
 特点  耳罩式 降噪、音质不亚于 QC 20 长期佩戴舒适性不足  价格  ￥ 1018   Bose QC 15
 特点  耳罩式 适合长期佩戴，但音质略有不足  价格  ￥ 2920   Logitech Ultimate Ears
 特点  入耳式 蓝牙 降噪水平较为不足  价格  ￥ 555    参考  有哪些降噪耳机推荐？  </content>
    </entry>
    
     <entry>
        <title>Java开发必须掌握的线上问题排查命令</title>
        <url>http://domain.yqjdcyy.com/post/java%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  [TOC]
Java开发必须掌握的线上问题排查命令 常用命令 JPS  功能  显示进程的 PID  示例  jps jps -v pid  显示指定 PID 对应程序的虚拟机参数  jps -m pid  显示程序启动参数  jps -l pid  显示主类的绝对路径    JSTAT  功能  显示进程中类装载/ 内存/ 垃圾回收及 JIT 编译等数据  示例  jstat -gc [PID] [milliseconds] [times]  查询指定[PID]进程的垃圾回收情况, 每[milliseconds]毫秒一次,共[times]次  jstat -gccause  显示上次 GC 的原因  jstat -calss  显示类装载、类卸载、总空间以及所消耗的时间     JMAP  功能  生成堆栈快照  示例  jmap -heap [PID]  查看 java 堆的使用情况  jmap -histo [PID]  查看堆内存中的对象数量及大小  jmap -histo:live [PID]  JVM会先触发 gc，然后再统计信息  jmap -dump:format=b,file=[file] [PID]  将内存使用的详细情况输出到文件 [file] 中    JHAT  功能  配合 JMAP 使用,分析堆栈文件  示例  jhat heapDump  解析Java堆转储文件,并启动一个 web server    JSTACK  功能  生成当前的线程快照  示例  `jstack [PID]  查看线程情况  `jstack -F [PID]  正常输出不被响应时，使用该指令  `jstack -l [PID]  除堆栈外，显示关于锁的附件信息    问题定位 频繁 GC 或内存溢出  使用 jps 查看线程ID 使用 jstat -gc [PID] [MS] [TIME] 查看gc情况，一般比较关注 PERM区 的情况，查看 GC的 增长情况 使用 jstat -gccause 额外输出上次GC原因 使用 jmap -dump:format=b,file=heapDump [PID] 以*生成堆转储文件** 使用 jhat 或者可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）分析堆情况 结合代码解决内存溢出或泄露问题  死锁  使用jps查看线程ID 使用jstack [PID] 以查看线程情况  </content>
    </entry>
    
     <entry>
        <title>学车</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B1%BD%E8%BD%A6.%E5%AD%A6%E8%BD%A6/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>汽车</tag>
        </tags>
        <content type="html">  参考条件  身高 180 练习时教练传授的相关口诀和体会、尝试，仅供参考  报名  2018.1.19  驾校报名，交付一半的订金  2018.1.20  由驾校工作人员载着去进行体检   科目一 挂学时 刷题目 考试  自行前往车管所 到时先行录指纹 等叫到号时进入 完成考试后领取成绩单  科目二 注意事项  注意调整座椅、后视镜等  后视镜上沿可见后侧门把手 车身占后视镜 1&amp;frasl;4 左右   启动三保险  离合踩满 刹车踩满 挂空档  打满= 90度= 打三把  一把= 单手半圈   流程  注意事项  考试过程中，身体任意部位不能伸出车窗 考试不及格，需从专门车道返回重考 有一次重考机会 场地     入场  穿反光马甲 识别身份证，按指纹  启动  调整座位、后视镜 绑定安全带，挂空档，踩刹车、离合，启动 拉手刹、挂一档、打左车向灯前进  侧方停车  出库时打左转向灯 不及格  入库停止后，车身出线  扣10分  行驶中轮胎压线   定点与半坡起步  前保险框停于实线处 起步前手刹拉起三秒，打左转向灯 起步熄火时，立马踩刹车重新启动 不及格  前保险框停于虚线外 后溜超过30公分 未于30s内启动  扣10分  前保险框位于虚线内实线外 后溜30公分   直角转弯  不及格  行驶中车轮压线 中途停车   曲线  不及格  行驶中车轮压线 中途停车   倒车入库  不及格  不按规定路线、顺序行驶 车身出线 中途停车 时长超过4min    实际体验  申请  第一次预约  286&amp;frasl;300 提前几天通知预约失败 与教练确认是由于预约顺序与科目一考试的时间有关 提前几天，短信通知到预约失败  第二次预约  顺利   集合  6:55 训练场集合  入场  7:30 到达考场，后直接刷身份证进去  排队  安排的9:30的场 分排「8:00-9:30」与「9:30-12:00」的场    8点的场进去后便可进入  刷身份证&#43; 脱眼镜拍照   考试  进考场  坐在大厅等待提示 提示自己「6」号车后，对照了解需进第三号考场    去了一下洗手间，手机静音  考试  紧张等待「6」号车返回 听大妈讲刚考过，紧张到脚抖至走不动的故事 上车，检查座椅、左右后视镜  左右后视镜无法再调整，幸好还有辅助镜子  使用身份证签到，对摄像头拍照 重新启动出发  安全员搭话，忘记启动打左转向，囧  侧方 半坡  位置停不准  直角 S弯 倒库  80分及格   难点 倒车入库 左倒车  前进至车身挡住对面车道线，方向盘向左打满 直视前方，快对直时拉直（右打满） 继续前进至左侧远端黄线与手肘对齐 踩满离合、刹车后，挂倒档 倒至左侧后视镜杆挡住远端黄线时左转打满（左打三把） 观察左侧后视镜中，车身离左侧库角70厘米左右，回（右）1.3把  库口左侧辅助线远端角  继续观察左侧后视镜，至车身轨迹与入库角离30厘米左右  原：至左侧库角被下沿挡住时打（左）满  倒车至车身与库边平行时拉直（右打三把） 然后等到库角线刚出左侧后视镜杆后即可停下  右倒车  前六步与左侧倒车相近 于右侧后视镜下边框挡住右侧库角之时，向右打满 观察左侧后视镜，待底库角与车身距离20厘米左右时，将车身回正  不至车身平直是为了给调整方向盘时间  然后等到库角线刚出左侧后视杆后即可停下  侧方停车  坐直情况下，右眼延着左侧雨刮远端柄头对着侧边线右侧，前进并调整方向盘至稳定  调整对齐方式，侧边线距中间车标30公分左右  部分车子无此雨刮点   开至车身挡住最前方辅助线情况下刹车、挂倒档 倒至左侧车大灯处露出辅助线情况下，向右打满 观察左侧后视镜，当看到内侧底库角时拉直（左打三把） 等左侧后轮将至线处，向左打满  适当调整，保障后续车轮过线即可 左轮压线情况下，车身进入太多  观察车身左上角与库左侧线平直时刹车，完成入库 打左转向灯，挂一档前进至车身左上角遮挡道路左侧辅助线时，拉直（向右打三把） 行进至车标遮挡辅助线，向右打两把 最后待车身即将恢复时，拉直（向左打两把）即可  直角  与侧方停车一致，保持车身与右侧道路的距离 打左侧转向灯 观察左侧后视镜直线上车身处，待拐角左侧线一过，左转打满  后面使用直角延长线对齐车窗角处   定点&#43; 半坡起步  稳定松离合，保证低速上坡，同时确认左侧雨刮远端柄头对着侧边线右侧  同样确认右侧边线距离车标30厘米左右  前进至左侧后视镜杆遮挡半坡处的实线（三线中间一条）时，踩刹车、离合 拉起手刹3秒后放下，打左侧转向灯，松离合至车身抖动后，同时提起刹车和离合 完成上坡后，关闭转向灯 并于开始下坡时，深踩离合，轻踩刹车控制前进速度  S弯  入库时，右侧边线距车标50厘米左右 待左侧车头往内40厘米处遮挡右侧线时，向左打两把 行进中向左调整，保障右侧边线不过车头往内20厘米处 至车头左侧离左侧边线20厘米左右时，向右打两把回正 至车标触及左侧边线时，向右打两把 行进中向右调整，保障左侧线不过车头往右40公分 即将出弯时，回正不压线即可  科目三 流程  厦门后溪一号线  考试开始  上车，调整座椅、后视镜等  务必不要系上安全带 可以在不松离合的情况下，尝试一下换档 因为有后档，此时可以提前松掉手刹  人脸验证 播报“请开始考试”  开门下车，逆时针绕圈，分别按动车身右后方及左前方的红色感应器 确保听到语音播报“左前方/右后方有学员通过”后才可上车   灯光模拟  耐心等待播报完成，思考后再行操作  未等播报完毕就完成操作，系统可能会识别失败  完成停车等操作后，在进入下一灯光操作前，需先清除之前灯光操作的影响 完成灯光模拟后，关闭所有灯光  起步  松手刹 挂空档 打左转向灯三秒 踩离合、刹车、挂一档，左右观察中起步  加减档位操作  在进入加减档位区域前 提前换好二档  需先加油门，将车速稳定在 15-20km/h 后换档  车速过低时，可踩油门，避免熄火  一档换二档时，转速不得超过二千转  耐心等待指示后，进行相关档位的操作  现在二档不提示 提示“开始加减档位操作”时，加速至 30km/h 后换至三档 然后在提示声中完成下一档位的操作  如提示“三档”，实际是执行换四档操作  需要在25秒内完成  完成操作后，可换一档以保证后续操作的稳定  路口右转  播报提醒“前方路口右转” 车身摆正 打右转向灯三秒 左右摆头观察 右转 结束操作后，灯未熄灭时需及时关闭  超车  播报“超越前方车辆” 车身摆正 打左转向灯三秒 左转后回直  直线行驶  优先走右侧车道 车身摆正 观察远方参照物，提前量微调  掉头  播报提醒“前方请选择合适路口调头” 打左转向灯三秒 左右摆头观察 左转  变更车道  播报提醒“变更车道” 打转向灯三秒 左右摆头观察 变更车道  半把去半把回   减速让行  无语音播报提醒，需提前预判 离减速区域30米内有效 点刹| 刹车至有较明显减速  刹车过轻，系统可能识别不到   会车  刹车减速 左右摆头观察  靠边停车  车身回正，调整车身离线三十公分左右  1号线靠边停车前有一处弯道 车头出线也不及格  打右转向灯三秒 踩离合、刹车停车 换空档、拉手刹 等待提示考试及格后再放离合、油门  路线     实际体验 出发  7:00 软件园集合  沿途接其它学员  7:50 到达后溪  备考  刷身份证入场（大门）  和同期同学遇到两台机器都刷不了的情况  提供参考短信 让教练出示一下今天考生列表 由保安代刷入场   在科目三考场外排队等待考试开始 刷身份证进入备考区  此次顺利进入  排队使用照相设备确认本人，然后进入备考区等待叫号   可等到自己的名字到了「上车考试」列后再行出去  遇到前面学员开特别久的情况 顺便可以再整理一下流程    考试  不需要身份证，直接沿路边走到对应号码的车旁 等待安全员的指导  验证方式为人脸识别 有其它人员通过摄像头监考，所以考试期间不允许说话  按流程进行考试  囧，一开始起步时因为有点紧张，松离合太快熄火了一次 不过也可能因此觉得大不了就挂这回，第二回注意，反而按部就班地完全了后续的项目   总结  和同学一起回来，她不小挂了
 第一次  起步时，左转灯刚打，不小心打到方向盘  建议先打左转灯，左右观察三秒后，再挂一档起步   第二次  加减档位操作时，超过25秒  进入区域前可等待一下，保证前方学员不会影响自己操作    备考时，观察其它学员挂掉的情况
 路边停车时，一听到提示声音就准备停，压线或离线太远  听到语音提示时，还在小弯处，吃线不准，可行至直线处再打灯停车 考试车无车标，无平时参照物，但可使用车灯、雨刮器或车头处号码牌对照  离合不熟悉，松太快导致频繁熄火 一档时油门不熟悉，踩太急，转速超两千转 紧张踩下刹车导致熄火  建议待考时，可以先去一下卫生间
 建议即将考试时，可吃一下口香糖、巧克力等
 考试时，回忆当前项目的各个点，提前准备
 前方有学员影响自己操作，可踩刹车、离合，换成一档
 待前方学员完成后，松离合进半联动后，松刹车启动，继续完成项目  不可靠消息
 越早通过率越低  待考时，听其它教练说之前的学员通过率仅三分之一 如果不急，可以适当考虑晚一点考试 当然觉得不可靠，毕竟操作人员只有开车的人    科目四 出发  11:40  确保携带身份证 推荐携带文件带  12:10  在软件园东二门集合 拿到历史各体检单、成绩单等  各成绩单补充签名   13:00  原定12:30，但由于部分学员太慢，等待 所幸于14:00 前到考场即可  13:30  到达考场   考试  刷身份证进入 将身份证投入备考人员身份证收集口  等待叫到名字  进入考场  手机关机 排队等待分配机器  考试  第一次考试88分 第二次考试  交身份证上缴给考官，等待第二轮考试 重新分配机器 考试通过  领取培训单  提交考卷 领取右侧打印机打印出的成绩单   安全培训  携带所有材料至安全培训场所 上缴所有材料 签名 领取签到时间卡、笔和快递单、意见反馈卡  按桌子上的红字提示，进行必输信息填写  半小时安全培训完成后，提交材料即可   证书到手  2018.6.4  收到快递，岛内十块钱搞定   参考 科目二  厦门后溪科目二考场注意事项 科目二考试流程技巧详解 科目二直角转弯满分通过的4个技巧，切记勿要失分  科目三  图文详解后溪科目三考场两条线路，这些会车点一定要当心！ 科目三过路口、调头…明明动作对了还是挂科？原因找到了！ 考科目三不注意这六点，平时练得再好也没用！ 科目三雷区20项，避开这些，通过率高达99% 学员速看！厦门驾考预约方式有重大变化，科目三考试规则也有变！ 带11名学员考科目三，10人通过！厦门教练总结通关要点，太有收获了 油门这样踩，科目三一把过！金牌教练的秘诀全公开 驾考科目三-2016新交规科目三大路考试技巧  驾校  3月全市驾校通过率排名来了！  </content>
    </entry>
    
     <entry>
        <title>Spring.Security</title>
        <url>http://domain.yqjdcyy.com/post/spring.security/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Spring</tag><tag>Security</tag>
        </tags>
        <content type="html">  前后端分离 思路  登录成功后，于 Session 添加相应属性值 接口请求时，判断过滤接口和 Session 属性值是否过期、有效，以判断是否拦截  选型  Spring.Security  展示型项目，简单区分前后端即可  Vue&#43; Bootstrap  代码 引用 &amp;lt;parent&amp;gt; &amp;lt;version&amp;gt;1.3.8.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-core&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 登录  Controller
@RequestMapping(value = &amp;#34;/login&amp;#34;, method = RequestMethod.POST) public void login(@RequestBody UserVo userVo, HttpServletRequest request) { securityService.login(userVo.getName(), userVo.getPwd(), request); } Service
public void login(String username, String password, HttpServletRequest request) { User user = userService.findByName(username); if (null == user || StringUtils.isEmpty(user.getPwd()) || !passwordEncoder.matches(password, user.getPwd())) throw new IllegalStateException(&amp;#34;用户名|密码 错误&amp;#34;); logger.info(&amp;#34;User[{}] login.success&amp;#34;, username); HttpSession session = request.getSession(); // TODO 优化为 JWT 等其它可验证的方式 session.setAttribute(AuthConfig.authSessionKey, user.getId()); }  鉴权  Application
@SpringBootApplication(exclude = {SecurityAutoConfiguration.class}) @EnableTransactionManagement(proxyTargetClass = true) @EnableJpaRepositories(basePackages = &amp;#34;com.yao&amp;#34;) @ComponentScan(basePackages = &amp;#34;com.yao&amp;#34;) @EnableAsync public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) { return args -&amp;gt; { System.out.println(&amp;#34;Let&amp;#39;s inspect the beans provided by Spring Boot:&amp;#34;); String[] beanNames = ctx.getBeanDefinitionNames(); Arrays.sort(beanNames); for (String beanName : beanNames) { System.out.println(beanName); } }; } } Config
@Configuration public class WebAppConfig extends WebMvcConfigurerAdapter { @Autowired AuthenticationInterceptor authenticationInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry // 添加拦截器 .addInterceptor(authenticationInterceptor) .addPathPatterns(&amp;#34;/**&amp;#34;) // 添加不需要校验的路径 .excludePathPatterns(&amp;#34;/resource/**&amp;#34;, &amp;#34;/order&amp;#34;, &amp;#34;/user/**&amp;#34;); } } Interceptor
@Component public class AuthenticationInterceptor extends HandlerInterceptorAdapter { final Logger logger = LoggerFactory.getLogger(AuthenticationInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { HttpSession session = request.getSession(); Long authUserId = (Long) session.getAttribute(AuthConfig.authSessionKey); // TODO 补充权限校验、用户 Session 校验等 if (null != authUserId) { request.setAttribute(AuthConfig.authSessionKey, authUserId); return true; } else { logger.warn(&amp;#34;UNAUTHORIZED session:{}&amp;#34;, session.getId()); response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &amp;#34;UNAUTHORIZED&amp;#34;); return false; } } }  其它方案 Spring.Security  2.0.2.RELEASE  实践  着重参考「Reference.Example」中的「Registration and Login Example with Spring Boot, Spring Security, Spring Data JPA, and HSQL」  尝试未果  权限配置未果  使用 RESTFul 方式 打算针对 /{interface} 放开，而限制 /{interface}/{method} 进行权限校验 配置如下  http.authorizeRequests() .antMatchers(&amp;quot;/resources/**&amp;quot;, &amp;quot;/car&amp;quot;, &amp;quot;/casus&amp;quot;, &amp;quot;/msg&amp;quot;, &amp;quot;/news&amp;quot;, &amp;quot;/order&amp;quot;, &amp;quot;/share&amp;quot;, &amp;quot;/user&amp;quot;, &amp;quot;/user/login&amp;quot;).permitAll() .anyRequest().authenticated()  如若有知道配置哪边写错的，烦请留言告知     Apache.Shiro  阶段功能已满足，未尝试  Reference Office  Spring.Security  Spring Security Reference Java Configuration spring-projects/spring-security  Apache.Shiro  Apache.Shiro   Example  Registration and Login Example with Spring Boot, Spring Security, Spring Data JPA, and HSQL 前后端分离之Springboot后端 从 MVC 到前后端分离 Shiro安全框架入门篇 跟我学 Shiro  Other  Spring Security (三) 核心配置解读 关于Boot应用中集成Spring Security你必须了解的那些事 JWT  </content>
    </entry>
    
     <entry>
        <title>FFmpeg.2Gif.Ass</title>
        <url>http://domain.yqjdcyy.com/post/ffmpeg.2gif.ass/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>FFmpeg</tag>
        </tags>
        <content type="html">  [TOC]
字幕文件 安装 aegisub  aegisub.官网  打开视频  注意选择合适大小  编辑  /视频/打开视频 试听 &amp;amp; 添加行记录 &amp;amp; 更新时间点、字幕内容和样式     指令 模板  ffmpeg -i {video_path} -r 8 -vf ass={ass_path},scale=300:-1 -y {gif_path}  示例  cd path ffmpeg -i ‪template.mp4 -r 8 -vf ass=‪template.ass,scale=300:-1 -y template.gif  代码参考  sorry.python - render.py  Reference Project  East196/sorrypy xtyxtyx/sorry  Software  aegisub 【教程】手把手教你用aegisub写字幕（基础向）  </content>
    </entry>
    
     <entry>
        <title>Spring.Boot.Publish</title>
        <url>http://domain.yqjdcyy.com/post/spring-boot-run-on-tomcat/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Spring</tag>
        </tags>
        <content type="html">  Init  project.init business.finish  Package packaging.war  pom.xml  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;   tomcat.remove  pom.xml  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 移除嵌入式tomcat插件 --&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt;   servlet-api.add  pom.xml  javax.servlet-api  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  OR tomcat-servlet-api  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;tomcat-servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.36&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;    runner.update  与 Application 同级  public class SpringBootStartApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(Application.class); } }   pack  mvn clean package  Publish conf.update  update Connector.port  aliyun.update  更新安全组端口  webapp.upload tomcat.run Notice  spring.boot 项目的发布改造  可正常运行，但服务未正常启动  tomcat 对外端口为 /conf/server.xml 中 Connector.port 服务器防火墙放开 Connector.port  centos 新版本中默认使用 Firewalld  阿里云实例安全组中，需放开 Connector.port  Reference Spring Boot  spring-projects/spring-boot Building an Application with Spring Boot  Package  spring boot项目打包成war并在tomcat上运行的步骤 把spring-boot项目部署到tomcat容器中  Firewalld  Linux.Firewalld  </content>
    </entry>
    
     <entry>
        <title>我们的孩子</title>
        <url>http://domain.yqjdcyy.com/post/%E6%88%91%E4%BB%AC%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>思考</tag>
        </tags>
        <content type="html">  阅读 《我们的孩子》  哈佛大学教授罗伯特·帕特南通过大量的采访和数据例证，生动展现了美国的教育现状，以及美国社会半个世纪来日益拉大的阶级鸿沟。  参考  如果说中美存在几十年的发展时间差，那么帕特南笔下的美国现状，有可能就是我们和我们的孩子即将面对的明天。  思考  在一个发展成熟的社会里，真的寒门难再出贵子吗？ 未来我们的孩子，将要面临怎样的阶层状况？ 如果真的有所谓的阶层固化，我们现在该怎么教育孩子？留给我们的时间还有多少？  寒门难出贵子 经济制约  教育花费  美国宿舍一个月税前1400刀（dollar） 宿舍自助餐早餐11刀 午餐15刀 晚餐18刀 最便宜的二手课本要80刀 贵的是200以上 每年学费6万刀，折合超过40万人民币  美国人平均年薪  5万  极为有限的经济水平制约着个人的发展，而更为可怕的是，穷人之所以难以通过教育改命，还在于他们身上背负的无形负担。  阶级隔离  示例
 美国  学校距离不远，政府投入相当，学生经费差不多，师资水平也难分上下 A校的美国高考SAT成绩常年位于全国前列，B校却常年垫底  中国  北京五道口学区房单价破10万元 有些家长希望孩子“快乐就好”的同时，清华附小的学生已开始试着用大数据研究苏轼 甚至中产内部都出现了教育鄙视链：绝不让娃和没英文名、看喜羊羊的孩子做朋友 不允许学费五万的幼儿园招收学费三万的学生   原因
 学校档次不同，源于家长的阶层不同  阶级隔离
 恶性循环  收入的不平等造成  居住隔离（住不一样的社区） 教育隔离（上不一样的学校）， 交友和婚姻上（只在本阶层内交友、寻找伴侣）  孩子出生后就在和父辈一样的环境中成长 上同样层次的学校    教育再也不是穷人改变命运的阶梯，而成了富人维护现有秩序的工具   出路 参考  富人爸爸厄尔
 房地产商人 工作再忙，都会陪孩子一起吃晚餐，听孩子说话，孩子参加体育比赛，他会挤出时间去加油助阵。 而且在很早以前，厄尔就和妻子约定，不在孩子面前吵架。他也做到了。 有一段时间，厄尔的小女儿露西因为不堪学校的高压，成绩一落千丈。  了解到露西对骑马感兴趣，厄尔就立马在自家农场增设了一个谷仓，然后给露西买了一匹马。 接着，又把露西到了安排到另一所中学。 露西很喜欢那里，成绩很快回升。   对比
 富人  在抚养下一代时，富人们事无巨细，不计时间和金钱，无微不至地关心。  穷人  倾向于对孩子自然放养，没有培养计划、缺少成长干预，任由孩子发展。 孩子的天赋得不到培养，错误得不到纠正，成才要靠运气    自身  努力发展自己，提高收入，成为一个更好的人，在能力范围内，给下一代更多的关注和更好的教育  Reference  你的孩子，未来20年将面临怎样的阶层分化？  </content>
    </entry>
    
     <entry>
        <title>Java.ImportStatic</title>
        <url>http://domain.yqjdcyy.com/post/java.importstatic/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  DESCRIBE 发布  JDK 1.5 新特性
对比 import
 从包中引入类，允许不添加类前缀的方式进行调用  imports classes from packages, allowing them to be used without package qualification   static import
 声明从类中引入静态成员，以允许它们在该类中直接使用，而不需要添加类前缀  declaration imports static members from classes, allowing them to be used without class qualification.    使用  import class.[*|method]  示例 Origin double r = Math.cos(Math.PI * theta); Static Import import static java.lang.Math.*; double r = cos(PI * theta); 时机 态度  保守地使用 仅当需频繁的访问一两个类中的静态成员  缺点  增加可读复杂度 增加维护成本  REFERENCE 官方  Static Import  对比  import static和import的区别 java中import static和import的区别  </content>
    </entry>
    
     <entry>
        <title>Spring.JPA.Fetch</title>
        <url>http://domain.yqjdcyy.com/post/spring.jpa.fetch/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Spring</tag><tag>JPA</tag>
        </tags>
        <content type="html">  Setting Default     Type Setting     JPA 2.0 spec      OneToMany Lazy    ManyToMany Lazy    OneToOne Eager    ManyToOne Eager   Hibernate      * Lazy    Docs Hibernate  By default, Hibernate uses lazy select fetching for collections and lazy proxy fetching for single-valued associations. These defaults make sense for most associations in the majority of applications.
 Jpa Spec  JPA Spec assumes that in general most of the applications will require the singleton relations by default be eager, whereas multi value relations by default be lazy.
 Reference Docs  21.1.1. Working with lazy associations  Other  Why is the JPA FetchType EAGER by default for the @ManyToOne relationship? hibrenate @ManyToOne(fetch = FetchType.EAGER) 和 lazy 区别  </content>
    </entry>
    
     <entry>
        <title>信用报告</title>
        <url>http://domain.yqjdcyy.com/post/%E4%BF%A1%E7%94%A8%E6%8A%A5%E5%91%8A/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>信用报告</tag>
        </tags>
        <content type="html">  信用报告 作用  个人信用报告影响到贷款和出行（乘坐飞机、动车和签证等）  法院判决  若未如期履行生效判决内容，将可能被列入失信黑名单，被限制出境、高消费等。    机构  征信中心  职属  中国人民银行旗下 目前唯一有资格发布信用报告的征信机构  我国暂未对其他机构发放个人征信牌照   时间点  2004年初步建立个人征信系统 2008 年于上海挂牌成立  负责  汇收集企业和个人的信息——主要以银行信贷信息 为相关机构和个人出具信用报告    明细  资产处置信息 保证人代偿信息 信用卡 住房贷款 其他贷款 为他人担保信息 欠税记录 民事判决记录 强制执行记录 行政处罚记录 电信欠费信息  有效时长  根据人行的规定，信报上只显示最近 5 年的记录  查询 渠道  参见「参考」中的「渠道」模块  流程  线上
 先到「个人信用中心」注册账号 登录 查询申请  24小时后，通过手机短信通知 「查询码」仍可用于下次查询  查看  于信用报告中输入「查询码」   线下
 前往有关部门  部门  中国人民银行分支行征信管理部门 征信中心  局面查询申请  中国人民银行  信用卡所在银行查不到情况下    携带身份证等相关证件 填写个人信用报告查询表 备注  速度  15分钟左右才能拿到信用报告  收费  每年前两次免费，第三次起 25元/次     影响因素  频繁查询
 个人或银行等机构的查询也会记录在信报上，频繁查询可能会影响后续信用卡和贷款的审批  网上贷款
 定性  经营性贷款  影响信报  每当点开「微粒贷」时，于人行信报中多一条 查询记录 当向「微粒贷」贷款时，该借款会以 个人消费贷款 名义占据一条信报  类型  微信  微粒贷  阿里  蚂蚁借呗 阿里网商银行  网商贷   苏宁  任性付    银行开卡
 部分银行 未激活的信用卡也会在信报上有所体现  持有信用卡 过多可能会对申请某些银行的信用卡造成负面影响 对于不需要的卡片，也请尽早销卡   信用卡还款逾期
 很多银行通常会给予 1-3 天的宽限期 可能不上报情况  过了最后还款日才还款 欠款金额很小  注意  工行  逾期一天也上信报  具体情况还请咨询银行    事件 恶意拖欠贷款  媒体报道了近年来在一些县城里，消费者热衷于使用分期服务购买高档手机，有些人在付完首付拿到手机后，转手倒卖，此后恶意拖欠贷款的现象。 对于恶意拖欠款项的个人，不仅是在高额消费中会受到限制，甚至无法乘坐高铁、飞机，还会影响到签证的办理。
 在德国“闯红灯”会有什么后果  德国一哥们儿深夜闯红灯被罚后，发现生活各种不顺：保险费比别人多付1%、购房贷款要提前还款等。  新规  南京和深圳市都明确规定了地铁逃票三次以上的行为可录入个人信用系统 杭州、宁波等城市已将个人和企业在电费缴纳方面的失信行为纳入银行信用平台 铁道部在今年年初也出台了相关规定，有逃票、吸烟、冒用优惠证件等行为的乘客将列入铁道部的旅客信用记录管理系统  参考 官网  征信中心 个人信用中心 信用报告全攻略  渠道  全国法院被执行人信息查询 中国裁判文书网 中国执行信息公开网 国家企业信用信息公示系统 启信宝  其它  十年后出不了国，买不了房，坐不了飞机，只因为现在你忽略了这个 如何查询个人信用记录？  </content>
    </entry>
    
     <entry>
        <title>Spring.@Transactional</title>
        <url>http://domain.yqjdcyy.com/post/spring.transactional/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Spring</tag>
        </tags>
        <content type="html">  使用方式  将 @Transactional 注解添加至 方法 上 将 @Transactional 注解添加至 类 上  该类中所有 public 类型方法均会被配置以相同的事务属性 方法级别的事务属性 覆盖 类级别的事务属性   属性 属性列表    属性名 是否必输 默认值 说明     name Yes  关联指定名称的事务管理器 可用通配符(*)来匹配多个事务管理器，如 get*, on*Event   propagation No REQUIRED 事务传播行为   isolation No DEFAULT 事务隔离等级   timeout No -1 事务超时时长，单位为秒  如果超过该时长限制而事务未完成，则自动回滚   read-only No false 事务是否只读   rollback-for No  指定能触发事务回滚的异常类型使用逗号(,)分隔，如 com.foo.MyBusinessException,ServletException   no-rollback-for No  仅抛出指定的异常，而不回滚异常写法同rollback-for    明细 PROPAGATION    事务传播行为 说明     Propagation.REQUIRED 外部存在事务情况下，加入，否则自行创建默认配置虽然事务逻辑范围内，可独立决定回滚状态，但由于同属相同的物理事务，内容回滚标志会影响到外部事务的提交当内部回滚，而外部不希望受影响，则外部事务需处理 UnexpectedRollbackException 异常   Propagation.NOT_SUPPORTED 容器不为这个方法开启事务   Propagation.REQUIRES_NEW 不管是否存在事务，都创建一个新的事务内外事务完全独立，拥有独立的物理事务，允许独立地提交或回滚   Propagation.MANDATORY 必须在一个已有的事务中执行，否则抛出异常   Propagation.NEVER 必须在一个没有的事务中执行，否则抛出异常   Propagation.SUPPORTS 依赖于调用方的事务，有则加入，没有则不带事务   Propagation.NESTED 允许使用单一物理事务，但包含有多个保存点以回滚 仅适合于 JDBC 3.0 驱动程序，即 JDBC DataSourceTransactionManager    ROLLBACK-FOR  默认检测到抛出 RuntimeException 异常或 Error 时，回滚事务 指定异常子类，当检测到该类异常抛出时，事务进行回滚  示例  @Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)    ISOLATION    事务隔离级别 说明     Isolation.READ_UNCOMMITTED 读取未提交数据基本不可用脏读和 不可重复读   Isolation.READ_COMMITTED 读取已提交数据默认配置不可重复读和 幻读   Isolation.REPEATABLE_READ 可重复读幻读   Isolation.SERIALIZABLE 串行化     补充  脏读  一个事务读取到另一事务未提交的更新数据  不可重复读  在同一事务中，多次读取同一数据返回的结果有所不同  后续读取可以读到另一事务已提交的更新数据   可重复读  在同一事务中多次读取数据时，能够保证所读数据一样 后续读取不能读到另一事务已提交的更新数据  幻读  一个事务读到另一个事务已提交的insert数据    原理 机制  生成  使用 AOP 代码，在代码运行时生成代理对象  拦截  代理对象根据 @Transactional 的属性来决定是否由 TransactionInterceptor 拦截  创建事务 执行目标方法逻辑 判断执行过程是否出现异常  提交事务 回滚事务      代理类  CglibAopProxy.intercept() JdkDynamicAopProxy.invoke()  事务管理框架  PlatformTransactionManager  AbstractPlatformTransactionManager  DataSourceTransactionManager     注意事项 @Transactional 注解仅过 public 方法有效  TransactionInterceptor拦截前，代理类间接调用 AbstractFallbackTransactionAttributeSource.computeTransactionAttribute 校验  protected TransactionAttribute computeTransactionAttribute(Method method, Class&amp;lt;?&amp;gt; targetClass) { // Don&#39;t allow no-public methods as required. if (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) { return null; } ... }   AOP 代理下，目标方法 由外部调用时才有效  AOP代理下，目标方法由外部调用时，才能被 Spring 生成的代理对象列入管理  同类无事务注解方法，调用有注解方法，后者事务被忽略 示例  @Service public class OrderService { private void insert() { insertOrder(); } @Transactional public void insertOrder() { // logic.* } }    可用 AspectJ 代替以解决以上两种不兼容 参考  官方  Transaction Management 16.5.7 Transaction propagation  补充  Spring @Transactional工作原理 透彻的掌握 Spring 中@transactional 的使用 Spring @Transactional原理及使用   </content>
    </entry>
    
     <entry>
        <title>如何聊天</title>
        <url>http://domain.yqjdcyy.com/post/%E5%A6%82%E4%BD%95%E8%81%8A%E5%A4%A9/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>社交</tag>
        </tags>
        <content type="html">  整理 常见错误 连续提问  心态  猎人发现了猎物马上就收集猎捕信息 试图用提问来逃避无话可说  缺点  连续提问是在透支社交的耐心和礼貌  方式  在每次对方回答了你的问题之后，你都给予一定的响应 对方主动开启倾诉模式，可以通过连续提问让对方尽情表达   不说自己  心态
 猎人总是习惯把自己隐蔽起来  方式
 回答时多用状态&#43;感受 对方对你的回答进一步表现出兴趣，你就可以顺势把话题变成关于你个人经历的一段小故事，这样你们的彼此了解以及相互关系就可以趁机推进。   情感过度  表现
 过于细致琐碎的状态表达  忘了别人也许对这些根本不感兴趣  过分强烈的感受表达  对一个刚刚认识的女孩说“今天满脑子想的都是你”，但他意识不到女孩可能会因此觉得尴尬   心态
 追求表达的极致效果，恨不得每句话都一语惊人直捣芳心。 对真诚的错误理解，认为真诚就是把自己做的和想的毫无保留地告诉对方。  所谓真诚的原则为“不说假话”即可，至于真话说多少应该随着交往循序渐进  自恋  方式
 主动说自己的状态  先只“下切一级”，然后根据对方的反应再决定是否下切到二级或者三级  用 比你觉得安全的程度再轻一些去表达   随意评价  重要性
 四大常见错误里最严重的一项，可惜很多人都意识不到  表现
 对别人的情绪、意愿、能力、性格、角色进行不由分说的主观判定  产生的原因往往是当事者为了说出有趣的话题，自己先去**设定前提**，然后再想象伸延去表达一个意义 前提常常与事实不符，并且还是指向对方的，这就给别人自以为是的感觉。   方式
 用客观事实淡化主观意愿  比如调查青少年自慰行为  直接问被试“你平时自慰吗？”，回答yes的人会很少 改成“很多人有自慰习惯，你呢？”，回答yes的人就明显多了。   确保自己能够说对 确保对方愿意让你说对   推荐  能够很好的把握对话的节奏，善于倾听。  能够知道什么时候让我说，什么时候他说  通过索取、给予、索取、再给予的过程，不断加深人与人之间的联系。  主动替对方着想，可能怎么样的链接或者信息可能对于对方有用，主动提供给对方。  很多时候女性的聊天是做为一种释放压力的方式，而不是一定在寻求一个问题的解答。 互相袒露隐私，会让对方有一种亲密的错觉 在聊天过程中，多给予具体的肯定  参考  如何变得会聊天？  </content>
    </entry>
    
     <entry>
        <title>复刻亿万中那一幕让人垂涎欲滴的饭局</title>
        <url>http://domain.yqjdcyy.com/post/%E5%A4%8D%E5%88%BB%E4%BA%BF%E4%B8%87%E4%B8%AD%E9%82%A3%E4%B8%80%E5%B9%95%E8%AE%A9%E4%BA%BA%E5%9E%82%E6%B6%8E%E6%AC%B2%E6%BB%B4%E7%9A%84%E9%A5%AD%E5%B1%80/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>酒</tag>
        </tags>
        <content type="html">  复刻美剧《亿万》中那一幕让人垂涎欲滴的饭局 剧情  《亿万》 SE03-06
 三个大老爷们的饭局，却是坐在黑暗的房间里，点着蜡烛，还要把脑袋蒙住，就为了吞吃一只小小鸟儿  蒙头仪式
 食客头顶餐巾 食用时放下蒙面，不用餐具而整只下口 除了不让人看见不雅的进食方式之外，更能笼住香气，甚至制造一种独食的小天地，放大感官享受   介绍  雅文邑浸圃鹀（pǔ wú）  评价  独特之处首先在于其肥厚油脂的香气 经过催肥而活生生在雅文邑中浸泡而死的圃鹀，肉质细嫩肥美之余，带有雅文邑特有的醇香；不取内脏、一口吞的吃法更能完整保有肉汁的香浓口感。 肥油、内脏、血骨和嫩肉在口腔中的热滚冲击。那种古早时期的香气，带有无花果、雅文邑和野味交织的醇香甜美，而我的口腔挤碎鸟骨而微微出血，混合了一丝丝咸腥的口感，逼近高潮。  Anthony Bourdin.&amp;lt;&amp;gt;   作法  需要在阻挡光线的暗笼中饲养圃鹀21天，阻止叫声 并喂食以白粟米催肥至原有三倍的体积 最终活着投入雅文邑中，浸泡至死并吸取香气 去毛轻烤，整只食用  补充  圃鹀又称嵩雀（ortolan） 圃鹀与催肥填鸭并称为法兰西美食酷刑的代表 因为制法残忍和物种濒危，1999年法国明令禁止捕猎圃鹀    引申  雅文邑（Armagnac）  描述  雅文邑本身就是法国最古老的白兰地 最早关于雅文邑这种白兰地的拉丁语文献，记载于1310年，供教宗和主教们享用。 雅文邑的产区比波尔多和干邑更南，温润的气候，葡萄种类的选择，以及更加古朴的蒸馏（采取柱式蒸馏器仅蒸馏1次）和陈年方式（干邑只有3档，而雅文邑有6档）的独特性，使雅文邑的口感与干邑相比起来更加甜润，甘香，酒精度也相对更低。  产量  450万瓶/年  补充  产量 干邑 1.8亿瓶/年 苏格兰威士忌 15亿瓶/年     推荐 口碑最高的达豪思酒庄（DARROZE）  评价
 仅生产拿破仑级别（至少6年）及以上的雅文邑带有浓郁的李子干，柑橘和香草风味 是全法国所有米其林三星餐厅的首选白兰地  40年陈酿
 Les Grands Assemblages 系列 风味可用“宏伟”形容，及其馥郁繁杂的香气中贯穿着强劲有力的熟酿风味（Rancio），会让任何一位白兰地爱好者拜服。   30年陈酿
 是酒庄 Les Grand Assemblages系列 酒体醇熟，口味更加柔软温和，香料气息浓郁，熟酿风味中带有一些皮革的气息。   2000年
 经过了15年桶陈，是未经勾兑，而让酒精自然蒸发降低到饮用度数的“雅文邑原酒”  雅文邑产区对单一年份的法律要求比较严苛，必须在橡木桶中陈酿10年以上 在风味，单宁和酒精度上达到了令人愉悦的平衡。    酒渣白兰地（Grappa）
 酒渣白兰地是意大利北部的一种传统蒸馏酒 这款Marolo采用内比奥罗的葡萄渣，是你在意大利能够找到的最好的酒渣白兰地    </content>
    </entry>
    
     <entry>
        <title>Twitter.Lists</title>
        <url>http://domain.yqjdcyy.com/post/twitter.lists/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Twitter</tag>
        </tags>
        <content type="html">  Info  看到同事使用非 Twitter 网站在看 Twitter,且分类查看方便异常 询问了解是 Twitter 的 Lists 功能  Use Work  构建不同类型消息流,而不需要关注用户  关注用户于着重关注(显示于消息流中)/ 进行交流    Tools  windows  TweetDeck Twhirl hootsuite  IPhone  Twitter  Android  Twidroid   Reference  How to use Twitter Lists 有效组织：如何创建并使用 Twitter 列表 如何使用Twitter hootsuite  </content>
    </entry>
    
     <entry>
        <title>艾美</title>
        <url>http://domain.yqjdcyy.com/post/%E8%89%BE%E7%BE%8E/</url>
        <categories>
          <category>艺术</category>
        </categories>
        <tags>
          <tag>手表</tag>
        </tags>
        <content type="html">  品牌 简介  始于1961年，位于苏黎世的Desco Von Schulthess AG公司收购了侏罗省Saignelégier镇内一间钟表零件厂，生产独家品牌供应国内和海外市场。 1975年，第一枚以 “Maurice Lacroix”命名的艾美表于奥地利面世，从此奠定日后成功的基业 在瑞士的生产厂房包括了表壳制造工场和装配工场，尤其是表壳制造工场，为艾美表提供了整套的生产程序，从最原始阶段的表壳设计到最终的打磨工序，都由艾美表厂自行管理和控制。  系列 匠心  高端价位 体现巅峰技术、设计之作 以 Cinq Aiguilles 为蓝本 大窗口飞返年历表,获得 2003年度钟表评选大赛的 全年最佳腕表 大奖 机芯有部分自产的，全镂通，五针同轴，方形齿轮  奔涛  低端价位 以三针为主  典雅  低端价位 兼备经典钟表优点  评价  品牌档次高于浪琴，略低于欧米茄 价位位于1-6万之间  明细 匠心 MP7158-SS001 基本信息  由 Masterpiece Square Wheel 推出惊世骇俗的无表盘腕表  价格  ¥ 92500  机芯  ML 156 机械机芯，手动上链  外观  表壳  不锈钢表壳,43毫米,经缎面磨砂和抛光处理 双面防眩弧形蓝宝石水晶表镜 宽面蓝宝石水晶旋入式底盖 防水深度 50米/5atm  指针
 镍制方轮用于秒钟显示,白漆表盘秒钟显示覆有白色荧光层(蓝光),黑色表盘秒钟显示覆有黑色荧光层(蓝光) 隐藏旋转轴 镀铑时针、分针和动力储存指针  表带/表链
 黑色或棕色鳄鱼真皮表带   功能  动力储存  45小时   补充  中置指针显示小时和分钟 6时位置设方轮显示小秒钟 3时位置设动力储存指针 振频  18000振/时,2.5赫兹  宝石轴承数  34  调校  上满链后和24小时后5方位调校  装饰  大蜗形纹图案(Grand Colimaçon),镀铑处理   欣赏         典雅 LC6063-PS101-110-1 基本信息  外观沉稳中显露锋芒，传承百年传统制表技艺。纤薄表壳、简约表盘，突显这些腕表的内敛优雅气质，彰显佩戴者之品味。 采用最高水准传统工艺装饰的日内瓦波纹摆陀、圆形粒纹表桥以及镀金或镀铑自动陀，均赏心悦目。  价格  ¥ 11000  机芯  ML 155/132自动上链机芯  外观  表壳  不锈钢材质，直径 28毫米 经抛光处理 弧形蓝宝石水晶内层防眩表镜 透明底盖 防水深度达 30米（3atm）  指针  钻石切割、琢面镀铑时针、分针和秒针  表带  黑色或棕色纯正鳄鱼皮表带，黑色小牛皮衬里  表扣  经典不锈钢表扣 | 18 K玫瑰金经典表扣   功能  中置指针指示小时、分钟和秒钟 6时位置设日期显示视窗  补充  振频  28,800次/小时，4赫兹  动力储存  38小时  宝石  25/20颗  调校  上满链及满24小时后可进行3方调校  装饰  镀铑机芯，圆形粒纹，蜗形饰纹，日内瓦波纹，镀金自动陀   欣赏       奔涛 PT6358-SS001-430-1 价格  ¥ 16000  机芯  自动机械  外观  表壳  不锈钢，直径40毫米，经磨砂和抛光表面处理 防水深度达50米（5atm）  表盘  蓝宝石水晶玻璃，双面防眩涂层弧形蓝宝石水晶表镜  表带  鳄鱼皮，小牛皮衬里和黑色缝线  表扣  不锈钢   功能  日期显示 星期显示  补充  振频  28,800次/小时，4赫兹  动力储存  38小时  宝石  26颗  调校  上满链及满24小时后可进行3方调校  装饰  镀铑指针   欣赏      欣赏 匠心                典雅          奔涛               参考  官网  官网  匠心  匠心系列 匠心系列方轮經典腕表_和復刻腕表 艾美匠心系列MP7158-SS001-900腕表  典雅
 典雅系列 LC6063-PS101-110-1  奔涛  奔濤系列 PT6358-SS001-430-1  其它  艾美手表怎么样？   </content>
    </entry>
    
     <entry>
        <title>Go.GOPATH</title>
        <url>http://domain.yqjdcyy.com/post/go.gopath/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  作用  于 go/build 中引入，罗列本机 Go 代码的位置，可用于解析导入语句
 Unix  使用 : 分割  Windows  使用 ; 分割  Plan
 使用列表记录
默认   未设置时，默认为用户主目录下的 go 文件夹
 Unix  $HOME/go  Windows  %USERPROFILE%\go    补充  设置可参考 Reference.SettingGOPATH 可使用 go env GOPATH 查看当前配置 新 包 被 下载 时，将 默认 下载至 列表目录中的首项 目录地址中  目录结构 要求  配置的目录，需包含规定的结构  类型  src 目录拥有 源代码，而 src 下目录决定了引用路径和可执行文件名 pkg 目录拥有已安装的 包对象  在 Go 的树型结构中，各目标 操作系统和体系 架构均有对应的 pkg 子目录  bin 目录拥有已编译的 命令  DIR/src/foo/quux 将被安装至 DIR/bin/quux 而当 GOBIN 被设置时，会 指定生成至其配置目录中  GOBIN 必须为一个 绝对目录   internal 目录及其下级代码，仅可被 internal 的父目录下各目录代码引用 vendor  Go 1.6&#43; support 使用外部依赖的 本地拷贝，以安全地引入 仅可被 vendor 的父目录下各目录代码引用，同 internal，但引用时自动忽略 /vendor 前缀  /src/foo/vendor/baz/z.go  /src/foo/bar/x.go  import baz  /src/crash//bang/b.go  cannot import      示例 basic GOPATH=/home/user/go /home/user/go/ src/ foo/ bar/ (go code in package bar) x.go quux/ (go code in package main) y.go // import foo/bar  bin/ quux (installed command) pkg/ linux_amd64/ foo/ bar.a (installed package object) internal import foo/internal/baz/z.go noly work for foo/* /home/user/go/ src/ crash/ bang/ b.go // **NO** foo/ f.go // YES bar/ x.go // YES internal/ baz/ z.go quux/ y.go // YES Reference  Go.Help.GOPATH.log SettingGOPATH How to Write Go Code Go 1.4 “Internal” Packages Go 1.5 Vendor Experiment  </content>
    </entry>
    
     <entry>
        <title>Hello.RPC</title>
        <url>http://domain.yqjdcyy.com/post/hello.rpc/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>RPC</tag>
        </tags>
        <content type="html">  概念 RPC 定义  远程过程调用  「请求」「应答」服务器，部署在「请求」服务器上的应用，想要调用「应答」服务器上应用提供的函数方法 由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据   框架前缀 要点  通讯
 主要是通过在客户端和服务器之间建立TCP连接，传输远程调用所有交换的数据  按需连接，调用结束后就断掉 长连接，多个远程过程调用共享同一个连接   寻址
 「请求」服务器上的应用告诉底层的RPC框架，连接到「应答」服务器的 IP、端口、方式和相关的方法  基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找 RMI调用的话，还需要一个RMI Registry来注册服务的地址   序列化
 网络协议是基于二进制，内存中的参数的值要序列化成二进制的形式  反序列化
 对参数进行反序列化，恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用以得到返回值。  处理
 将反馈数据根据业务进行处理   图解    协议  CORBA  Common Object Request Broker Architecture 通用对象请求代理架构标准  Java RMI  Remote Method Invocation 远程方法调用  Web Service  服务导向架构  Thrift  接口描述语言和二进制通讯协议，用来定义和创建跨语言的服务 远程过程调用框架  Rest API  Representational State Transfer 表现层状态转化  Representational  表现层即资源  State Transfer  GET| POST| PUT| DELETE   网站即软件   Netty 定义  Netty 是提供一种事件驱动的，责任链式（也可以说是流水线）的网络协议实现方式  组成  网络协议  传输层协议 编码解码 压缩解压 身份认证 加密解密 请求的处理逻辑  责任链
 Upstream  从传输层，经过一系列步骤，如身份认证，解密，日志，流控，最后到达业务层  DownStream
 业务层返回后，又经过一系列步骤，如加密等，又回到传输层
图解     构架 选型 考量  GRPC  支持服务治理 主要的精力放在服务发现、路由、容错处理等方面 主要围绕一个语言开发  DUBBO  框架特性 性能 成熟度 技术支持 社区活跃度   对比     Dubbo Montan rpcx gRPC Thrift     开发语言 Java Java Go 跨语言 跨语言   分布式(服务治理) √ √ √ × ×   多序列化框架支持 √ √ √ × ×   多种注册中心 √ √ √ × ×   管理中心 √ √ √ × ×   跨编程语言 × × × √ √    压测     gRPC Dubbo rpcx thrift go stdrpc     0ms 3rd140,000 last-3st65,00 1st200,000 70,000 1st295,000   10ms 4th140,000 last-3st65,00 2nd200,000download 70,000 1st295,000   30ms 4th140,000 last-3st65,00download 2nd 200,000download 70,000 1st295,000    补充  0ms      10ms      30ms       GRPC 特点  主要面向移动应用开发并基于 HTTP/2协议标准而设计，基于 ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言  为了跨语言，服务端可以用不同的语言实现，客户端也可以用不同的语言实现，不同的语言实现的客户端和服务器端可以互相调用。 基于同一个IDL（Interface description language），可以生成不同语言的代码，并且语言的支持也非常的多。   thirft 特点  跨语言的 高性能的服务框架 广泛的应用  dubbo 特点  Java 高性能优秀的服务框架 可以和 Spring框架 无缝集成  Motan 特点  新浪微博开源的一个 Java框架 起于2013年，2016年5月开源  性能  100,000,000,000&#43; 次/ 100&#43;服务/ 天  RPCX 特点  Go语言生态圈的 Dubbo 比Dubbo更 轻量，实现了Dubbo的许多特性，借助于Go语言优秀的并发特性和简洁语法  Reference  RPC
 谁能用通俗的语言解释一下什么是 RPC 框架？ 远程过程调用协议 你应该知道的RPC原理  GRPC
 官网 API 文件就是你的伺服器，REST 的另一個選擇：gRPC Go Quick Start  Netty
 The Netty Project API Reference (3.2.6.Final)  Apache.AB
 官方  Apache AB Apache HTTP 服务器 2.4 文档  其它  超实用压力测试工具－ab工具 开源性能测试工具 - Apache ab 介绍   Other
 RPC 框架  流行的rpc框架benchmark-2018.1 分布式RPC框架性能大比拼-2016.9 JAVA中几种常用的RPC框架介绍  补充  性能测试应该怎么做？ Why Averages Suck and Percentiles are Great Dubbo-性能测试报告 - 404 dubbo-api性能测试报告 性能测试报告    </content>
    </entry>
    
     <entry>
        <title>Hello.性能测试</title>
        <url>http://domain.yqjdcyy.com/post/hello.%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>测试</tag><tag>性能</tag>
        </tags>
        <content type="html">  Mistake  用的全是 平均 值 响应时间 没有和**吞吐量 TPS/QPS 挂钩 响应时间和吞吐量 没有和 成功率 挂钩  调整 Averages not work 噪点影响平均值  统计数据  [1ms,1ms,1ms,1ms,1ms,1ms,1ms,1ms,1ms,1s]  平均值  100ms  实际作法  去除噪点后计算平均值 或将数据排序后，取中间数据的平均值   百分比分页  统计数据  [10ms, 1s, 200ms, 100ms]  报告
 TP= Top Percentile = 当前数值的最高可能性 TP50&amp;lt;= 100ms TP90&amp;lt;= 1s
推荐格式  99.9%的请求必须小于 1ms，所有的平均时间必须小于1ms
  Latency &amp;amp; Thoughput 关联  随着并发量（吞吐量）的上升，系统愈发不稳定，响应时间延长   推荐格式  TP99小于100ms的时候，系统可以承载的最大并发数是1000qps  #Thoughput &amp;amp; Success.Rate  性能测试，建立于请求的成功  Recomend Point  吞吐量  Thoughput  响应时间  Latency  资源利用  CPU/MEM/IO/Bandwidth  成功率 系统稳定性  Report  定义一个系统的响应时间 latency  建议是TP99，以及成功率  在这个响应时间的限制下，找到 最高 的 吞吐量 在这个吞吐量做 Soak Test  使用第二步测试得到的吞吐量连续7天的不间断的压测系统  找到系统的 极限值  在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。  做 Burst Test  用第二步得到的吞吐量执行5分钟 然后在第四步得到的极限值执行1分钟 再回到第二步的吞吐量执行5钟 再到第四步的权限值执行1分钟 如此往复个一段时间，比如2天。  低吞吐量 和 网络小包 的测试  Reference  性能测试应该怎么做？ Why Averages Suck and Percentiles are Great  </content>
    </entry>
    
     <entry>
        <title>Java.Tools.JMap</title>
        <url>http://domain.yqjdcyy.com/post/java.tools.jmap/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>tools</tag>
        </tags>
        <content type="html">  JMAP 作用  为进程、核心文件或远程调试服务器打印共享对象内存映射或堆内存细节 Java 1.8 版本中不支持   调用  jmap [option] &amp;lt;pid&amp;gt;|&amp;lt;executable &amp;lt;core&amp;gt;&amp;gt; | &amp;lt;[server_id@]&amp;lt;remoteServerIP | hostname&amp;gt;&amp;gt; 参数  &amp;lt;no option&amp;gt;  如果使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称  -dump:[live,]format=b,file=&amp;lt;filename&amp;gt;  以 hprof 二进制格式转储 Java 堆到指定文件中。live子选项是可选的 live子选项决定堆中只有活动的对象会被转储 可用 jhat 浏览 heap dump  -finalizerinfo  打印等待终结的对象信息  -heap  打印一个堆的摘要信息，包括使用的GC算法、堆配置信息和generation wise heap usage  -histo[:live]  打印堆的柱状图。其中包括每个Java类、对象数量、内存大小(单位：字节)- 、完全限定的类名 打印的虚拟机内部的类名称将会带有一个’*’前缀。如果指定了live子选项，则只计算活动的对象  -permstat  Java 1.8 版本中不支持 打印Java堆内存的永久保存区域的类加载器的智能统计信息 对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印  包含的字符串数量和大小   -F  强制模式。如果指定的pid没有响应，请使用jmap -dump或jmap -histo选项。此模式下，不支持live子选项  -h|help  打印帮助信息  -J&amp;lt;flag&amp;gt;  指定传递给运行jmap的JVM的参数    示例  jmap 24748 | 内存地址 | 内存占用 | 进程、核心文件或远程调试服务器 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;| | 0x0000000051560000 | 8740K | D:\server\Java\jdk1.8.0_65\jre\bin\server\jvm.dll | | 0x0000000054130000 | 104K | D:\server\java\jdk1.8.0_65\jre\bin\net.dll | jmap -histo 24748 | 序号 | 实例数 | 所在字节数 | 类名 | |&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;| | num | #instances | #bytes | class name | | 14: | 6778 | 108448 | java.lang.Object | | 1565: | 1 | 16 | sun.util.resources.LocaleData$LocaleDataResourceBundleControl | | Total | 266178 | 50804480 | | jmap -finalizerinfo 24748  Attaching to process ID 24748, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.65-b01 Number of objects pending for finalization: 0  jmap -dump:format=b,file=d:/24748-jmap.dump 24748  Dumping heap to D:\24748-jmap.dump ... Heap dump file created  jmap -heap 24748
Attaching to process ID 24748, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.65-b01 using thread-local object allocation. Parallel GC with 8 thread(s) // GC 方式 Heap Configuration: MinHeapFreeRatio = 0 // JVM堆最小空闲比例，默认`40`，可通过 `-XX:MinHeapFreeRatio` 设置 MaxHeapFreeRatio = 100 // JVM堆最大空闲比例，默认`70`，可通过 `-XX:MaxHeapFreeRatio` 设置 MaxHeapSize = 734003200 (700.0MB) // JVM堆的最大大小，可通过 `-XX:MaxHeapSize` 设置 NewSize = 89128960 (85.0MB) // JVM堆的 `新生代` 的默认大小，可通过 `-XX:NewSize` 设置 MaxNewSize = 244318208 (233.0MB) // JVM堆的 `新生代` 的最大大小，可通过 `-XX:MaxNewSize=` 设置 OldSize = 179306496 (171.0MB) // JVM堆的 `老生代` 的大小，可通过 `-XX:OldSize` 设置 NewRatio = 2 // `新生代` 和 `老生代` 的大小比例，可通过 `-XX:NewRatio` 设置 SurvivorRatio = 8 // 年轻代中 `Eden` 与 `Survivor` 的大小比例，可通过 `-XX:SurvivorRatio` 设置 MetaspaceSize = 21807104 (20.796875MB) // JVM堆的 `元数据` 的大小，默认为`20.8M`，可通过 `-XX:MetaspaceSize` 设置 CompressedClassSpaceSize = 1073741824 (1024.0MB) // JVM堆的 `Klass Metaspace` 的大小，默认为`1G`，可通过 `-XX:CompressedClassSpaceSize` 设置 MaxMetaspaceSize = 17592186044415 MB // JVM堆的 `元数据` 的最大大小，默认为`无穷大`，可通过 `-XX:MaxMetaspaceSize` 设置 G1HeapRegionSize = 0 (0.0MB) // 设置 `Garbage First` 平分java堆产生的区域的大小，默认为`2的幂`，范围为 `1M至 32M`，可通过 `-XX:G1HeapRegionSize` 设置 Heap Usage: // 堆内存使用情况 PS Young Generation Eden Space: // Eden 区内存分布 capacity = 67108864 (64.0MB) used = 44377568 (42.321746826171875MB) free = 22731296 (21.678253173828125MB) 66.12772941589355% used From Space: // Survivor 0 区内存分布 capacity = 11010048 (10.5MB) used = 6410528 (6.113555908203125MB) free = 4599520 (4.386444091796875MB) 58.224341982886905% used To Space: // Survivor 1 区内存分布 capacity = 11010048 (10.5MB) used = 0 (0.0MB) free = 11010048 (10.5MB) 0.0% used PS Old Generation // 老生代内存分布 capacity = 179306496 (171.0MB) used = 16384 (0.015625MB) free = 179290112 (170.984375MB) 0.009137426900584795% used 5576 interned Strings occupying 475000 bytes.  Reference  官方  jmap
 2.14 The jmap Utility  整理  Java命令学习系列（三）——Jmap  补充  MetaspaceSize的坑 JVM源码分析之Metaspace解密 G1(Garbage First)的使用 垃圾优先型垃圾回收器调优 垃圾优先垃圾回收器(G1 GC)使用笔记   </content>
    </entry>
    
     <entry>
        <title>Java.Tools.Profiler</title>
        <url>http://domain.yqjdcyy.com/post/java.tools.profiler/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>tools</tag>
        </tags>
        <content type="html">  监控 目的  通过收集程序运行时的信息来研究程序行为的动态分析方法。其目的在于定位程序需要被优化的部分，从而提高程序的运行速度或是内存使用效率  方式  事件方法  对于 Java，可以采用 JVMTI（JVM Tools Interface）API 来捕捉诸如方法调用、类载入、类卸载、进入/离开线程等事件，然后基于这些事件进行程序行为的分析。  统计抽样方法（sampling）  该方法每隔一段时间调用系统中断，然后收集当前的调用栈（call stack）信息，记录调用栈中出现的函数及这些函数的调用结构,基于这些信息得到函数的调用关系图及每个函数的 CPU 使用信息。 由于调用栈的信息是每隔一段时间来获取的，因此不是非常精确的，但由于该方法对目标程序的干涉比较少，目标程序的运行速度几乎不受影响。  植入附加指令方法（BCI）  该方法在目标程序中插入指令代码，这些指令代码将记录 profiling 所需的信息，包括运行时间、计数器的值等，从而给出一个较为精确的内存使用情况、函数调用关系及函数的 CPU 使用信息。 该方法对程序执行速度会有一定的影响，因此给出的程序执行时间有可能不准确。但是该方法在统计程序的运行轨迹方面有一定的优势。   常用功能  遥测（Telemetry）  遥测是一种用来查看应用程序运行行为的最简单的方法。 通常会有多个视图（View）分别实时地显示 CPU 使用情况、内存使用情况、线程状态以及其他一些有用的信息，以便用户能很快地发现问题的关键所在 CPU Telemetry 视图一般用于显示整个应用程序的 CPU 使用情况，有些工具还能显示应用程序中每个线程的 CPU 使用情况 Memory Telemetry 视图一般用于显示堆内存和非堆内存的分配和使用情况 Garbage Collection Telemetry 视图显示了 JVM 中垃圾收集器的详细信息 Threads Telemetry 视图一般用于显示当前运行线程的个数、守护进程的个数等信息 Classes Telemetry 视图一般用于显示已经载入和还没有载入的类的数量  快照（snapshot）  应用程序启动后，profiler 工具开始收集各种执行数据，其中一些数据直接显示在遥测视图中，而另外大部分数据被保存在内部，直到用户要求获取快照，基于这些保存的数据的统计信息才被 显示出来。 快照包含了应用程序在一段时间内的执行信息  CPU 快照  主要包含了应用程序中函数的调用关系及运行时间。  内存快照  主要包含了内存的分配和使用情况、载入的所有类、存在的对象信息及对象间的引用关系。    CPU Profiling  CPU Profiling 的主要目的是统计函数的调用情况及执行时间，或者更简单的情况就是统计应用程序的 CPU 使用情况。 方式  CPU 遥测 CPU 快照   内存 Profiling  主要通过统计内存使用情况检测可能存在的内存泄露问题及确定优化内存使用的方向。 方式  内存遥测 内存快照   线程 Profiling  线程 Profiling 主要用于在多线程应用程序中确定内存的问题所在  某个线程的状态变化情况 死锁情况 某个线程在线程生命期内状态的分布情况    工具 Java.* JPS  作用  显示当前用户本地 JAVA 进程及进程号  机制  java 程序启动后，会在 java.io.tmpdir 指定临时目录下，生成名称类似于 hsperfdata_User 的文件夹，其中个别文件的名字就是 java 进程的 pid 示例  appuser 用户 ll /tmp/hsperfdata_appuser/  total 928 -rw------- 1 appuser appuser 32768 May 2 22:17 11337 -rw------- 1 appuser appuser 32768 May 2 22:17 11489    调用  jps [-q] [-mlvV] [&amp;lt;hostid&amp;gt;] 参数  -q  仅显示 pid 值  -m  显示调用时 main 函数收到的启动参数  -l  显示启动类的进程 ID 和完整路径名  -v  显示调用 JVM 时的相关参数     JINFO  作用  输出进程、Core 文件或远程 Debug 服务器配置信息  Java 系统参数 命令行参数  运行于64位虚拟机上时，需指定 -J-d64 Java 1.8 版本中不支持  机制 调用  jinfo [option] &amp;lt;pid&amp;gt; 参数  -flag &amp;lt;name&amp;gt;
 to print the value of the named VM flag  -flag [&#43;|-]&amp;lt;name&amp;gt;
 to enable or disable the named VM flag  -flag &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;  to set the named VM flag to the given value  -flags
 to print VM flags   示例  jinfo pid  Caused by: sun.jvm.hotspot.runtime.VMVersionMismatchException: Supported versions are 24.60-b09. Target VM is 25.25-b02     JSTAT  作用  监视vm内存内的各种堆和非堆的大小及其内存使用量，并可观察classloader，compiler，gc相关信息  机制    调用  jstat -&amp;lt;option&amp;gt; [-t] [-h&amp;lt;lines&amp;gt;] &amp;lt;vmid&amp;gt; [&amp;lt;interval&amp;gt; [&amp;lt;count&amp;gt;]] 参数  option  选项  –class  监视类装载、卸载数量、总空间及类装载所耗费时间  –gc  监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量
  –gccapacity  监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最小空间  –gcutil  监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比
  –gccause  与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因  –gcnew  监视新生代GC的状况
  –gcnewcapacity  监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间
  –gcold  监视老年代GC的状况
  –gcoldcapacity  监视内容与—gcold基本相同，输出主要关注使用到的最大和最小空间
  –gcpermcapacity  输出永久代使用到的最大和最小空间
  –compiler  输出JIT编译器编译过的方法、耗时等信息  –printcompilation  输出已经被JIT编译的方法
    vmid  VM 进程号，即当前运行 java 进程号  VMID= Vitrual Machine IDentifier LVMID= Local Vitrual Machine IDentifier  情况  本地虚拟机进程  VMID= LVMID  远程虚拟机进程 = VMID= [protocol:][//] lvmid [@hostname[:port]/servername]   interval  间隔时间，单位为秒或毫秒  count  打印次数，默认不限制     JSTACK  作用  观察当前java虚拟机内每一条线程正在执行的方法堆栈的集合，以定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等 java 程序崩溃生成 core 文件，jstack工具可以用来获得 core 文件的java stack和native stack的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题 Java 1.8 版本中不支持  机制
 生成java虚拟机当前时刻的线程快照 观察 Object.Monitor 于线程拥有和区域的情况，获得各进程的相关情况
   区域 状态 描述     Entry Set Waiting ThreadWaiting for monitor entry BLOCKEDwaiting for monitor entry线程进入临界区（ synchronized 保护起来的代码区）   The Owner Active Thread RUNNABLE   Wait Set Waiting Threadin Object.wait() WAITING / TIMED_WAITING  in Object.wait()/ waiting on condition      调用
 jstack [-Fml|h] &amp;lt;pid&amp;gt; 参数  -F  jstack &amp;lt;pid&amp;gt;未响应或进程挂起时，**强制 Dump **出线程数据  -m  混合模式打印出 java 和本机的框架信息  -l  长清单，显示锁相关信息  -h  打印出帮助文档信息     JMAP  作用  为进程、核心文件或远程调试服务器打印共享对象内存映射或堆内存细节 Java 1.8 版本中不支持  调用  jmap [option] &amp;lt;pid&amp;gt;|&amp;lt;executable &amp;lt;core&amp;gt;&amp;gt; | &amp;lt;[server_id@]&amp;lt;remoteServerIP | hostname&amp;gt;&amp;gt; 参数  &amp;lt;no option&amp;gt;  如果使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称  -dump:[live,]format=b,file=&amp;lt;filename&amp;gt;  以 hprof 二进制格式转储 Java 堆到指定文件中。live子选项是可选的 live子选项决定堆中只有活动的对象会被转储 可用 jhat 浏览 heap dump  -finalizerinfo  打印等待终结的对象信息  -heap  打印一个堆的摘要信息，包括使用的GC算法、堆配置信息和generation wise heap usage  -histo[:live]  打印堆的柱状图。其中包括每个Java类、对象数量、内存大小(单位：字节)- 、完全限定的类名 打印的虚拟机内部的类名称将会带有一个’*’前缀。如果指定了live子选项，则只计算活动的对象  -permstat  Java 1.8 版本中不支持 打印Java堆内存的永久保存区域的类加载器的智能统计信息 对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印  包含的字符串数量和大小   -F  强制模式。如果指定的pid没有响应，请使用jmap -dump或jmap -histo选项。此模式下，不支持live子选项  -h|help  打印帮助信息  -J&amp;lt;flag&amp;gt;  指定传递给运行jmap的JVM的参数     JCONSOLE  java GUI监视工具，可以以图表化的形式显示各种数据,并可通过远程连接监视远程的服务器VM 实时内存、线程、类和系统信息监控，并提供树型 MBean 结构进行属性、方法查询  Business.* TPTP  开发商  eclipse 官方的 Profiling 工具插件和可扩展的开发平台框架  遥测种类  只提供了线程 Telemetry  集成性  仅支持 Eclipse 通过 Eclipse update Manager 或者是安装包进行安装，安装成功后会在 eclipse 中增加相关操作按钮，并支持于 eclipse 中查询 profiling 结果  CPU快照  包的组成关系，细化到包含的类及类中的方法 方法的调用关系  以每个线程为根节点的方法调用信息，对于树中出现的代表方法的每个节点，列出了该方法的运行时间或运行时间百分比，以及该方法被调用的次数  方法被调用情况  直接调用某方法的其他方法 方法调用该方法的次数及相关运行时间  热点列表  CPU 占用时间排列前十的方法、类或包   内存快照  包含了类实例的内存分配情况，包括实例化的对象个数，以及这些对象的本身占用内存的大小。  源代码定位  只能定位到某个类  无法定位到方法或其中的成员变量。   快照操作  这些快照不会自动保存，因此当 eclipse 关闭后，这些快照数据将会消失  通过 export 的方式将需要的快照保存下来   性能健壮性  SAMPLING 模式相关不大 BCI 当前 .6.2无提供 健壮   CodePro Profiler  开发商  instantiations 公司推出的一款商用 eclipse 插件  遥测种类：  CPU, 内存, 线程, 载入的类以及垃圾收集  集成性：  仅支持 Eclipse Eclipse update Manager 进行安装或者是将安装包直接解压缩后保存在 eclipse 的指定目录下  CPU快照  包的组成关系，细化到包含的类及类中的方法 方法的调用关系。以树结构表示  类型  以每个线程为根节点的方法调用关系 以整个线程为根节点的方法调用关系 以每个方法为根节点的方法调用关系  对于树中出现的代表方法的每个节点，列出了该方法的运行时间或运行时间百分比，以及由该方法生成的对象个数和为这些对象分配的内存大小  方法的被调用关系。该关系以树结构表示，其中根节点为某个指定的方法  每个节点的子节点为父节点的调用者  热点列表  包含了 CPU 占用时间排前的一些方法   内存快照  类实例的内存分配情况，包括实例化的对象个数，以及这些对象的 shallow 和 retained 大小 最大对象列表  包含了 retained 大小排前的一些对象  有可能存在内存泄漏的对象列表：包含了有可能存在内存泄漏的对象以及可能性大小  源代码定位  拥有该功能，但是只能定位到类及成员变量，无法定位到方法  快照操作  快照会被自动保存在 Eclipse Workspace 之外的一个临时空间，但会随 eclipse 关闭页消失 提供同类型快照（同 BCI 模式等）比较  性能健壮性  SAMPLING 模式相关不大 BCI 进行 Profilling 时较慢  5万行代码需要5分钟  PROFILLING 较大型程序时，容易出现栈溢出情况    YourKit Java Profiler  开发商  商用软件  遥测种类  CPU, 内存, 线程以及垃圾收集  集成性：  支持的操作系统包括  Windows Linux FreeBSD Mac OS X Solaris HP-UX  支持的 IDE  Eclipse JBuilder JDeveloper NetBeans Intellij IDEA  用户就可以从 Eclipse 中启动 Profiling，但是 profiling 的结果需要在 YourKit Java Profiler 中进行查询  CPU快照：  包的组成关系  细化到包含的类及类中的方法  方法的调用关系  以树结构表示，根据根节点表示的对象的不同，分为三种类型：以每个线程为根节点的方法调用关系，以整个线程为根 节点的方法调用关系，以及以每个方法为根节点的方法调用关系。对于树中出现的代表方法的每个节点，列出了该方法的运行时间或运行时间百分比，以及由该方法 生成的对象个数和为这些对象分配的内存大小。  方法的被调用关系  该关系以树结构表示，其中根节点为某个指定的方法，每个节点的子节点为父节点的调用者。  热点列表  包含了 CPU 占用时间排前的一些方法。   内存快照
 类实例的内存分配情况，包括实例化的对象个数，以及这些对象的 shallow 和 retained 大小 最大对象列表  包含了 retained 大小排前的一些对象   源代码定位 - 可以定位到类、成员变量及方法。 快照操作  针对内存快照提供了自动获取快照的功能，被自动保存到一个临时的文件夹  性能健壮性  SAMPLING 模式相关不大 BCI 进行 Profilling 时一般  5万行代码需要1分钟  健壮   JProfiler  开发商  ej-technologies 推出的一款商用软件  遥测种类  CPU, 内存 , 线程 , 载入的类以及垃圾收集  集成性  支持的操作系统有  Windows Linux Mac OS X FreeBSD Solaris AIX HP-UX  支持的 IDE  Eclipse NetBeans Intellij IDEA JBuiler JDeveloper  用户就可以从 Eclipse 中启动 Profiling，但 profiling 的结果需要在 JProfiler 中进行查询  CPU快照  包的组成关系，细化到包含的类及类中的方法 节点的方法调用关系，以及以每个方法为根节点的方法调用关系。对于树中出现的代表方法的每个节点，列出了该方法的运行时间或运行时间百分比，以及由该方法 生成的对象个数和为这些对象分配的内存大小 方法的被调用关系。该关系以关系图展现，存在复杂结构展示不全情况 热点列表：包含了 CPU 占用时间排前的一些方法  内存快照  类实例的内存分配情况，包括实例化的对象个数，以及这些对象的 shallow 和 retained 大小 最大对象列表：包含了 retained 大小排前的一些对象  源代码定位  可以定位到类、成员变量及方法  快照操作  指定一个目录来保存该 snapshot  性能健壮性  SAMPLING 模式相关不大 BCI 进行 Profilling 时较无影响  5万行代码需要半分钟  健壮   参考  整理  JPS JINFO JSTAT JSTACK JMAP   </content>
    </entry>
    
     <entry>
        <title>Python.Pack</title>
        <url>http://domain.yqjdcyy.com/post/python.pack/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Python</tag>
        </tags>
        <content type="html">  类型  .py  项目源码 需要安装 Python 及依赖库  .pyc  Python 解释器可识别的二进制码 跨平台 需要安装 Python 及依赖库  .exe  不同平台的可执行文件   工具比较    Solution Windows Linux OS X Python 3 One file mode Zipfile import Eggs pkg_resources support     bbFreeze yes yes yes no no yes yes yes   py2exe yes no no yes yes yes no no   pyInstaller yes yes yes no yes no yes no   cx_Freeze yes yes yes yes no yes yes no   py2app no no yes yes no yes yes yes    详解 pyInstaller 注意事项  依赖于打包环境，无法于 x64 环境打 x86 的包 &amp;gt; Pyinstaller produces a binary depending from the python you used to build it. So if you use python 2.7 64 bit it is not possible, as far as I know, to produce a 32 bit executable.  指令  安装  pip[3] install pyinstaller  版本  pyinstaller --version  执行  pyinstaller [option] *.py 参数  -F  打包出可独立运行 exe  -c  使用控制台，无界面 默认项  -w|--noconsole  去除控制台窗口，仅带 GUI 界面时推荐 cmd 中执行时不显示相关日志  -i  指定可执行文件的图标   示例  pyinstaller -F -i favicon.ico pack.py      查看文件列表  pyi-archive_viewer *.exe 示例  pyi-archive_viewer pack.exe  pos, length, uncompressed, iscompressed, type, name [(0, 255, 323, 1, &#39;m&#39;, &#39;struct&#39;), (255, 1104, 1814, 1, &#39;m&#39;, &#39;pyimod01_os_path&#39;), (1359, 4287, 9268, 1, &#39;m&#39;, &#39;pyimod02_archive&#39;), (5646, 7221, 18489, 1, &#39;m&#39;, &#39;pyimod03_importers&#39;), (12867, 1859, 4171, 1, &#39;s&#39;, &#39;pyiboot01_bootstrap&#39;), (14726, 86, 103, 1, &#39;s&#39;, &#39;pack&#39;), (14812, 47536, 87888, 1, &#39;b&#39;, &#39;VCRUNTIME140.dll&#39;), (62348, 39531, 87552, 1, &#39;b&#39;, &#39;_bz2.pyd&#39;), (101879, 623839, 1443840, 1, &#39;b&#39;, &#39;_hashlib.pyd&#39;), (725718, 85308, 247296, 1, &#39;b&#39;, &#39;_lzma.pyd&#39;), (811026, 28848, 65536, 1, &#39;b&#39;, &#39;_socket.pyd&#39;), (839874, 782920, 1737216, 1, &#39;b&#39;, &#39;_ssl.pyd&#39;), (1622794, 480, 1029, 1, &#39;b&#39;, &#39;pack.exe.manifest&#39;), (1623274, 83821, 180736, 1, &#39;b&#39;, &#39;pyexpat.pyd&#39;), (1707095, 1522436, 3555840, 1, &#39;b&#39;, &#39;python36.dll&#39;), (3229531, 9124, 19968, 1, &#39;b&#39;, &#39;select.pyd&#39;), (3238655, 356822, 899072, 1, &#39;b&#39;, &#39;unicodedata.pyd&#39;), (3595477, 0, 0, 0, &#39;o&#39;, &#39;pyi-windows-manifest-filename pack.exe.manifest&#39;), (3595477, 196507, 734166, 1, &#39;x&#39;, &#39;base_library.zip&#39;), (3791984, 1150741, 1150741, 0, &#39;z&#39;, &#39;out00-PYZ.pyz&#39;)]    查看可执行文件依赖动态库  pyi-bindepend *.exe 示例  pyi-bindepend pack.exe  pack.exe {&#39;KERNEL32.dll&#39;, &#39;WS2_32.dll&#39;}     其它  暂略  参考 官网  PyInstaller PyInstaller.Manual PyInstaller.Using  教程  pyinstaller简洁教程 Python程序打包成exe可执行文件  交叉编译  http://www.alivepea.me/prog/pyinstaller/ 基于wine的linux交叉编译python程序  补充  Can I control the architecture (32bit vs 64bit) when building a pyinstaller executable? 使用PyInstaller打包Python程序  </content>
    </entry>
    
     <entry>
        <title>Java.Tools.JInfo</title>
        <url>http://domain.yqjdcyy.com/post/java.tools.jinfo/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>tools</tag>
        </tags>
        <content type="html">  JINFO 作用  输出进程、Core 文件或远程 Debug 服务器配置信息  Java 系统参数 命令行参数  运行于64位虚拟机上时，需指定 -J-d64 Java 1.8 版本中不支持  调用  jinfo [option] &amp;lt;pid&amp;gt; 参数  -flag &amp;lt;name&amp;gt;
 to print the value of the named VM flag  -flag [&#43;|-]&amp;lt;name&amp;gt;
 to enable or disable the named VM flag  -flag &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;  to set the named VM flag to the given value  -flags
 to print VM flags    示例  jinfo pid  Caused by: sun.jvm.hotspot.runtime.VMVersionMismatchException: Supported versions are 24.60-b09. Target VM is 25.25-b02   Reference  官方  jinfo 2.13 The jinfo Utility  整理  Java命令学习系列（六）——jinfo   </content>
    </entry>
    
     <entry>
        <title>Java.Tools.JPS</title>
        <url>http://domain.yqjdcyy.com/post/java.tools.jps/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>tools</tag>
        </tags>
        <content type="html">  JPS 作用  显示当前用户本地 JAVA 进程及进程号  机制  java 程序启动后，会在 java.io.tmpdir 指定临时目录下，生成名称类似于 hsperfdata_User 的文件夹，其中个别文件的名字就是 java 进程的 pid 示例  appuser 用户 ll /tmp/hsperfdata_appuser/  total 928 -rw------- 1 appuser appuser 32768 May 2 22:17 11337 -rw------- 1 appuser appuser 32768 May 2 22:17 11489    调用  jps [-q] [-mlvV] [&amp;lt;hostid&amp;gt;] 参数  -q  仅显示 pid 值  -m  显示调用时 main 函数收到的启动参数  -l  显示启动类的进程 ID 和完整路径名  -v  显示调用 JVM 时的相关参数    示例  /usr/java/jdk1.7.0_60/bin/jps -m  26324 Maven31Main /data/jenkins/tools/hudson.tasks.Maven_MavenInstallation/_usr_local_maven /var/cache/jenkins/war/WEB-INF/lib/remoting-2.53.2.jar /data/jenkins/plugins/maven-plugin/WEB-INF/lib/maven31-interceptor-1.5.jar /data/jenkins/plugins/maven-plugin/WEB-INF/lib/maven3-interceptor-commons-1.5.jar 52930 11489 Kafka config/server.properties 23692 Bootstrap start  /usr/java/jdk1.7.0_60/bin/jps -v  9107 Bootstrap -Djava.util.logging.config.file=/data/service/webapps/basic-operation-test/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Dtomcat.instance.name=basic-operation-test -Dspring.profiles.active=test -Dspring.cloud.config.uri=http://localhost:29011/config-server -Xms600m -Xmx600m -XX:&#43;UseConcMarkSweepGC -XX:&#43;UnlockDiagnosticVMOptions -XX:&#43;PrintGCDetails -XX:&#43;PrintClassHistogramBeforeFullGC -XX:&#43;PrintClassHistogramAfterFullGC -XX:&#43;HeapDumpOnOutOfMemoryError -Djava.endorsed.dirs=/data/service/tomcat/endorsed -Dcatalina.base=/data/service/webapps/basic-operation-test -Dcatalina.home=/data/service/tomcat -Djava.io.tmpdir=/data/service/webapps/basic-operation-test/temp 17888 Elasticsearch -Xms256m -Xmx2g -Djava.awt.headless=true -XX:&#43;UseParNewGC -XX:&#43;UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:&#43;UseCMSInitiatingOccupancyOnly -XX:&#43;HeapDumpOnOutOfMemoryError -XX:&#43;DisableExplicitGC -Dfile.encoding=UTF-8 -Delasticsearch -Des.path.home=/data/elasticsearch-test 26324 Maven31Main   Reference  官方  jps 2.15 The jps Utility  整理  Java命令学习系列（一）——Jps   </content>
    </entry>
    
     <entry>
        <title>Java.Tools.JStack</title>
        <url>http://domain.yqjdcyy.com/post/java.tools.jstack/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>tools</tag>
        </tags>
        <content type="html">  JSTACK 作用  观察当前java虚拟机内每一条线程正在执行的方法堆栈的集合，以定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等 java 程序崩溃生成 core 文件，jstack工具可以用来获得 core 文件的java stack和native stack的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题 Java 1.8 版本中不支持  机制  生成java虚拟机当前时刻的线程快照 观察 Object.Monitor 于线程拥有和区域的情况，获得各进程的相关情况 | 区域 | 状态 | 描述 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;| | Entry Set | Waiting ThreadWaiting for monitor entry | BLOCKEDwaiting for monitor entry线程进入临界区（ synchronized 保护起来的代码区） | | The Owner | Active Thread | RUNNABLE | | Wait Set | Waiting Threadin Object.wait() | WAITING / TIMED_WAITING  in Object.wait()/ waiting on condition |   调用  jstack [-Fml|h] &amp;lt;pid&amp;gt; 参数  -F  jstack &amp;lt;pid&amp;gt;未响应或进程挂起时，**强制 Dump **出线程数据  -m  混合模式打印出 java 和本机的框架信息  -l  长清单，显示锁相关信息  -h  打印出帮助文档信息   状态  NEW  未启动的不会出现在 Dump 中  RUNNABLE  在虚拟机内执行的  BLOCKED  受阻塞并等待监视器锁  WATING  无限期等待另一个线程执行特定操作  TIMED_WATING  有时限的等待另一个线程的特定操作  TERMINATED  已退出的   修饰  locked &amp;lt;地址&amp;gt; 目标  使用 synchronized 申请对象锁成功,监视器的拥有者。  waiting to lock &amp;lt;地址&amp;gt; 目标  使用 synchronized 申请对象锁未成功,在进入区等待。  waiting on &amp;lt;地址&amp;gt; 目标  使用 synchronized 申请对象锁成功后,释放锁幵在等待区等待。  parking to wait for &amp;lt;地址&amp;gt; 目标  动作  runnable  状态一般为 RUNNABLE  in Object.wait()  等待区等待,状态为 WAITING 或 TIMED_WAITING  waiting for monitor entry  进入区等待,状态为 BLOCKED  waiting on condition  等待区等待、被 park  sleeping  休眠的线程,调用了 Thread.sleep()    示例  /usr/java/jdk1.7.0_60/bin/jstack 29003
&amp;#34;http-nio-127.0.0.1-29029-ClientPoller-0&amp;#34; #28 daemon prio=5 os_prio=0 tid=0x00007f9d8c4a5800 nid=0x71ba runnable [0x00007f9d513be000] java.lang.Thread.State: RUNNABLE &amp;#34;ContainerBackgroundProcessor[StandardEngine[Catalina]]&amp;#34; #27 daemon prio=5 os_prio=0 tid=0x00007f9d8c4a4000 nid=0x71b9 waitin on condition [0x00007f9d514bf000] java.lang.Thread.State: TIMED_WAITING (sleeping) &amp;#34;Abandoned connection cleanup thread&amp;#34; #24 daemon prio=5 os_prio=0 tid=0x00007f9d15de4000 nid=0x7188 in Object.wait() [0x00007f9d138fd000] java.lang.Thread.State: TIMED_WAITING (on object monitor) while(true)
&amp;#34;main&amp;#34; #1 prio=5 os_prio=0 tid=0x0000000005422800 nid=0x20e0 runnable [0x000000000517f000] java.lang.Thread.State: RUNNABLE at com.yao.common.thread.ThreadBlockTest.main(ThreadBlockTest.java:12)  lock
 jstack-deadlock.log ``` Found one Java-level deadlock: ============================= &amp;ldquo;Thread-1&amp;rdquo;: waiting to lock monitor 0x0000000004b47828 (object 0x000000076b45c4d0, a java.lang.Object), which is held by &amp;ldquo;Thread-0&amp;rdquo; &amp;ldquo;Thread-0&amp;rdquo;: waiting to lock monitor 0x00000000209a0a68 (object 0x000000076b45c4e0, a java.lang.Object), which is held by &amp;ldquo;Thread-1&amp;rdquo;  Java stack information for the threads listed above: &amp;ldquo;Thread-1&amp;rdquo;: at com.yao.common.thread.DeadLock.run(ThreadLockDead.java:52) - waiting to lock  (a java.lang.Object) - locked  (a java.lang.Object) at java.lang.Thread.run(Thread.java:745) &amp;ldquo;Thread-0&amp;rdquo;: at com.yao.common.thread.DeadLock.run(ThreadLockDead.java:39) - waiting to lock  (a java.lang.Object) - locked  (a java.lang.Object) at java.lang.Thread.run(Thread.java:745)
```
  Reference  官方  jstack
 2.16 The jstack Utility  整理  Java命令学习系列（二）——Jstack  补充  如何使用jstack分析线程状态 java死锁的例子   </content>
    </entry>
    
     <entry>
        <title>Java.Tools.JStat</title>
        <url>http://domain.yqjdcyy.com/post/java.tools.jstat/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>tools</tag>
        </tags>
        <content type="html">  JSTAT 作用 - 监视vm内存内的各种**堆**和非堆的**大小**及其**内存使用**量，并可观察classloader，compiler，**gc**相关信息 调用  jstat -&amp;lt;option&amp;gt; [-t] [-h&amp;lt;lines&amp;gt;] &amp;lt;vmid&amp;gt; [&amp;lt;interval&amp;gt; [&amp;lt;count&amp;gt;]] 参数  option  选项  –class  监视类装载、卸载数量、总空间及类装载所耗费时间 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;| | Loaded | 装载类的数量 | 11736 | | Bytes | 装载类所占字节数 | 22293.3 | | Unloaded | 卸载类的数量 | 0 | | Bytes | 卸载类所占字节数 | 0.0 | | Time | 装载和卸载类所花的时间 | 13.24 |  –gc  监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;-| | S0C | 年轻代中第一个survivor（幸存区）的容量 (字节) | 20480.0 | | S1C | 年轻代中第二个survivor（幸存区）的容量 (字节) | 20480.0 | | S0U | 年轻代中第一个survivor（幸存区）目前已使用空间 (字节) | 8.0 | | S1U | 年轻代中第二个survivor（幸存区）目前已使用空间 (字节) | 0.0 | | EC | 年轻代中Eden的容量 (字节) | 163840.0 | | EU | 年轻代中Eden目前已使用空间 (字节) | 35825.1 | | OC | Old代的容量 (字节) | 409600.0 | | OU | Old代目前已使用空间 (字节) | 132443.4 | | PC | Perm(持久代)的容量 (字节) | � | | PU | Perm(持久代)目前已使用空间 (字节) | � | | YGC | 从应用程序启动到采样时年轻代中gc次数 | 172 | | YGCT | 从应用程序启动到采样时年轻代中gc所用时间(s) | 2.254 | | FGC | 从应用程序启动到采样时old代(全gc)gc次数 | 4 | | FGCT | 从应用程序启动到采样时old代(全gc)gc所用时间(s) | 0.180 | | GCT | 从应用程序启动到采样时gc用的总时间(s) | 2.434 |
  –gccapacity  监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最小空间 | 字段 | 描述 | 数值 | |:&amp;mdash;&amp;mdash;|:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|:&amp;mdash;&amp;mdash;&amp;mdash;| | NGCMN | 年轻代(young)中初始化(最小)的大小(字节) | 204800.0 | | NGCMX | 年轻代(young)的最大容量 (字节) | 204800.0 | | NGC | 年轻代(young)中当前的容量 (字节) | 204800.0 | | S0C | 年轻代中第一个survivor（幸存区）的容量 (字节) | 20480.0 | | S1C | 年轻代中第二个survivor（幸存区）的容量 (字节) | 20480.0 | | EC | 年轻代中Eden（伊甸园）的容量 (字节) | 163840.0 | | OGCMN | old代中初始化(最小)的大小 (字节) | 409600.0 | | OGCMX | old代的最大容量(字节) | 409600.0 | | OGC | old代当前新生成的容量 (字节) | 409600.0 | | OC | Old代的容量 (字节) | 409600.0 | | PGCMN | perm代中初始化(最小)的大小 (字节) | � | | PGCMX | perm代的最大容量 (字节) | � | | PGC | perm代当前新生成的容量 (字节) | � | | PC | Perm(持久代)的容量 (字节) | � | | YGC | 从应用程序启动到采样时年轻代中gc次数 | 173 | | FGC | 从应用程序启动到采样时old代(全gc)gc次数 | 4 |  –gcutil  监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;-| | S0 | 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比 | 0.00 | | S1 | 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比 | 0.04 | | E | 年轻代中Eden（伊甸园）已使用的占当前容量百分比 | 6.00 | | O | old代已使用的占当前容量百分比 | 32.33 | | P | perm代已使用的占当前容量百分比 | � | | YGC | 从应用程序启动到采样时年轻代中gc次数 | 173 | | YGCT | 从应用程序启动到采样时年轻代中gc所用时间(s) | 2.258 | | FGC | 从应用程序启动到采样时old代(全gc)gc次数 | 4 | | FGCT | 从应用程序启动到采样时old代(全gc)gc所用时间(s) | 0.180 | | GCT | 从应用程序启动到采样时gc用的总时间(s) | 2.438 |
  –gccause  与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因  –gcnew  监视新生代GC的状况 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;| | S0C | 年轻代中第一个survivor（幸存区）的容量 (字节) | 20480.0 | | S1C | 年轻代中第二个survivor（幸存区）的容量 (字节) | 20480.0 | | S0U | 年轻代中第一个survivor（幸存区）目前已使用空间 (字节) | 0.0 | | S1U | 年轻代中第二个survivor（幸存区）目前已使用空间 (字节) | 8.0 | | TT | 持有次数限制 | 6 | | MTT | 最大持有次数限制 | 6 10240.0 | | EC | 年轻代中Eden（伊甸园）的容量 (字节) | 163840.0 | | EU | 年轻代中Eden（伊甸园）目前已使用空间 (字节) | 13029.7 | | YGC | 从应用程序启动到采样时年轻代中gc次数 | 173 | | YGCT | 从应用程序启动到采样时年轻代中gc所用时间(s) | 2.258 |
  –gcnewcapacity  监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;-| | NGCMN | 年轻代(young)中初始化(最小)的大小(字节) | 204800.0 | | NGCMX | 年轻代(young)的最大容量 (字节) | 204800.0 | | NGC | 年轻代(young)中当前的容量 (字节) | 204800.0 | | S0CMX | 年轻代中第一个survivor（幸存区）的最大容量 (字节) | 20480.0 | | S0C | 年轻代中第一个survivor（幸存区）的容量 (字节) | 20480.0 | | S1CMX | 年轻代中第二个survivor（幸存区）的最大容量 (字节) | 20480.0 | | S1C | 年轻代中第二个survivor（幸存区）的容量 (字节) | 20480.0 | | ECMX | 年轻代中Eden（伊甸园）的最大容量 (字节) | 163840.0 | | EC | 年轻代中Eden（伊甸园）的容量 (字节) | 163840.0 | | YGC | 从应用程序启动到采样时年轻代中gc次数 | 173 | | FGC | 从应用程序启动到采样时old代(全gc)gc次数 | 4 |
  –gcold  监视老年代GC的状况 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;-| | PC | Perm(持久代)的容量 (字节) | � | | PU | Perm(持久代)目前已使用空间 (字节) | � | | OC | Old代的容量 (字节) | 409600.0 | | OU | Old代目前已使用空间 (字节) | 132443.4 | | YGC | 从应用程序启动到采样时年轻代中gc次数 | 173 | | FGC | 从应用程序启动到采样时old代(全gc)gc次数 | 4 | | FGCT | 从应用程序启动到采样时old代(全gc)gc所用时间(s) | 0.180 | | GCT | 从应用程序启动到采样时gc用的总时间(s) | 2.438 |
  –gcoldcapacity  监视内容与—gcold基本相同，输出主要关注使用到的最大和最小空间 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;-| | OGCMN | old代中初始化(最小)的大小 (字节) | 409600.0 | | OGCMX | old代的最大容量(字节) | 409600.0 | | OGC | old代当前新生成的容量 (字节) | 409600.0 | | OC | Old代的容量 (字节) | 409600.0 | | YGC | 从应用程序启动到采样时年轻代中gc次数 | 173 | | FGC | 从应用程序启动到采样时old代(全gc)gc次数 | 4 | | FGCT | 从应用程序启动到采样时old代(全gc)gc所用时间(s) | 0.180 | | GCT | 从应用程序启动到采样时gc用的总时间(s) | 2.438 |
  –gcpermcapacity  输出永久代使用到的最大和最小空间 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;-| | PGCMN | perm代中初始化(最小)的大小 (字节) | � | | PGCMX | perm代的最大容量 (字节) | � | | PGC | perm代当前新生成的容量 (字节) | � | | PC | Perm(持久代)的容量 (字节) | � | | YGC | 从应用程序启动到采样时年轻代中gc次数 | 173 | | FGC | 从应用程序启动到采样时old代(全gc)gc次数 | 4 | | FGCT | 从应用程序启动到采样时old代(全gc)gc所用时间(s) | 0.180 | | GCT | 从应用程序启动到采样时gc用的总时间(s) | 2.438 |
  –compiler  输出JIT编译器编译过的方法、耗时等信息 | 字段 | 描述 | 数值 | |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-| | Compiled | 编译任务执行数量 | 9726 | | Failed | 编译任务执行失败数量 | 3 | | Invalid | 编译任务执行失效数量 | 0 | | Time | 编译任务消耗时间 | 85.85 | | FailedType | 最后一个编译失败任务的类型 | 1 | | FailedMethod | 最后一个编译失败任务所在的类及方法 | com/mysql/jdbc/AbandonedConnectionCleanupThread run |  –printcompilation  输出已经被JIT编译的方法 可由 -XX:&#43;PrintComplation 设置 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;| | Compiled | 编译任务的数目 | 9726 | | Size | 方法生成的字节码的大小 | 582 | | Type | 编译类型 | 1 | | Method | 类名和方法名用来标识编译的方法 | org/springframework/data/redis/core/RedisTemplate$6 doInRedis |
    vmid  VM 进程号，即当前运行 java 进程号  VMID= Vitrual Machine IDentifier LVMID= Local Vitrual Machine IDentifier  情况  本地虚拟机进程  VMID= LVMID  远程虚拟机进程 = VMID= [protocol:][//] lvmid [@hostname[:port]/servername]   interval  间隔时间，单位为秒或毫秒  count  打印次数，默认不限制    示例  /usr/java/jdk1.7.0_60/bin/jstat -class 29003  Loaded Bytes Unloaded Bytes Time 11736 22293.3 0 0.0 13.24  /usr/java/jdk1.7.0_60/bin/jstat -gc 29003  Warning: Unresolved Symbol: sun.gc.generation.2.space.0.capacity substituted NaN Warning: Unresolved Symbol: sun.gc.generation.2.space.0.used substituted NaN S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 20480.0 20480.0 8.0 0.0 163840.0 35825.1 409600.0 132443.4 � � 172 2.254 4 0.180 2.434  /usr/java/jdk1.7.0_60/bin/jstat -compiler 29003  Compiled Failed Invalid Time FailedType FailedMethod 9726 3 0 85.85 1 com/mysql/jdbc/AbandonedConnectionCleanupThread run [appuser@iZ94nvigjtdZ ~]$ /usr/java/jdk1.7.0_60/bin/jstat -gccapacity 29003 Warning: Unresolved Symbol: sun.gc.generation.2.minCapacity substituted NaN Warning: Unresolved Symbol: sun.gc.generation.2.maxCapacity substituted NaN Warning: Unresolved Symbol: sun.gc.generation.2.capacity substituted NaN Warning: Unresolved Symbol: sun.gc.generation.2.space.0.capacity substituted NaN NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC PGCMN PGCMX PGC PC YGC FGC 204800.0 204800.0 204800.0 20480.0 20480.0 163840.0 409600.0 409600.0 409600.0 409600.0 � � � � 173 4  /usr/java/jdk1.7.0_60/bin/jstat -gcnew 29003  S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 20480.0 20480.0 0.0 8.0 6 6 10240.0 163840.0 9772.3 173 2.258  /usr/java/jdk1.7.0_60/bin/jstat -gcutil 29003  Warning: Unresolved Symbol: sun.gc.generation.2.space.0.capacity substituted NaN Warning: Unresolved Symbol: sun.gc.generation.2.space.0.used substituted NaN Warning: Unresolved Symbol: sun.gc.generation.2.space.0.capacity substituted NaN S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 0.04 6.00 32.33 � 173 2.258 4 0.180 2.438  /usr/java/jdk1.7.0_60/bin/jstat -gcnew 29003  S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 20480.0 20480.0 0.0 8.0 6 6 10240.0 163840.0 13029.7 173 2.258  /usr/java/jdk1.7.0_60/bin/jstat -gcnewcapacity 29003  NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC 204800.0 204800.0 204800.0 20480.0 20480.0 20480.0 20480.0 163840.0 163840.0 173 4  /usr/java/jdk1.7.0_60/bin/jstat -gcold 29003  Warning: Unresolved Symbol: sun.gc.generation.2.space.0.capacity substituted NaN Warning: Unresolved Symbol: sun.gc.generation.2.space.0.used substituted NaN PC PU OC OU YGC FGC FGCT GCT � � 409600.0 132443.4 173 4 0.180 2.438  /usr/java/jdk1.7.0_60/bin/jstat -gcoldcapacity 29003  OGCMN OGCMX OGC OC YGC FGC FGCT GCT 409600.0 409600.0 409600.0 409600.0 173 4 0.180 2.438  jstat -gcutil 12191 250 7  统计 GC 时 heap 情况，间隔250毫秒，打印7次   Reference  官方  jstat 2.17 The jstat Utility  整理  Java命令学习系列（四）——jstat   </content>
    </entry>
    
     <entry>
        <title>Error.CSharp</title>
        <url>http://domain.yqjdcyy.com/post/error.csharp/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Error</tag><tag>CSharp</tag>
        </tags>
        <content type="html">  异常 在可以调用 OLE 之前，必须将当前线程设置为单线程单元(STA)模式，请确保您的Main函数带有STAThreadAttribute标记 解决  Main 方法上增加 [STAThread] 标志 ``` c# Thread app = new Thread(new ParameterizedThreadStart(ShowWindow)); app.ApartmentState = ApartmentState.STA;  Thread newThread = new Thread(new ThreadStart(ThreadMethod)); newThread.SetApartmentState(ApartmentState.MTA); ```
解析  STA  线程创建并进入一单线程单元  MTA  线程创建并进入一多线程单元  Unknown  尚未设置 ApartmentState 属   过程  COM 类中使用的公共语言库需要在 COM interop 情况下调用 COM 对象时创建单元  其中托管进程帮忙创建时允许其进入一个线程的单线程单元（STA）或多线程单元（MTA）   </content>
    </entry>
    
     <entry>
        <title>Hello.Linux</title>
        <url>http://domain.yqjdcyy.com/post/hello.linux/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  进度 Linux 基础文件  14&amp;frasl;30
Linux 架站文件 0/ 31
Linux 安全 0/ 1
Solaris 0/ 1
  概述 系统特点  开源免费、稳定性 安全性 处理多并发性能好  系统管理事项(kernel)  系统呼叫接口 行程管理：多任务 内存管理：控制内存，虚拟内存 档案系统管理：数据I/O及NTFS档案格式硬盘 装置驱动     系统演化  Unix - 1973  IBM AIX SUM SOLARIS HP HP UNIX 伯克利分校 MINIX  LINUS LINUX - 1994  REDHAT S.U.S.E 红旗     VMWare安装 学习流程  Linux平台开发，含vi,gcc,gdb,make,jdk,tomcat,mysql和linux基本操作 加厚c语言功底（c专家编程）或java语言 学习 Unix 环境高级编程（Unix环境高级编程） Linux应用系统开发或嵌入式开发  推荐书籍  《鸟哥的Linux私房菜》 《Linux编程从入门到精通》 《Linux内核完全剖析》  常用概念 安装  yum  进行软件包管理安装，一般用于自动从中央仓库下载安装指令 yum -y install make|patch|ntp  make  主要针对tar.gz和tar.bz2打包软件，然后使用[./configure;]make;make install进行安装 其中./configure用于配置软件功能，其参数&amp;ndash;prefix用于指定软件安装目录 使用方式  ./configure [--prefix=/opt/fcitx 指定安装至/opt/fcitx目录]    软件地址  doc2unix java  系统指令 指令格式  command [-options] ...params  command 为命令或可执行文件的名称，例如变换路径的命令为 cd 等等 []并不存在于实际的命令中  加入选项配置时，通常选项前会带 - 如 -h 使用选项的完整全名，则选项前带有 --, 如--help  ...params 为依附在选项后面的参数，或者是 command 的参数； 命令太长的时候，可以使用 \ 来跳脱[Enter]符号，使命令连续到下一行   常用指令 系统登录  root  系统管理员账号，同 Winddows 的Administrator 建议以其它账号登录后使用 su - 命令来切换至root  startx  进入图形界面  Ctrl&#43; Alt&#43; F2  CentOS进入命令行界面执行语句
  Ctrl&#43; Alt&#43; F7  进入图型界面语句  shutdown -n now/20/20:00  立刻关机/20分钟后关机/晚上8点关机  reboot  重启计算机  logout  注销  passwd  修改用户口令   系统信息  who/ whoami/ id  用户基本信息查看  uname/uname -a/uname --all  显示之前操作系统名称  firefox/firefox &amp;amp;  打开火狐/后台打开火狐浏览器
  env  查看当前用户使用的所有环境变量  ls/ls -a  显示当前文件夹内文件/显示含隐藏文件信息  echo $SHELL  显示当前系统shell版本  date  显示当前系统时间  date &#43;%Y/%m/%d  Fri Sep 13 21:34:18 CST 2013 -&amp;gt; 2013/09/13    cal  cal [month] [year]  查看某年某月的日历功能   bc  计算器，默认精度为整数，可用scale=X来调整精度，使用完成输入quit退出   快捷操作  [tab][tab]  一次补全，两次显示所有此前缀指令  Ctrl&#43; C  中断当前指令  Ctrl&#43; D  退出当前文本文字接口，离开  CRT下进行复制粘贴  鼠标选中后执行 Ctrl&#43; Insert 进行 复制，执行 Shift&#43; Insert 进行 粘贴   帮助  man  查询当前指令的说明，包括分类（DATE(1)）、完整名、选项、参数等 匹配按键  /String  向下搜索string字符串  ?String  向上搜索String字符串  q  结束此次man page   其中DATE(1)中1所对应的参数如下，输入 man 7 man 可以获取完整定义  1
 使用者在shell环境中可以操作的命令或可运行文件  2
 系统核心可呼叫的函数与工具等  3
 一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc)  4
 装置文件的说明，通常在/dev下的文件  5
 配置文件或者是某些文件的格式  6
 游戏(games)  7
 惯例与协议等，例如Linux文件系统、网络协议、ASCII code等等的说明
  8
 系统管理员可用的管理命令  9
 跟kernel有关的文件     指令详解 档案与目录管理  目录与路径
 路径概念  绝对路径  由根目录 / 写起  /usr/share/doc   相对路径  相对于目前工作目录的路径 /usr/share/doc
- cd /usr/share/man - cd ../man   目录操作
 目录指令
 cd  变换目录  pwd [-P]  显示目前的联结目录名称  mkdir [-mp] dirName  建立一个新的目录[-m用于设定档案权限，-p则可递归建立文档]  rmdir[-p]  删除一个空的目录[-p用于递归删除档案]   特殊目录
 .  代表此层目录  ..  代表上一层目录  -  代表前一个工作目录  ~  代表目前使用者身份所在的Home目录  ~account  代表 account 这个使用者的家目录     环境变量
 echo $PATH  输出环境变量  PATH=&amp;quot;$PATH&amp;quot;:/root  将/root目录添加至环境变量中，其中以:间隔各环境变量     档案与目录管理  档案与目录的检视
 ls [-aAdfFhilRS] [--color={none, auto, always}] [--full-time]
 目录名称 &amp;ndash;&amp;gt; 预设显示：非隐藏档的档名、 以档名进行排序及文件名代表的颜色显示 参数
 -a  全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来 388b9369-8237-4f6b-9948-a1c6baae1617_basic.mp4  -A  全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录  -d  仅列出目录本身，而不是列出目录内的档案数据  -f  直接列出结果，而不进行排序，速度快  -F  根据档案、目录等信息，给予附加数据结构  *  代表可执行档 iusql*  /  代表目录 3c15cab3-4eb2-400d-84a4-2af1191cd6be_640x360/  =  代表 socket 档案 rpcbind.sock=  |  代表 FIFO 档案 dmeventd-client|    -h  将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来 -rw-rw-r-- 1 appuser appuser 1.2M Jan 26 10:56 ff2ba789-09ba-49c1-8b3f-b27039fd9ef4_640x360.mp4  -i  列出 inode 位置，而非列出档案属性 8076778 3c15cab3-4eb2-400d-84a4-2af1191cd6be_640x360.mp4 8076782 3c15cab3-4eb2-400d-84a4-2af1191cd6be_640x360  -l  长数据形式，包含档案的属性等等数据 -rw-rw-r-- 1 appuser appuser 4042068 Jan 22 14:59 fe5c76c7-b1d5-42e0-9ad4-2567a6d14ccb_640x360.mp4  -n  列出 UID 与 GID 而非使用者与群组的名称 -rw-r--r-- 1 1001 1001 2293727 Oct 19 2017 ffb2dfd0-7c0f-48a2-85a2-c854a2d1f988_640x360.mp4  -r  将排序结果反向输出 ls -l  drwxrwxr-x 2 appuser appuser 4096 May 1 23:32 zip drwxrwxr-x 460 appuser appuser 20480 Apr 27 11:22 video drwxrwxr-x 2 appuser appuser 12288 May 1 23:37 record drwxrwxr-x 512 appuser appuser 90112 May 2 09:09 img drwxrwxr-x 688 appuser appuser 8192 May 1 23:32 hls drwxrwxr-x 3272 appuser appuser 57344 May 1 23:31 doc drwxrwxr-x 2 appuser appuser 8192 Apr 27 14:56 audio  ls -rl  drwxrwxr-x 2 appuser appuser 8192 Apr 27 14:56 audio drwxrwxr-x 3272 appuser appuser 57344 May 1 23:31 doc drwxrwxr-x 688 appuser appuser 8192 May 1 23:32 hls drwxrwxr-x 512 appuser appuser 90112 May 2 09:09 img drwxrwxr-x 2 appuser appuser 12288 May 1 23:37 record drwxrwxr-x 460 appuser appuser 20480 Apr 27 11:22 video drwxrwxr-x 2 appuser appuser 4096 May 1 23:32 zip   -R
 递归子目录内容进行展示 ls -R
./shell: curl-cookie-test watermark-run.sh watermark.sh ./to: preview-slide-rId2.jpg preview-slide-rId3.jpg preview-slide-rId4.jpg slide-rId4-35.jpg slide-rId4-55.jpg slide-rId4-75.jpg  -S
 以档案容量大小排序 ls -lhS  total 588K -rw-rw-r-- 1 appuser appuser 124K Oct 19 2017 preview-slide-rId4.jpg -rw-rw-r-- 1 appuser appuser 118K Dec 25 16:15 slide-rId4-75.jpg -rw-rw-r-- 1 appuser appuser 99K Dec 25 16:15 slide-rId4-55.jpg -rw-rw-r-- 1 appuser appuser 89K Oct 19 2017 preview-slide-rId3.jpg -rw-rw-r-- 1 appuser appuser 80K Oct 19 2017 preview-slide-rId2.jpg -rw-rw-r-- 1 appuser appuser 70K Dec 25 16:15 slide-rId4-35.jpg   -t
 依时间排序 ls -lt  -rw-rw-r-- 1 appuser appuser 70698 Dec 25 16:15 slide-rId4-35.jpg -rw-rw-r-- 1 appuser appuser 101205 Dec 25 16:15 slide-rId4-55.jpg -rw-rw-r-- 1 appuser appuser 120465 Dec 25 16:15 slide-rId4-75.jpg -rw-rw-r-- 1 appuser appuser 125989 Oct 19 2017 preview-slide-rId4.jpg -rw-rw-r-- 1 appuser appuser 90566 Oct 19 2017 preview-slide-rId3.jpg -rw-rw-r-- 1 appuser appuser 81338 Oct 19 2017 preview-slide-rId2.jpg   --color=never
 不要依据档案特性给予颜色显示；  --color=always
 显示颜色  --color=auto
 让系统自行依据设定来判断是否给予颜色  --full-time
 以完整时间模式 (包含年、月、日、时、分) 输出 ls --full-time  drwxrwxr-x 5 appuser appuser 4096 2018-03-16 12:27:05.786003128 &#43;0800 from drwxrwxr-x 2 appuser appuser 4096 2017-10-19 12:00:34.242962752 &#43;0800 shell drwxrwxr-x 2 appuser appuser 4096 2017-12-25 16:15:56.524407396 &#43;0800 to   --time={atime,ctime}
 输出 access 时间或 改变权限属性时间 (ctime)而非内容变更时间 (modification time)     复制、移动与删除
 cp [-adfilprsu] 来源档 * (source) 目的檔(destination)  复制档案或目录 参数  -a  相当于 -pdr 的意思；  -d  若来源文件为连结文件的属性(link file)，则复制连结文件属性而非档案本身；  -f  为强制 (force) 的意思，若有重复或其它疑问时，不会询问使用者，而强制复制；  -i  若目的檔(destination)已经存在时，在覆盖时会先询问是否真的动作！  -l  进行硬式连结 (hard link) 的连结档建立，而非复制档案本身；  -p  连同档案的属性一起复制过去，而非使用预设属性；  -r  递归持续复制，用于目录的复制行为；  -s  复制成为符号连结文件 (symbolic link) 快捷方式  -u  若 destination 比 source 旧才更新    rm [-fir] 档案或目录
 移除档案或目录 参数
 -f  就是 force 的意思，强制移除  -i  互动模式，在删除前会询问使用者是否动作  -r  递归删除   mv [-fiu] source1 source2 source3 .... destination
 移动档案与目录，或更名
 参数
 -f  force 强制的意思，强制移动而不询问  -i  若目标档案 (destination) 已经存在时，就会询问是否覆盖  -u  若目标档案已经存在，且 source 比较新，才会更新 (update)     取得路径的文件名称与目录名称
 获取文件名称  basename /data/test/resource  resource   获取目录名称  dirname /data/test/resource  /data/test     档案内容查阅  直接检视档案内容
 cat [-AEnTv] file
 由第一行开始显示档案内容 参数  -A  相当于 -vET 的整合参数，可列出一些特殊字符  -E  将结尾的断行字符 $ 显示出来  -n  打印出行号  -T  将 [tab] 按键以 ^I 显示出来  -v  列出一些看不出来的特殊字符    tac /etc/issue
 与cat相反，从最后一行开始显示  nl [-bnw] 文件
 带行号进行显示 参数  -b  指定行号指定的方式，主要有两种 -b a  表示不论是否为空行，也同样列出行号  -b t  如果有空行，空的那一行不要列出行号   -n  列出行号表示的方法，主要有三种 -n ln  行号在屏幕的最左方显示  -n rn  行号在自己字段的最右方显示，且不加 0  -n rz  行号在自己字段的最右方显示，且加 0   -w  行号字段的占用的位数。     可翻页检视
 more file
 一页一页的显示档案内容 操作  空格键 (space)  代表翻页  Enter  代表移行  /字符串  代表在这个显示的内容当中，向下搜寻『字符串』  :f  立刻显示出文件名及当前行数  q  代表立刻离开 more ，不再显示该档案内容    less file
 在 more 的基础上支持向前翻页 操作  [pagedown]  向下翻动一页  [pageup]  向上翻动一页  /字符串  向下搜寻『字符串』的功能  ?字符串  向上搜寻『字符串』的功能  n  重复前一个搜寻 (与 / 或 ? 有关！)  N  反向的重复前一个搜寻 (与 / 或 ? 有关！)
     资料撷取
 head [-n number] file  显示指定文件前number行（默认前十行）  tail [-cfFnqsv] file  显示指定文件右方数据，默认显示十行 参数  f  实时显示最新追加的数据  n line-rows  显示指定行数的数据     非纯文字文件
 od [-t TYPE] file  以二进制读取文档内容   修改档案时间和建置新档
 档案变动时间  mtime  修改档案更新时间  ctime  状态（如权限属性）变更时记录时间  atime  阅读档案时间   touch [-acdmt] file  调整档案时间    档案与目录的预设权限与隐藏权限  权限配置
 chrown [-Rf/abc] user[:group] file*/file1 file2..  参数  -f  忽略错误信息  -h  修复符号链接  -R  处理指定目录以及其子目录下的所有文件  abc各数值分别对应User/Group/Other的权限  读r=4,写w=2,执行x=1 常用权限如下  -rw------- (600)  只有属主有读写权限。  -rw-r--r-- (644)  只有属主有读写权限；而属组用户和其他用户只有读权限。  -rwx------ (700)  只有属主有读、写、执行权限。  -rwxr-xr-x (755)  属主有读、写、执行权限；而属组用户和其他用户只有读、执行权限。  -rwx--x--x (711)  属主有读、写、执行权限；而属组用户和其他用户只有执行权限。  -rw-rw-rw- (666)  所有用户都有文件读、写权限。这种做法不可取。  -rwxrwxrwx (777)  所有用户都有读、写、执行权限。更不可取的做法。       档案预设权限
 umask [-S] [abcd]  设置限制新建文件权限的掩码，以决定新文件被创建时的最初的权限 其中abcd分别对应特殊权限/User/Group/Other移除项属性值，其中档案默认最大权限为666，而目录为777 参数  -S  以符号方式输出权限掩码 u=rwx,g=rx,o=rx   示例  umask u=, g=w, o=rwx umask 0022 ll  drwxr-xr-x. 2 root root 4096 9月 28 12:02 resource  umask 007 mkdir test4Umask ll  drwxr-xr-x. 2 root root 4096 9月 28 12:02 resource drwxrwx---. 2 root root 4096 9月 28 17:55 test4Umask  umask 0022 ​    设置档案隐藏属性
 chattr [-RVf] [-&#43;=aAcCdDeijsStTu] [-v version] files...
 参数  -  递归处理所有的文件及子目录。　  -  详细显示修改内容，并打印输出。  &#43;  增加某一个特殊参数，其它原本存在参数则不动。  -  移除某一个特殊参数，其它原本存在参数则不动。  =  设定一定，且仅有后面接的参数  A  当设定了 A 这个属性时，这个档案(或目录)的存取时间 atime (access)不可被修改，可避免例如手提式计算机容易有磁盘 I/O 错误的情况发生！  S  这个功能有点类似 sync 的功能！就是会将数据同步写入磁盘当中！可以有效的避免数据流失！  a  当设定 a 之后，这个档案将只能增加数据，而不能删除 只有 root 才能设定这个属性。  c  这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩，但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用的！)  d  当dump(备份)程序被执行的时候，设定d属性将可使该档案(或目录)不具有dump功能  i  让一个档案不能被删除、改名、设定连结也无法写入或新增资料  j  当使用 ext3 这个档案系统格式时，设定 j 属性将会使档案在写入时先记录在journal 中 但是当 filesystem 设定参数为 data=journalled 时，由于已经设定了日志了，所以这个属性无效！  s  让系统在删除这个文件时，使用0填充文件所在的区域  u  当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件   示例
 chattr &#43;i chattr-test.dat  -rw-r--r-- 1 appuser appuser 2 May 2 11:12 chattr-test.dat   注意
 这个属性设定上面，比较常见的是 a 与 i 的设定值，而且很多设定值必须要身为 root 才能够设定的！    显示档案隐藏属性
 lsattr [-aR] file/dir  参数  -a  将隐藏文件的属性也显示出来  -R  连同子目录的数据也一并列出来   示例  lsattr -a  ----i--------e-- ./chattr-test -------------e-- ./.. -------------e-- ./slide-rId3-blue.jpg ----i--------e-- ./chattr-test.dat  ​    档案特殊权限
 示例  ll /tmp/ /usr/bin/passwd  drwxrwxrwt. 11 root root 4096 9月 28 17:00 tmp -rwsr-xr-x. 1 root root 30768 2月 22 2012 /usr/bin/passwd   解析  s  User  SUID，暂时得到root权限且仅用于二进制文档  /usr/bin/passwd 程序允许用户更新自己密码 但该程序会存取/etc/shadow密码文件，该文件却权为root所占有   Group  SGID（Set GID） 档案  SGID 是设定在 binary file 上面，则不论使用者是谁，在执行该程序的时候， 他的有效群组 (effective group) 将会变成该程序的群组所有人 (group id)。  目录  SGID 是设定在 A 目录上面，则在该 A 目录内所建立的档案或目录的 group ，将会是 此 A 目录的 group   其中如目录不具备x权限，但强制设置了s，则显示权限时会显示大写的S表示为空。  下面 t/T的显示逻辑与之相同。   t  Other SBit（Sticky Bit）设定于目录 在具有 SBit 的目录下，使用者若在该目录下具有 w 及 x 的权限 当使用者在该目录下建立档案或目录时，只有档案拥有者与 root 才有权力删除   设置  shattr abcd file/dir  a=[SUID=4, SGID=2, SBit=1] ​    档案类型
 file file/dir  显示档案的基本类型 示例  file hello.java  hello.java: ASCII C&#43;&#43; program text  file hello.class  hello.class: compiled Java class data, version 51.0  file zh_cn.txt  zh_cn.txt: ISO-8859 text  file ../resource/  ../resource/: directory     档案搜索
 which [-a] whereis [-bmsu] file/dir locate file/dir  搜索自建数据库/var/lib/slocate/，且仅每天建立一次预设 更新 /etc/updatedb.conf 中 DAILY_UPDATE 进行默认建立  find [PATH] [option] [action]  时间相关  -atime/ctime/mtime n  n天前一天之内被访问/改变/修改过的档案  -newer file  比指定文件新的文件等均会被列出   用户群组相关  -uid/gid n  指定用户或群组ID  -user/group  指定用户或群组名称  -nouser/-nogroup  寻找档案拥有者不存在于/etc/passwd或/etc/group中的   档案权限及名称相关  -name filename  搜寻文件名称为 filename 的档案 示例  find -name &amp;quot;slide-rId3*&amp;quot;  寻找前缀为 slide-rId3 的文件    -size [&#43;-]SIZE  搜寻比 SIZE 还要大(&#43;)或小(-)的档案 SIZE 的规格  c 代表 byte k 代表 1024bytes  示例  find -size &#43;50k  找比 50KB 还要大的档案    -type TYPE  搜寻档案的类型为 TYPE 的 类型  f  一般正规档案  b, c  装置档案  d  目录  l  连结档  s  socket  p  FIFO    -perm mode  搜寻档案属性『刚好等于』 mode 的档案，这个 mode 为类似 chmod的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！  -perm -mode  搜寻指定属性的档案 示例  ls -lh | grep &amp;quot;\-rw\-r\-\-r\-\-&amp;quot;  -rw-r--r-- 1 appuser appuser 2 May 2 11:24 chattr-test.dat -rw-r--r-- 1 appuser appuser 1.5M Jan 18 12:08 from.gif -rw-r--r-- 1 appuser appuser 70K Sep 1 2017 no-optimize-slide-rId2.jpg -rw-r--r-- 1 appuser appuser 74K Sep 21 2017 slide-rId2.jpg -rw-r--r-- 1 appuser appuser 83K Sep 21 2017 slide-rId3.jpg -rw-r--r-- 1 appuser appuser 118K Sep 21 2017 slide-rId4.jpg -rw-r--r-- 1 appuser appuser 32K Oct 19 2017 watermark-basic-blue.png  find -perm 644  ./from.gif ./slide-rId3.jpg ./no-optimize-slide-rId2.jpg ./slide-rId2.jpg ./callback/callback-save-to-zip.zip ./watermark-basic-blue.png ./chattr-test.dat ./audio/audio.mp3 ./slide-rId4.jpg    -perm &#43;mode  搜寻档案属性『包含任一 mode 的属性』的档案，举例来说，我们搜寻-rwxr-xr-x ，亦即 -perm &#43;755 时，但一个档案属性为 -rw&amp;mdash;&amp;mdash;-也会被列出来，因为他有 -rw&amp;hellip;. 的属性存在！   额外操作  -exec command  command 为其它指令，-exec 后面可再接额外的指令来处理搜寻到的结果。  -print  将结果打印到屏幕上，这个动作是预设动作！    比较  whereis/locate（速度快，利用数据库，不搜索硬盘）&amp;gt; find（速度慢，操作硬盘）  事例  find / -perm &#43;7000 -exec ls -l {} \;  {} 代表的是由 find 找到的内容
 \; 表示 exec 指令结束     档案压缩和打包  用途与技术
 实现思路  1 byte= 8 bits  相关于每个byte中有8个空格并可选0/1  考虑到1表示时为 0000 0001，相关于7bit为空，压缩便是利用算法用上这些剩余的位置   常见指令
 常见格式  *.Z compress  程序压缩的档案；  *.bz2 bzip2  程序压缩的档案；  *.gz gzip  程序压缩的档案；  *.tar tar  程序打包的数据，并没有压缩过；  *.tar.gz tar  程序打包的档案，其中并且经过 gzip 的压缩 ​    常见指令
 compress [-dcr] file/dir [for -c: toFile/toDir]
 压缩后原文件会被压缩文件替换 参数  -d  用来解压缩的参数，或可直接使用uncompress  -r  可以连同目录下的档案也同时给予压缩呢！  -c  将压缩数据输出成为 standard output (输出到屏幕)，  compress -c man.config &amp;gt; man.config.back.Z     gzip [-cdt#] fileName [for -c: toFileName]
 参数  -c  将压缩的数据输出到屏幕上，可透过数据流重导向来处理  -d  解压缩的参数  -t  可以用来检验一个压缩档的一致性,看看档案有无错误  -#  压缩等级 -1 最快，但是压缩比最差、-9 最慢，但是压缩比最好 预设是 -6    gunzip [-acfhlLnNqrtvV][-s ][file...]
 zcat fileName.gz
 用于读取压缩文件数据内容  bzip2 [-cdz#] fileName [for -c: toFileName]
 bzcat fileName.bz2
 tar [-cxtzjvfpPN] file|dir..
 参数  -c  建立一个压缩档案的参数指令(create 的意思)；  -x  解开一个压缩档案的参数指令！  -t  查看 tarfile 里面的档案 c/x/t 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。  -z  是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？  -j  是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？  -v  压缩的过程中显示档案！这个常用，但不建议用在背景执行过程！  -f  使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成『 tar -zcvPf tfile sfile』才对喔！  -p  使用原档案的原来属性（属性不会依据使用者而变）  -P  可以使用绝对路径来压缩！  -N  比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的档案中！  --exclude FILE  在压缩的过程中，不要将 FILE 打包    示例
 tar -cvf all.tar bzip2.txt compress.txt gzip.text
 将指定文件打包  tar -czvf all.tar.gz bzip2.txt compress.txt gzip.text
 将指定文件打包并以gzip方式压缩  tar -tzvf all.tar.gz  将指定文件拆包  -rw-r--r-- root/root 229 2014-09-29 11:28 bzip2.txt -rw-r--r-- root/root 229 2014-09-29 10:00 compress.txt -rw-r--r-- root/root 229 2014-09-29 10:06 gzip.txt   tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc
 备份 /home, /etc ，但不要 /home/dmtsai   dd if=&amp;quot;input_file&amp;quot; of=&amp;quot;outptu_file&amp;quot; bs=&amp;quot;block_size&amp;quot; count=&amp;quot;number&amp;quot;
 主要用于大文件的备份还原  分区 磁盘 Used盘  参数  if  input file  of  output file  bs  规划的一个 block 的大小 默认 512 bytes  count  多少个 bs 的意思。   示例  dd if=test.gif of=test.gif.iso   cpio -covB &amp;gt; [file|device]
 备份  cpio -icduv &amp;lt; [file|device]
 还原 参数  -o  将数据 copy 输出到档案或装置上  -i  将数据自档案或装置 copy 出来系统当中  -t  查看 cpio 建立的档案或装置的内容  -c  一种较新的 portable format 方式储存  -v  让储存的过程中文件名称可以在屏幕上显示  -B  让预设的 Blocks 可以增加至 5120 bytes 预设是 512 bytes ！这样的好处是可以让大档案的储存速度加快(请参考 i-nodes 的观念)  -d  自动建立目录！由于 cpio 的内容可能不是在同一个目录内，如此的话在反备份的过程会有问题 这个时候加上 -d 的话，就可以自动的将需要的目录建立起来了  -u  自动的将较新的档案覆盖较旧的档案！    示例
 find / -print | cpio -covB &amp;gt; /dev/st0  将所有系统上的数据通通写入磁带机内  cpio -icdvt &amp;lt; /dev/st0 &amp;gt; /tmp/content  查看磁带机内容，并将输出文件名纪录至 /tmp/content     vi文字处理器 功能介绍  Linux 与 Unix 系统中的参数文件几乎都是 ASCII 码的纯文字文件  纯文字文件= 以 ASCII 格式码为主 不论使用什么编辑器均可正常使用   vi使用 模式分类  一般模式
 默认进入模式  编辑模式
 等到您按下『i, I, o, O, a, A, r, R』等字母之后才会进入编辑模式 按「ESC」退出编辑模式  指令列命令模式
 在一般模式当中，输入 : 或 / 或 ?就可以进入该模式 在这个模式当中，可达成 搜寻、读取、存盘、大量取代字符、离开 vi 、显示行号 等动作   补充操作  wq!  权限不对时强制写入  [n] h/j/k/l  光标向左/下/上/右方向移动n个字符  0/$/H/L/[n]G/[n]Enter  移动至行首/行尾/页首/页尾/第n行/向下移动n行  /word或?word  向下或向上搜索word字符串  n/N  重复前一搜索操作或反向搜索  [n]x/X  向后/前删除n/1个字符  [n]dd
 删除游标向下n/1行 ​
一般模式 移动光标  h | ←
 光标向左移动一个字符  j | ↓
 k | ↑
 l | →
 多次移动,例如向下移动 30 行  30j 30↓   n
 输入 n 空格  0
 移动到行首  $
 移动到行尾  H
 移动屏幕中首行  M
 移动到屏幕中间行  L
 移动屏幕末行  G
 移动末行  nG
 移动到第 n 行  gg
 移动首行 等价于 1G  n&amp;lt;Enter&amp;gt;
 光标向下移动 n 行   搜寻与取代  /word
 向光标之下寻找一个字符串名称为 word 的字符串  ?word
 向光标之上寻找一个字符串名称为 word 的字符串。  n
 重复前一个搜寻的动作  N  为『反向』进行前一个搜寻动作   删除、复制与贴上  dG  删除光标所在到最后一行的所有数据  d$  删除游标所在处到该行的最后一个字符  d0  删除游标所在处到该行的最前面一个字符  yy  复制当前行  nyy  复制光标所在的向下 n 行  20yy  复制 20 行    y1G  复制光标所在列到第一列的所有数据  yG  复制光标所在列到最后一列的所有数据  y0  复制光标所在的那个字符到该行行首的所有数据  y$  复制光标所在的那个字符到该行行尾的所有数据  p, P  p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行 示例  目前光标在第 20 行，且已经复制了 10 行数据。  按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。 按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。    J
 将光标所在列与下一列的数据结合成同一列  c
 重复删除多个数据 示例  10cj  向下删除 10 行    u
 复原前一个动作  [Ctrl]&#43;R
 重做上一个动作   指令列命令模式  :w
 将编辑的数据写入硬盘档案中  :w!
 若档案属性为只读时，强制写入该档案。  :q
 离开 vi  :q!
 若曾修改过档案，又不想储存，使用 ! 为强制退出不储存档案。  :wq
 储存后离开，若为 :wq! 则为强制储存后退出  :e!
 将档案还原到最原始的状态  ZZ
 若档案没有更动，则不储存离开，若档案已经经过更动，则储存后离开！  :w [filename]
 将编辑的数据储另存成一个档案  :r [filename]
 在编辑的数据中，读入另一个档案的数据  :n1,n2 w [filename]  将 n1 到 n2 的内容储存成 filename 这个档案  :! command
 暂时离开 vi 到指令列模式下执行 command 的显示结果 示例  :! ls /home  可在 vi 当中察看 /home 底下以 ls 输出的档案信息！    :set nu
 显示行号  :set nonu
 取消行号显示   vim额外功能 区块选择- 多选 常用指令  v
 字符选择，会将光标经过的地方反白选择  V
 行选择，会将光标经过的行反白选择  [Ctrl]&#43;v  区块选择，可以用长方形的方式选择资料  y
 将反白的地方复制起来  d
 将反白的地方删除掉  P
 将复制内容粘贴   多档案编辑 操作指令  vim file1...
 批量打开多个文档 参数  :n
 编辑下一档案  :N
 编辑上一档案  :files
 罗列此次打开的所有文件     多窗口编辑 操作指令  vim file1  参数  :sp file2  将file2加入窗口编辑  [ctrl]&#43;wj/wk
 移到下方/上方窗口     vim环境设定  vi ~/.vimrc  :set hlsearch
 设置搜寻字符串反白  :set backspace=2
 2时使用 backspace 可删除任意字符，为0或1时仅可删除刚输入字符  :set autoindent
 自动缩排设置  :set ruler
 设置右下角状态列说明  :set showmode
 显示状态列，如 --INSERT--  :syntax on
 根据语法显示不同颜色并主动排错    断行区别 区别  DOS  回车换行/ CR LF/ ^M$  Linux
 换行/ LF/ $
查看  cat -A file
转换 dos2unix/unix2dos [-kn] file [newFile]
 参数  -k  保留该档案原本的 mtime 时间格式 (不更新档案上次内容经过修订的时间)  -n  保留原本的旧档，将转换后的内容输出到新档案，如： dos2unix -n old new     BASH SHELL 功能介绍 概念 - 硬件核心 - kernel - 与核心交互工具 - shell - bash - Bourne Again shell，常见shell版本 - shell - [ Shell[ 核心-kernel[ 硬件]]] - 查询系统支持shell版本 - ll /bin/*sh BASH功能 - 命令编修 - 自动记录使用过的指令，其中~/.bash_history存储着前一次登入所执行的指令【有黑客入侵查看到数据库登录等的操作】 - 命令补全 - 输入指令前面部分字符后按[tab]进行自动补全，未自动补全双击[tab]查看所有可执行指令 - 命令别名 - 为命令串自订短命令，alias la=&amp;#39;ls -al&amp;#39;，后续直接使用la查看所有的文件（含隐藏文件） - 工作|前景|背景控制 - shell scripts - 万用字符（*） ​
内建指令  type [-tpa] command
 参数
 -t  当加入 -t 参数时，type 会将 command 以底下这些字眼显示出他的意义： file  表示为外部指令  alias  表示该指令为命令别名所设定的名称  builtin  表示该指令为 bash 内建的指令功能   -p  如果后面接的 command 为指令时，会显示完整文件名(外部指令)或显示为内建指令；  -a
 会将由 PATH 变量定义的路径中，将所有含有 command 的指令都列出来，包含 alias ​
变量功能    yao=yao
 设置变量值  变量与变量内容以=来连结 等号两边不能直接接空格符 变量名称只能是英文字母与数字，但是数字不能是开头字符 若有空格符可以使用双引号 &amp;quot; 或 &#39; 来将变量内容结合起来  双引号内的特殊字符可以保有变量特性 单引号内的特殊字符则仅为一般字符  必要时需要以跳脱字符 \ 来将特殊符号 (如 Enter,$, \,空格符,&#39; 等) 变成一般符号； 由其它的指令提供的信息，可使用 `command` 扩增变量内容  &amp;quot;$PATH&amp;quot;:/home』 以追加内容  将变量变成环境变量  export PATH  建议  大写字符为系统预设变量 自行设定变量可以使用小写字符    echo $yao
 输出变量值  unset yao
 取消变量  quote(`)
 复合指令 ls -l `locate crontab`
 优先执行``中的指令，并将其执行结果作为外部的输入信息 ​
变量用途 应用场景  简化名称
 批量进行名称替换（scripts中）
   环境变量  env  列出目前的 shell 环境下的所有环境变量与其内容  set  显示仅于当前SHELL环境下可用的环境变量及其相关内容  PS1
 提示字符设定 参数  \d  代表日期，格式为 Weekday Month Date，例如 &amp;ldquo;Mon Aug 1&amp;rdquo;  \H  完整的主机名称。举例来说，鸟哥的练习机 linux.dmtsai.tw ，那么这个主机名称就是 linux.dmtsai.tw  \h  仅取主机名称的第一个名字。以上述来讲，就是 linux 而已， .dmtsai.tw 被省略。  \t  显示时间，为 24 小时格式，如： HH:MM:SS  \T  显示时间，12 小时的时间格式！  \A  显示时间，24 小时格式， HH:MM  \u  目前使用者的账号名称；  \v  BASH 的版本信息；  \w  完整的工作目录名称。家目录会以 ~ 取代；  \W  利用 basename 取得工作目录名称，所以仅会列出最后一个目录名。  \#  下达的第几个指令。  \$  提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～   示例  PS1=&#39;[\u@\h \d \t \w]&#39;  [root@localhost 四 10月 23 18:39:26 /data/test]    $$
 本shell的PID  $?
 上一指令的回传值，其中成功执行时为0，否则返回对应错误码  OSTYPE/HOSTTYPE/MACHTYPE
 主机硬件与核心等级 示例 echo $HOSTTYPE
 x86_64  echo $OSTYPE
 linux-gnu  echo $MACHTYPE
 x86_64-redhat-linux-gnu   export
 显示所有的环境变量  locale
 语系档案变量 示例  locale -a  显示所支持的语系    read/array/declare
 read [-pt] variable  参数：  -p  接提示字符  -t  等待秒数   事例  read -p &amp;quot;Please keyin your name: &amp;quot; -t 30 named  提示使用者 30 秒内输入自己的大名，将该输入字符串做成 named 变量  echo $named  输出使用者输入信息    declare [-aixr] variable  参数：  -a  将后面的 variable 定义成为数组 (array)  -i  将后面接的 variable 定义成为整数数字 (integer)  -x  用法与 export 一样，就是将后面的 variable 变成环境变量；  -r  将一个 variable 的变量设定成为 readonly ，该变量不可被更改内容，也不能 unset   事例：  yao=handsome.guy~ declare -x yao declare -r yao unset yao/ yao=1  -bash: yao: readonly variable    array  事例  [root@localhost targz]# var[1]=yao [root@localhost targz]# var[2]=qing [root@localhost targz]# var[3]=ju [root@localhost targz]# echo &amp;quot;${var[1]} ${var[2]} ${var[3]}&amp;quot;  yao qing ju     ulimit [-SHacdflmnpstuv] [配额]
 限制使用者的系统资源 参数  -H  hard limit 严格的设定，必定不能超过设定的值  -S  soft limit 警告的设定，可超但会有警告讯息  -a  列出所有的限制额度  -c  可建立的最大核心档案容量 (core files)  -d  程序数据可使用的最大容量  -f  此 shell 可以建立的最大档案容量 (一般可能设定为 2GB)单位为 Kbytes  -l  可用于锁定 (lock) 的内存量  -p  可用以管线处理 (pipe) 的数量  -t  可使用的最大 CPU 时间 (单位为秒)  -u  单一使用者可以使用的最大程序(process)数量。     ​ - 命令别名设定 - alias - 设置别名 - 事例 - alias la=&#39;ls -al&#39; - 罗列所有别名0 - alias cp=&#39;cp -i&#39; - alias l.=&#39;ls -d .* --color=auto&#39; - alias la=&#39;ls -al&#39; - alias ll=&#39;ls -l --color=auto&#39; - alias ls=&#39;ls --color=auto&#39; - alias mv=&#39;mv -i&#39; - alias rm=&#39;rm -i&#39; - alias which=&#39;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#39;
 history [n|-c|[-raw] histfiles]  显示本次登录所操作过所有指令 参数  n  列出最近的 n 笔命令列表  -c  内容全部消除  -a  新增写入 histfiles，默认为 ~/.bash_history  -r  读取 histfiles  -w  写入 histfiles   !66  执行第66条记录  !al  执行以al开头的命令 ​   /etc/issue
 本机登录时显示的提示信息 参数  \d  本地端时间的日期  \l  显示第几个终端机接口  \m  显示硬件的等级 (i386/i486/i586/i686&amp;hellip;)  \n  显示主机的网络名称  \o  显示 domain name  \r  操作系统的版本 (相当于 uname -r)  \t  显示本地端时间的时间  \s  操作系统的名称  \v  操作系统的版本   事例  文件内容  CentOS release 6.3 (Final) Kernel \r on an \m  显示内容  CentOS release 6.3 (Final) Kernel 2.6.32-279.e16.x86_64 on an x86_64    /etc/motd
 客户端登录后提示信息，内容为文本实际内容   额外功能 变量有效范围 - 当启动一个 shell ，操作系统分配一记忆区块给 shell 使用，此区域之变量可以让子程序存取 - 利用 export 功能，可以让变量的内容写到上述的记忆区块当中(环境变量) - 当加载另一个 shell 时 (亦即启动子程序，而离开原本的父程序了)，子 shell 可以将父 shell 的环境变量所在的记忆区块导入自己的环境变量区块当中 信息读取  param=/data/test/download/targz/redis-2.8.3/src/hahaha.jar  echo ${param##/*/}  hahaha.jar 两个#表示截取掉两个/中间的所有值，以最长长度优先  echo ${param#/*/}  test/download/targz/redis-2.8.3/src/hahaha.jar 单个#表示截取掉两个/中间的所有值，以最短长度优先  echo ${param%%/*}   两个%表示截取掉/后的所有值，以最长长度优先  echo ${param%/*}
 /data/test/download/targz/redis-2.8.3/src 单个%表示截取掉/后的所有值，以最短长度优先   param=/data/test/download/targz/redis-2.8.3/src/test.jar
 echo ${param/test/woca}  /data/woca/download/targz/redis-2.8.3/src/test.jar 替换第一个test字符串  echo ${param//test/woca}
 /data/woca/download/targz/redis-2.8.3/src/woca.jar 替换所有的test字符串 ​
变量设定       变量设定方式 str 没有设定 str 为空字符串 str 已设定非为空字符串     var=${str-expr} var=expr var= var=$str   var=${str:-expr} var=expr var=expr var=$str   var=${str&#43;expr} var=expr var=expr var=expr   var=${str:&#43;expr} var=expr var= var=expr   var=${str=expr} str=expr var=expr str 不变 var= str 不变 var=$str   var=${str:=expr} str=expr var=expr str=expr var=expr str 不变 var=$str   var=${str?expr} expr 输出至 stderr var= var=str   var=${str:?expr} expr 输出至 stderr expr 输出至 stderr var=str    环境设定档  系统设定值  /etc/sysconfig/i18n  语言配置  /etc/bashrc  每一shell用户登录时读取的配置文件  /etc/profile.d/*.sh  针对bash及Cshell的规范数据  /etc/man.config  指定man指令时对应的man page路径   个人设定值
 ~/.bash_profile  个人设定文档，登录时读取，定义个人化的路径和环境变量  ~/.bash_login, ~/.profile  同.bash_profile，但shell启动时优先读bash_profile，找不到时找login，最后才是profile  ~/.bashrc  执行shell script时读取，建议存放命令别人和路径等  ~/.bash_history  用户操作指令记录  ~/.bash_logout  读取顺序
 /etc/profile [/etc/profile.d | /etc/inputrc] [~/.bash_profile | ~/.bash_login | ~/.profile] ~/.bashrc   终端机的环境设定  stty  参数  -a ：将目前所有的 stty 参数列出来  事例  stty -a  speed 38400 baud; rows 71; columns 237; line = 0; intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &amp;lt;undef&amp;gt;; eol2 = &amp;lt;undef&amp;gt;; swtch = &amp;lt;undef&amp;gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0; -parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel - -iutf8 opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke  stty erase ^h  使用 ctrl&#43; h 进行回退    set  参数  -u  预设不启用 若启用后，当使用未设定变量时，会显示错误讯息  -v  预设不启用 若启用后，在讯息被输出前，会先显示讯息的原始内容  -x  预设不启用 若启用后，在指令被执行前，会显示指令内容(前面有 &#43;&#43; 符号)  -h  预设启用 与历史命令有关  -H  预设启用 与历史命令有关  -m  预设启用 与工作管理有关  -B  预设启用 与刮号 [] 的作用有关  -C  预设不启用 若使用 &amp;gt; 等，则若档案存在时，该档案不会被覆盖   事例  echo $-  显示当前所有set设置，如 himBH     异常及处理 -bash: make: command not found  原因  安装为最小化版本，未安装make/vim等常用命令  处理  直接于控制台执行 yum -y install gcc automake autoconf libtool make   应用实例 服务重启 Tomcat部署WAR  使用CRT连接linux cd /usr/local/bin/
 Linux系统软件安装目录  pwd  显示当前目录名
  cd ~  进入当前用户目录  cd ..  返回至上级目录  cd /home/  返回至/ home/目录  cd apache-tomcat-8.0.9/webapps rm -rf ops*  不提示确认框，递归地删除ops开头的文件  rm
 删除  -r
 递归  -f
 不提示确认  o*
 以o开头&amp;gt;rz并选择要上传的文件 其中rz为CRT自带工具，Linux中也需安装相应功能  cd .. cd bin ./shutdown.sh  ./  执行本文件夹中的可执行文件   ./startup.sh  Mule服务重启  /usr/local/bin/mule-standalone-3.5.0/bin ./mule [start|stop|restart]  进行mule项目的开启、关闭或重启操作   关机步骤  sync  将数据同步写入硬盘 Root 角色下使用，保证内存中的缓存数据及时写入硬盘  shutdown  惯用关机指令  reboot,halt,poweroff  重新开机、关机 于关机前均会调用 sync 指令，但为保证数据准备，建议还是自行再次调用 sync 指令保护数据   VI操作 以开发Java程序为例  vi Hello.java i &amp;gt; public class Hello{ public static void main(String[] args){ System.out.println(&amp;ldquo;Hello World!&amp;rdquo;); } }
 ESC
 进入命令模式  wq
 保存后退出同连按两次大写字母Z，输入 q! 则表示只退出不保存  javac Hello.java
 java Hello
  开发C&#43;&#43;程序为例  vi Hello.cpp i &amp;gt; #include int main(){ printf(&amp;ldquo;Hello World!&amp;rdquo;); return 0; } gcc Hello.cpp  用ls查看编译后文件名，默认为a.out  ./a.out  </content>
    </entry>
    
     <entry>
        <title>表情.符号</title>
        <url>http://domain.yqjdcyy.com/post/%E8%A1%A8%E6%83%85.%E7%AC%A6%E5%8F%B7/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>表情</tag>
        </tags>
        <content type="html"> ╮(￣▽￣&amp;rdquo;)╭　(~￣▽￣)~ =￣ω￣= →_→ ←_← (✧≖‿≖) ╮（￣▽￣）╭ ╮（￣﹏￣）╭　╮(￣▽￣)╭ (=^ω^=) 狐狸 ヽ(￣ω￣(￣ω￣(￣ω￣(￣ω￣(￣ω￣〃)ゝ (～o￣▽￣)～o （；￣ェ￣） (=ﾟωﾟ)ﾉ (ლ(￣ε￣ლ) (￣(工)￣) &amp;lt;(￣︶￣)&amp;gt; []~(￣▽￣)~* (￣︶￣)&amp;gt; &amp;lt;(￣︶￣)/ (@口@) Σ(@) (￣￣)&#43; Σ(⊙▽⊙&amp;rdquo;a (@[]@!!) (￣ε(#￣) Σ( ° △ °|||)︴ (￣▽￣)~* (￣▽￣)&amp;rdquo; ╮(╯▽╰)╭ (￣３￣)a ￣▽￣ ╮(╯3╰)╭ ╮(╯╰)╭ o(︶︿︶)o (￣.￣) ..@@|||||.. …(⊙_⊙;)… O__O O_o ＜（￣︶￣）＞ ＼（￣︶￣）／　（￣▽￣）～■□～（￣▽￣） ＜（￣︶￣）＞＜（￣︶￣）＞＜（￣︶￣）＞ 〒▽〒 （╯‵□′）╯︵┴─┴ ┴─┴︵╰（‵□′╰） （╬￣皿￣）＝○＃（￣＃）３￣） ＜( ￣︿￣)︵θ︵θ︵θ︵θ︵☆（＞口＜－） （￣口￣） ≡￣﹏￣≡ （￣ c￣）y▂ξ　（～￣▽￣～）　(&amp;ldquo;▔□▔)/(&amp;ldquo;▔□▔)/(&amp;ldquo;▔□▔)/　(メ▼へ▼)/�{︻┻┳═一 ≡(▔﹏▔)≡
</content>
    </entry>
    
     <entry>
        <title>跟腱炎</title>
        <url>http://domain.yqjdcyy.com/post/%E8%B7%9F%E8%85%B1%E7%82%8E/</url>
        <categories>
          <category>健康</category>
        </categories>
        <tags>
          <tag>养生</tag>
        </tags>
        <content type="html">  跟腱炎 概况  跟腱位于小腿下段，平均有15cm 长，是人体最大最粗壮的肌腱。跑步过程中脚踝的缓冲和扒地动作。
 原因  类型
 过度使用操作（常规原因） 勾脚尖幅度不足  膝盖伸直时，勾脚尖幅度不够，则跟腱过紧，风险增大  脚踝内外翻异常  崴脚等造成内外翻运动过多  绷脚力量弱  绷脚力量不足时，跟腱需承受更大负荷  扁平足  扁平足且足踝力线异常，导致跟腱异常受力    位置
 跟腱腱体上疼痛（距离跟腱止点近端2-6cm） 跟腱止点处疼痛 诊断  跟腱腱体，即跟腱附着于跟骨处（跟腱止点）上方2-6cm处
 跟腱连接跟骨的位置
 跟腱病 | 足跟滑囊炎 | 跟骨Haglund畸形
治疗  康复训练
 安排    动作详解  离心训练（核心）  脚前掌立于台阶，快起(1-2秒)慢落(6-8秒) 下落时脚跟可低于前掌，但以不产生疼痛幅度为准   压网球    快速勾脚    脚踝人工抗阻内外翻     落地缓冲  前脚掌着地过渡至脚后跟落地 落地无声响说明缓冲良好，同时落地后保持单脚稳定2秒   抓毛巾    脚踝稳定性  单脚站立&#43; 睁闭眼    理疗
 低水平激光治疗 离子渗透疗法  拉伸
 4* 4* 30  腿腓肠肌牵拉    小腿浅层腓肠肌站立位牵拉    小腿深层比目鱼肌的牵拉  后脚踩实地面，充分屈膝      参考  困扰我多年的跟腱病是如何康复的？  </content>
    </entry>
    
     <entry>
        <title>SQL.优化</title>
        <url>http://domain.yqjdcyy.com/post/sql.%E4%BC%98%E5%8C%96/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>SQL</tag>
        </tags>
        <content type="html">  特点  SQL为非过程化语言，只需要告诉机器做什么，而不需要指名每一步该怎么做。 SQL语句的输入输出均为同一类型数据对象（记录集），因此可以轻松实现嵌套功能。  优化 TOP-N问题  table  student{sid, sname, sage}  sql sql select sid, sname, sage from ( select rownum temp_no, sid, sname, sage from( select sid, sname, sage from student order by sid ) ) where temp_no between 4 and 6;   恰当使用索引  创建  简单索引= 指定字段值 &#43; ROWID  隐藏字表，而ROWID相当于目录当中的页码   影响  select 查找的字段有索引，加快查找速度 insert 则会减速 delete/update 则加快和减慢的可能性都存在   用case表达式替代多次查询  普通查询  select count(*) &amp;ldquo;below 25&amp;rdquo; from student where sage &amp;lt;= 25; select count(*) &amp;ldquo;between 25 and 30&amp;rdquo; from student where sage &amp;gt;25 and sage &amp;lt;30; select count(*) &amp;ldquo;above 30&amp;rdquo; from student where sage &amp;gt;=30;  case实现 sql select count(case when sage&amp;lt;=25 then 1 else null end) &amp;quot;below 25&amp;quot;, count(case when sage&amp;gt;25 and sage&amp;lt;30 then 1 else null end) &amp;quot;between 25 and 30&amp;quot;, count(case when sage&amp;gt;30 then 1 else null end) &amp;quot;above 30&amp;quot;, from student;   用where子句代替having子句 select * from table group by num having num=1; where num=1 group by num; 多表开发注意事项  正确连接方式
 table
   Table Rows     t1 1000   t2 10   t3 100    顺序
 t2连接到t3，而后将t3连接到t1   尽量使用全称列名
 避免花费时间决定某一列属于哪个表   示例 列转行  table
 material{id（编号）/type（类型）/num（数量）}  sql
select --substr用于从指定字段的指定位置截取指定个数的字符 substr(id, 1, 3) || &amp;#39;-&amp;#39; ||substr(id, 4, 3) || &amp;#39;-&amp;#39; || sbustr(id, 7, 3) &amp;#34;ID&amp;#34;, --decode函数用于吧字段的值按照不同的情况翻译成其他形式的输出，类似于java的switch语句 decode(type, &amp;#39;A&amp;#39;, TO_CHAR(num, &amp;#39;99999&amp;#39;), &amp;#39;&amp;#39;) &amp;#34;甲类型&amp;#34;, --TO_CHAR函数将输入转化为指定格式的文本 decode(type, &amp;#39;B&amp;#39;, TO_CHAR(num, &amp;#39;99999&amp;#39;), &amp;#39;&amp;#39;) &amp;#34;乙类型&amp;#34;, decode(type, &amp;#39;C&amp;#39;, TO_CHAR(num, &amp;#39;99999&amp;#39;), &amp;#39;&amp;#39;) &amp;#34;丙类型&amp;#34;, from material;  关联更新  table
 author{aid（作者编号）/aname（作者姓名）/acountbooks（数量）} work_book{aid（作者编号）/wbname（书籍名称）}  sql
update author aa set acountbooks =( select bs from ( -- 内层嵌套将对应作者著书数量检索出来的sql语句 select count(*) bs, aid naid from work_book wa -- 统计每个作者数量的sql语句 group by wa.aid union --work_book表中不存在的作者的书籍统计量为0 select 0, ab.aid from author ab where ab.aid not in( --检索出同一作者书籍情况 select wc.aid from work_book wc group by wc.aid ) ) where naid = aa.aid );  </content>
    </entry>
    
     <entry>
        <title>Java.Jar</title>
        <url>http://domain.yqjdcyy.com/post/java.jar/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  Package  Create Artifacts
 Open 「Project Structure」    Create Artifacts    Setting     Build Artifacts
     Run  java -jar PDFBox.jar C:\Users\Yao\Desktop\anythingToPPTX\from\sliders.pdf  PDFBox.jar中没有主清单属性   Fix  Open MANIFEST.MF  PDFBox.jar/META-INF/MANIFEST.MF  Add Main-Class  Main-Class: com.yao.main.PDFBoxMain  Save  Reference  主要  How to Create an Executable JAR with Maven idea打包java可执行jar包  补充  A如何打包可运行jar的一个问题 JAR包中的MANIFEST.MF文件详解以及编写规范 Convert Java to EXE — Why, When, When Not and How   </content>
    </entry>
    
     <entry>
        <title>Java.Keyword</title>
        <url>http://domain.yqjdcyy.com/post/java.keyword/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  List Access  private protected public  class, method, variable  abstract class extends implements interface native  The native keyword may be applied to a method to indicate that the method is implemented in a language other then Java. 用于说明该方法为原生函数，由 C|C&#43;&#43; 实现并编译成 DLL 提供给 Java 进行调用  统一由操作系统实现   new static strictfp  strict float point | 精确浮点 确保数值计算均严格遵守 FP-strict 限制，并符合 IEEE-754 规范 保障不会因为不同的硬件平台导致计算结果不一致 可声明于类、接口或方法上  synchronized  The synchronized keyword may be applied to a method or statement block and provides protection for critical sections that should only be executed by one thread at a time. 作用于一个方法或代码块上，以保证同一时刻最多只有一个线程执行该代码  若作用于静态方法，则整个类都会被锁定   transient  The transient keyword may be applied to member variables of a class to indicate that the member variable should not be serialized when the containing class instance is serialized. 实现 Serilizable 接口的对象中，有 transient 修饰的字段，则在自动序列化过程中略过 实现 Externalizable 接口，序列化操作均于 writeExternal 手动序列，则与 transient 修饰无关  volatile
 The volatile keyword may be used to indicate a member variable that may be modified asynchronously by more than one thread. volatile is intended to guarantee that all threads see the same value of the specified variable 使用条件
 对变量的写操作不依赖于当前值 该变量不包含在具有其它变量的公式中
flow   break
 switch
 case
 continue
 default
 switch 的默认处理环节 默认方法，用于添加新的功能至现有库的接口中，以兼容历史版本  java 1.8 新增 如 list.forEach   do
 else
 for
 if
 instanceofinstanceof
 The instanceof keyword is used to determine the class of an object node instanceof TreeNode  node 为 TreeNode或其子类的实例 情况下，均返回 true   return
 while
  package  import package  primitive  boolean byte char double float int long short  error  assert try catch finally throw throws  enumeration  enum  other  super this void  unused  const goto  Reference  官方  Java Language Keywords JavaKeywordReference.pdf List of Java keywords  补充  java native关键字 ava中的strictfp关键字 Java transient关键字使用小记 Java并发编程：volatile关键字解析 Java 8 默认方法（Default Methods）   </content>
    </entry>
    
     <entry>
        <title>Java.Stream</title>
        <url>http://domain.yqjdcyy.com/post/java.stream/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  分类 InputStream  PipedInputStream ObjectInputStream FilterInputStream  DataInputStream PushbackInputstream BufferedInputStream  FileInputStream SequenceInputStream ByteArrayInputStream  OutputStream  PipedOutputStream ObjectOutputStream FilterOutputStream  DataOutputStream BufferedOutputStream PrintStream  FileOutputStream ByteArrayOutputStream  Reader  StringReader PipedReader CharArrayReader InputStreamReader  FileReader  FilterReader  PushbackReader  BufferedReader  LineNumberReader   Writer  StringWriter PipedWriter ChatArrayWriter FilterWriter OutputStreamWriter  FileWriter  BufferedWriter PrintWriter  明细 Interface OutputStream  methods  write(int b) write(byte b[]) write(byte b[], int off, int len) flush() close()   InputStream  methods  read() read(byte b[]) read(byte b[], int off, int len) skip(long n) available() close() synchronized void mark(int readlimit) synchronized void reset()   Reader  params  Object lock  methods  read([char buf[], [int off, int len]]) skip(long n) ready() mark(int readAheadLimit) reset() close()   Writer  params  char[] writeBuffer Object lock  methods  write(int|char[]|string) Writer append(CharSequence csq[, int start, int end]) flush() close()   Stream Piped*Stream  用法  多线程时通过管道进行线程间的通讯  设计  PipedOutputStream  methods  connect(PipedInputStream snk) write(int b) write(byte b[], int off, int len)   PipedInputStream  params  DEFAULT_PIPE_SIZE = 1024 Thread readSide, writeSide;  methods  connect(PipedOutputStream src) receive(int b) receive(byte b[], int off, int len) read() read(byte b[], int off, int len)     Object*Stream  用法  通过文件永久地存储住对象（需支持 Serializable 接口）  设计  ObjectOutputStream  params  BlockDataOutputStream bout HandleTable handles ReplaceTable subs  methods  ObjectOutputStream(OutputStream out) write[Object|Boolean|Short|Char|Int|Long|Double|Bytes|Chars]   ObjectInputStream  params  BlockDataInputStream bin HandleTable handles  methods  ObjectInputStream(InputStream in) read[Object|Boolean|Short|Char|Int|Long|Double|Bytes|Chars]     Filter*Stream  用法  包含其它流，并作为基础的数据源  设计
 BufferedInputStream  methods  synchronized read()  fill()  所有数据被读取情况下，同步变换以填充更多的数据     DataInputStream  methods  DataInputStream(InputStream in) readFully(byte b[]) read[Boolean|Short|Char|Int|Long|Float|Double|Bytes|Line|UTF]   PushbackInputstream  params  byte[] buf int pos  缓冲池，用于存放 unread 数据   methods  PushbackInputStream(InputStream in[, int size= 1]) int read([byte[] b, int off, int len])  优先读取 buf 中数据 读取完成后，再行读取流中的数据  unread(int b) unread(byte[] b[, int off, int len])   BufferedOutputStream
 methods  BufferedOutputStream(OutputStream out) synchronized void write(int b)   DataOutputStream
 methods  DataOutputStream(OutputStream out) synchronized void write(int b) write[Boolean|Short|Char|Int|Long|Float|Double|Bytes|Line|UTF] writeLong(long v)  writeBuffer[0] = (byte)(v &amp;gt;&amp;gt;&amp;gt; 56);  8字节，对应位转换     PrintStream
 characteristic  封装其它流以提供便利输出大量数据的能力 不抛出 IOException，而以内部标志们以记录 自动 flush 数据  params  boolean autoFlush trouble = false  methods  PrintStream(OutputStream out[, boolean autoFlush, String encoding]) checkError() println printf(String format, Object &amp;hellip; args) append(CharSequence csq[, int start, int end])     File*Stream  用法  以流的形式进行文件或文件描述符的操作  支持自动创建文件 文件追加形式  文件已打开情况下，无法进行写操作 读取时推荐用于读取图片等形式数据，若读取文本，推荐使用 FileReader  设计  FileOutputStream  params  FileDescriptor fd FileChannel channel Object closeLock  methods  FileOutputStream(File|String|FileDescriptor[,append=false]) write(int b[, boolean append]) writeBytes(byte b[], int off, int len, boolean append)   FileInputStream  params  FileDescriptor fd FileChannel channel Object closeLock  methods  FileInputStream(File|String|FileDescriptor) read([byte[],[int off, int len]) close()  synchronized (closeLock) {  channel.close(); fd.closeAll(new Closeable() {       ByteArray*Stream  用法  以流的方式，字节数据的后台存储形式进行数据的存取 关闭流时不需要处理 IOException 异常  设计  ByteArrayInputStream  params  byte buf[] int pos int count  methods  ByteArrayInputStream(byte buf[][, int offset, int length]) read([byte b[], int off, int len])   ByteArrayOutputStream  params  byte buf[] int count MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8  methods  ByteArrayOutputStream([int size=32]) write(int b) write(byte b[], int off, int len) synchronized void writeTo(OutputStream out) synchronized byte toByteArray()[] synchronized String toString()     SequenceInputStream  用法  按顺序读取多个初始流，直至最后一个流读取完成  设计  methods  SequenceInputStream(Vector.elements())    *er String*er  用法  字符流，用于处理文本  设计  StringReader  methods  StringReader(String s) read() read(char cbuf[], int off, int len)   StringWriter  params  StringBuffer buf  methods  StringWriter([int initialSize]) toString() getBuffer()     Pipe*er  参见 Stream.Piped  CharArray*er  参见 Steam.CharArray  Buffered*er  用法  更有效率地由字符串、数组和行记录中读取文本  设计
 BufferedReader
 params  Reader in char cb[] int defaultCharBufferSize = 8192  methods  BufferedReader(Reader in[, int sz]) read() String readLine() Stream lines() ready()   LineNumberReader
 params  int lineNumber = 0  methods  LineNumberReader(Reader in[, int sz]) setLineNumber(int lineNumber) getLineNumber() readLine()   BufferedWriter
 params  int defaultCharBufferSize = 8192  methods  BufferedWriter(Writer out[, int sz]) write(String s, int off, int len)  cb[nextChar&#43;&#43;]= (char)c  newLine() flush()  out.write      InputStreamReader  用法  将字节流转换为字符流的桥梁  设计  params  StreamDecoder sd  methods  InputStreamReader(InputStream in[, String charsetName|Charset cs|CharsetDecoder dec])  sd = StreamDecoder.forInputStreamReader(in, this, (String)null);     OutputStreamWriter  用法  将字节流转换为字符流的桥梁  设计  params  StreamDecoder sd  methods  OutputStreamWriter(OutputStream out[, **String charsetName|Charset cs|CharsetDecoder dec])  se = StreamEncoder.forOutputStreamWriter(out, this, (String)null);     FileReader  参见 Stream.FileInput  PrintWriter  用法  格式化地将对象格式化流输出至文本输出流 仅适用于未编码的字节流  设计  params  boolean autoFlush Formatter formatter Writer out  methods  PrintWriter(String丨File [, String csn]) PrintWriter(Writer丨OutputStream [, boolean autoFlush]) print[ln](boolean丨char丨int丨long丨float丨double丨char[]丨String|Object) PrintWriter printf(String format, Object &amp;hellip; args) PrintWriter append(CharSequence csq[, int start, int end]) newLine()    Filter*er  设计  FilterReader  Abstract class for reading filtered character streams.  PushbackReader  extends FilterReader 参考 Stream.Pushback  FilterWriter  Abstract class for writing filtered character stream  ProxyWriter  extends FilterWriter    </content>
    </entry>
    
     <entry>
        <title>IDEA.Java.Version</title>
        <url>http://domain.yqjdcyy.com/post/idea.java.version/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>IDEA</tag>
        </tags>
        <content type="html">  Error  Run  Error:java: Compilation failed: internal java compiler error  Install  Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project thinking-in-java: Compilation failure: Compilation failure: xxxx.java:[26,56] -source 1.5 中不支持 diamond 运算符   Fix IDEA.Setting  Project Structure
 快捷键  Ctrl&#43; Alt&#43; Shift&#43; S  设置  project Setting/ Porject  Project SDK-&amp;gt; 1.8 Project language level-&amp;gt; 8 - Lambdas, type annotation etc.  project Setting/ Modules  choice your error modules Sources/ Language level-&amp;gt; 8 - Lambdas, type annotation etc. Dependencies/ Module SDK-&amp;gt; 1.8   截图       Setting
 快捷键  Ctrl&#43; Alt&#43; S  设置  Build,Execution,Deployment/ Compiler/ Java Compiler  Project bytecode version-&amp;gt; 1.8 Per-module bytecode version  choice your project  Target bytecodes version-&amp;gt; 1.8     截图      Maven.Setting  plugin
&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; or properties
&amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;/properties&amp;gt;  Note  调整完「Project Structure」和「Setting」后，重新调用「Project Structure」会发布「Settings」的配置被 重置为 1.5 版本  Reference  IntelliJ IDEA里Maven默认情况下编译版本为JDK1.5  </content>
    </entry>
    
     <entry>
        <title>Java.&amp;0xff</title>
        <url>http://domain.yqjdcyy.com/post/java.0xff/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  Code  PipedInputStream.receive(int b)  buffer[in&#43;&#43;] = (byte)(b &amp;amp; 0xFF);   Reason 原因  int= 32bits byte= 8bits 截取末 8 bit时，存在将数值位当符号位情况  示例  int-&amp;gt; byte  222 -&amp;gt; -34  222.补码  00000000 00000000 00000000 11011110  截取  11011110  反码  11011101  原码  10100010= -34   解决方案  222* 0xff    Supplement Java 使用 补码 进行数值存储  简化计算机运算，让符号位也参与运算，使计算机设计中只有加法，没有减法 示例  1[00000001] &#43; -1[11111111] = 0[1 00000000]= 0[00000000] 丢弃高位数值   *码  原码  符号位&#43; 数字二进制表示 &#43;7 [00000111] -7 [10000111]  反码  正数时同原码，负数时，符号位不变，其它位数取反 &#43;7 [00000111] -7 [11111000]  补码  正数时同原码，负数时则为反码&#43;1 &#43;7 [00000111] -7 [11111001]   Reference  java中byte转换int时为何与0xff进行与运算 java原码、补码、反码总结 原码, 反码, 补码 详解  </content>
    </entry>
    
     <entry>
        <title>方案.敏感词.DFA</title>
        <url>http://domain.yqjdcyy.com/post/%E6%96%B9%E6%A1%88.%E6%95%8F%E6%84%9F%E8%AF%8D.dfa/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>方案</tag><tag>敏感词</tag>
        </tags>
        <content type="html">  Situation  String.contain | pattern DFA  Theory  词库存储结构     Enviroment  Windows 10 Intel i7-4710MQ 2.5Ghz 16G 内存  Code  algorithm.DFA  Test    Type Duration Remark     Read File 45ms 65K   Fill in map 10ms 5146   check 0ms 10/200/500  match or not   query 0ms 10/200/500  match or not   replace 0~1ms 10/200/500  match or not    Reference  网站敏感词过滤的实现 DFA算法-敏感词过滤 简易敏感词过滤算法  </content>
    </entry>
    
     <entry>
        <title>CSGO.地图</title>
        <url>http://domain.yqjdcyy.com/post/csgo.%E5%9C%B0%E5%9B%BE/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>游戏</tag><tag>CSGO</tag>
        </tags>
        <content type="html">  [TOC]
项目 改准心  地图  Crosshair Generator V2  资源
 https://steamcommunity.com/sharedfiles/filedetails/?id=308490450&amp;amp;searchtext=Crosshair&#43;Generator&#43;V2
投掷物训练  地图
 Training maps (smoke,Molotov,Flash)  资源
 Dolnma *RankSea.com Yesber
预瞄点与投掷物热身训练  地图
 Warmup and Training  资源
 Yesber
瞄准训练  地图
 training_aim_csgo2  资源
 https://steamcommunity.com/sharedfiles/filedetails/?id=213240871&amp;amp;searchtext=training_aim_csgo2
跳跃训练  地图
 Jumps Training  资源
 https://steamcommunity.com/sharedfiles/filedetails/?id=314892291&amp;amp;searchtext=Jumps&#43;Training
瞄准课程  地图
 Aim Course 2  资源
 https://steamcommunity.com/sharedfiles/filedetails/?id=379868494&amp;amp;searchtext=Aim&#43;Course&#43;2
快速路线训练  地图
 Shortcuts  资源
 Yesber
压枪练习  地图
 Recoil Master-Spray Training  资源
 https://steamcommunity.com/sharedfiles/filedetails/?id=419404847&amp;amp;searchtext=Recoil&#43;Master-Spray&#43;Training
综合训练中心  地图
 Training Center 1.5c  资源
 https://steamcommunity.com/sharedfiles/filedetails/?id=353366249&amp;amp;searchtext=Training&#43;Center&#43;1.5c
快速瞄准与反应训练  地图
 Fast Aim/Reflex Training  资源
 https://steamcommunity.com/sharedfiles/filedetails/?id=368026786&amp;amp;searchtext=Fast&#43;Aim%2FReflex&#43;Training   添加  登录 Steam 进入 CS-GO 模块 搜索相应地图、作者名 订阅相关地图 进入 Cs-GO 客户端，创新工厂中即自动下载  参考  视频介绍 Steam.CS-GO  </content>
    </entry>
    
     <entry>
        <title>CSGO.技巧.跳跃</title>
        <url>http://domain.yqjdcyy.com/post/csgo.%E6%8A%80%E5%B7%A7.%E8%B7%B3%E8%B7%83/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>游戏</tag><tag>CSGO</tag><tag>技巧</tag>
        </tags>
        <content type="html">  连跳  W Space&#43; A&#43; 鼠标左摆 落地时&#43; Space&#43; D  跳箱子  正对箱子，Ctrl&#43; Space Ctrl&#43; W  跳远  W Space A&#43; 鼠标左摆 D&#43; 鼠标右摆  参考  CSGO跳跃技巧及操作方法心得详解  </content>
    </entry>
    
     <entry>
        <title>Python.Logging</title>
        <url>http://domain.yqjdcyy.com/post/python.logging/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Python</tag>
        </tags>
        <content type="html">  组成 Logger  作用  日志对外暴露接口  创建
 logger = logging.getLogger(logger_name)
Handler  作用
 将日志内容转至相应文件  类型
 StreamHandler  sh = logging.StreamHandler(stream=None)  FileHandler  fh = logging.FileHandler(filename, mode=&#39;a&#39;, encoding=None, delay=False)  NullHandler
Filter  作用
 将日志内容进行过滤
Formater  作用
 控制日志输出格式  LogRecord.对象
 name  日志记录器名称 不会因 Handler 将其转到其它 Logger 而改变  level  日志级别名称 如INFO、ERROR  pathname  源文件的完整路径名称  lineno  调用处在源文件中行号  msg  日志消息体  args  参数&#43; 日志消息体  exc_info  当前异常信息  func  调用处所在的方法体名称   LogRecord.参数
   Attribute Format Description     asctime %(asctime)s LogRecord创建时间的人为识别格式如2003-07-08 16:49:45,896   created %(created)f LogRecord创建时间的时间戳格式   msecs %(msecs)d LogRecord创建时间的毫秒部分   relativeCreated %(relativeCreated)d LogRecord的已创建时长   pathname %(pathname)s 源文件的完整路径名   filename %(filename)s pathname的文件名部分   module %(module)s filename 的部分   funcName %(funcName)s 调用方法名   levelname %(levelname)s &amp;lsquo;DEBUG&amp;rsquo;, &amp;lsquo;INFO&amp;rsquo;, &amp;lsquo;WARNING&amp;rsquo;, &amp;lsquo;ERROR&amp;rsquo;, &amp;lsquo;CRITICAL&amp;rsquo;   levelno %(levelno)s levelname 的对应数值   lineno %(lineno)d 源文件中报错行所在行的号码   message %(message)s LogRecord.msg &amp;amp; LogRecord.args   name %(name)s 所使用的日志记录器名称   process %(process)d 进程 ID   processName %(processName)d 进程名称   thread %(thread)d 线程 ID   threadName %(threadName)s 线程名称    示例
 logging.basicConfig(format=&amp;quot;%(asctime)-15s %(clientip)s %(user)-8s %(message)s&amp;quot;)    补充 日志级别  明细
   Level Usage Value     NOTSET  0   DEBUG 调试时的信息输出 10   INFO 运行状态、信息输出 20   WARNING 预警消息如磁盘将满，费用不足等 30   ERROR 运行时相关异常消息 40   CRITICAL 运行失败消息 50     配置方法  默认配置 简单配置  logging.basicConfig(filename=&#39;20180411.log&#39;, level=logging.INFO, format=&#39;%(asctime)-15s %(levelname)s %(filename)s \t%(lineno)d \t%(message)s&#39;)  文件配置  logging.config.fileConfig(&amp;quot;path&amp;quot;)  字典配置  logging.config.dictConfig(config)  网络配置  略   流程    示例 代码配置  Code
import logging logger = logging.getLogger(&amp;#39;example&amp;#39;) logger.setLevel(logging.DEBUG) ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) formatter = logging.Formatter(&amp;#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&amp;#39;) ch.setFormatter(formatter) logger.addHandler(ch) logger.debug(&amp;#39;debug message&amp;#39;) logger.info(&amp;#39;info message&amp;#39;) logger.warn(&amp;#39;warn message&amp;#39;) logger.error(&amp;#39;error message&amp;#39;) logger.critical(&amp;#39;critical message&amp;#39;) Output
2005-03-19 15:10:26,618 - example - DEBUG - debug message 2005-03-19 15:10:26,620 - example - INFO - info message 2005-03-19 15:10:26,695 - example - WARNING - warn message 2005-03-19 15:10:26,697 - example - ERROR - error message 2005-03-19 15:10:26,773 - example - CRITICAL - critical message  配置文件  Config
 logging.conf ``` [loggers] keys=root,user  [handlers] keys=consoleHandler,fileHandler
[formatters] keys=formatter
[logger_root] level=WARN handlers=consoleHandler
[logger_user] level=DEBUG handlers=fileHandler qualname=user propagate=0
[handler_consoleHandler] class=StreamHandler level=DEBUG formatter=formatter args=(sys.stdout,)
[handler_fileHandler] class=FileHandler level=DEBUG formatter=formatter args=(&amp;lsquo;file-conf.log&amp;rsquo;,)
[formatter_formatter] format=%(asctime)s\t%(levelname)s\t%(message)s datefmt=
- logging.yqml version: 1 formatters: simple: format: &amp;lsquo;%(asctime)s - %(name)s - %(levelname)s - %(message)s&amp;rsquo; handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdout loggers: simpleExample: level: DEBUG handlers: [console] propagate: no root: level: DEBUG handlers: [console] ```
 Code
import logging import logging.config logging.config.fileConfig(&amp;#34;logging.conf&amp;#34;) default = logging.getLogger() default.debug(&amp;#34;File\tDefault\tdebug&amp;#34;) default.info(&amp;#34;File\tDefault\tinfo&amp;#34;) default.warn(&amp;#34;File\tDefault\twarn&amp;#34;) default.error(&amp;#34;File\tDefault\terror&amp;#34;) default.critical(&amp;#34;File\tDefault\tcritical&amp;#34;) user = logging.getLogger(&amp;#34;user&amp;#34;) user.debug(&amp;#34;File\tUser\tdebug&amp;#34;) user.info(&amp;#34;File\tUser\tinfo&amp;#34;) user.warn(&amp;#34;File\tUser\twarn&amp;#34;) user.error(&amp;#34;File\tUser\terror&amp;#34;) user.critical(&amp;#34;File\tUser\tcritical&amp;#34;) Output
 同代码配置模块输出   对象配置  Code
import logging import logging.config DEFAULT_LOGGING = { &amp;#39;version&amp;#39;: 1, &amp;#39;disable_existing_loggers&amp;#39;: False, &amp;#39;loggers&amp;#39;: { &amp;#39;&amp;#39;: { &amp;#39;level&amp;#39;: &amp;#39;INFO&amp;#39;, }, &amp;#39;another.module&amp;#39;: { &amp;#39;level&amp;#39;: &amp;#39;DEBUG&amp;#39;, }, } } logging.config.dictConfig(DEFAULT_LOGGING) logging.info(&amp;#39;Hello, log&amp;#39;) Detail
{ &amp;#39;version&amp;#39;: 1, &amp;#39;disable_existing_loggers&amp;#39;: False, &amp;#39;formatters&amp;#39;: { &amp;#39;standard&amp;#39;: { &amp;#39;format&amp;#39;: &amp;#39;%(asctime)s [%(levelname)s] %(name)s: %(message)s&amp;#39; }, }, &amp;#39;handlers&amp;#39;: { &amp;#39;default&amp;#39;: { &amp;#39;level&amp;#39;: &amp;#39;INFO&amp;#39;, &amp;#39;formatter&amp;#39;: &amp;#39;standard&amp;#39;, &amp;#39;class&amp;#39;: &amp;#39;logging.StreamHandler&amp;#39;, }, }, &amp;#39;loggers&amp;#39;: { &amp;#39;&amp;#39;: { &amp;#39;handlers&amp;#39;: [&amp;#39;default&amp;#39;], &amp;#39;level&amp;#39;: &amp;#39;INFO&amp;#39;, &amp;#39;propagate&amp;#39;: True }, &amp;#39;django.request&amp;#39;: { &amp;#39;handlers&amp;#39;: [&amp;#39;default&amp;#39;], &amp;#39;level&amp;#39;: &amp;#39;WARN&amp;#39;, &amp;#39;propagate&amp;#39;: False }, } }  参考 官方  Logging HOWTO Formatter Objects LogRecord attributes  整理  python logging模块使用教程 日志（Logging）  配置  Configuration file format How to use logging with python&amp;rsquo;s fileConfig  YAML  官网 How to install pyYAML on windows 10 Unofficial Windows Binaries for Python Extension Packages  </content>
    </entry>
    
     <entry>
        <title>厦门软件园公寓租赁</title>
        <url>http://domain.yqjdcyy.com/post/%E5%8E%A6%E9%97%A8%E8%BD%AF%E4%BB%B6%E5%9B%AD%E5%85%AC%E5%AF%93%E7%A7%9F%E8%B5%81/</url>
        <categories>
          <category>一切按计划进行</category>
        </categories>
        <tags>
          <tag>租房</tag>
        </tags>
        <content type="html">  背景  要换房子，时值出差至北京「朋友A」所申请的一室一厅正好刚要被通过  考虑到大学舍友，关系好，在一起也便于互相照应 而政策允许最多有两个同住人 后面每年只要「朋友A」每年再提供一次公司在职证明、公司营业执照  情况稳定，不会像现在会有房东突然要求解约、涨房租情况  授权委托本人进行处理即可   结果  「朋友A」仅可单独申请，不允许添加同住人  虽然手续齐全 驳回原因为「审核人男」觉得一室一厅中住两男一女不适合  人为审核，不同意就没办法   后续处理  原房子四月中旬到期，现需赶紧重新找房子  很可惜，等待审批过程中有看到几套有阳台厨房的，但因为手续已在申办而放弃  考虑于建议板块提交代办流程和相关手续整理资料 考虑于投诉板块进行投诉   流程 申诉  2016.6.24  提交申请  2018.3.17  确认申请情况  2018.3.21  短信通知已取消 上官网查看为未接电话，已取消 手机确认无未接来电 上官网投诉，并拨打客服电话（0592-2950000）进行确认 申诉成功，等待月底别人退房后看房   看房  时间  3.27号通知看房 3.28 16:00 前回复  信息  东门-71号-501 一室一厅 1430元/月  补充  东门-73号 前台说看房，报房号取钥匙 户型特点  优点  一室一厅，面积很大 三个墙面大小的窗户，采光极好  缺点  无阳台、无厨房 家具全无，需要自行打理（已知） 本栋类似 SOHO，商住两用     手续  押一付六  1430* 7= 10,010  申请一
 时间节点  3.30号前  手续  「朋友A」  向公司申请 身份证复印件 授权委托函  「朋友B」  代拿  在职证明复印件 营业执照复印件    申办  73号楼前台告知需要先要到33号楼4层信息集团办理手续 「审核人女」  告知授权委托函需要体现委托人和被委托人的签名、手印 需要一并提交同住人的身份证复印件    申请二
 时间节点  4.2号前  手续  授权委托函需要委托人和被委托人的签名、手印 「朋友A」  授权委托书格式更换 授权委托函中委托人签名、手印 快递给「同住人男」  「同住人男」  授权委托函中被委托人签名、手印 身份证复印件  「同住人女」  身份证复印件   申办  「审核人男」  表示「朋友A」在北京出差时间大半年，怀疑有转租嫌疑 需要「审核人女」回来由她通过，他不处理 询问确认手续均已齐全    阶段三
 时间结点  4.4早上  手续  上次已确认齐全  授权委托函数  需要包含委托人、被委托人的签名和手印  申请人在职证明 申请人公司职业执照 申请人身份证复印件 申请人居住证复印件  申请人为厦门户口，略  同住人身份证复印件   申办  重新找「审核人女」申办，但未上班，转「审核人男」 「审核人男」仍拒绝，但电话与「审核人女」沟通后，代为处理 「审核人男」开始审核确认「朋友A」的资质、出差情况 得知出差频繁，可能觉得是转租，开始以其它理由拒绝  最后拒绝的理由是一室一厅住两男一女不合适  但手续齐全 最多可入两同住人 以上理由并不能接受   最后告知，「朋友A」要办理可以，但只可以由他个人租赁，不允许办理同住人    规划  房屋面积量划 排布设计  准备 大扫除 消菌杀毒 购置  家具  床 衣柜 沙发 屏风 窗帘  电器
 热水器 空调 洗衣机  其它
 宽带 酒精 浇花瓶   搬家 </content>
    </entry>
    
     <entry>
        <title>License.Choose</title>
        <url>http://domain.yqjdcyy.com/post/license.choose/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>License</tag>
        </tags>
        <content type="html">  作用 计算机软件的版权许可协议，其使源代码可用在允许修改和重分发而不要向原始创建者付费的条件下 开源许可证是一种法律许可。通过它，版权拥有人明确允许，用户可以免费地使用、修改、共享版权软件。 版权法默认禁止共享，也就是说，没有许可证的软件，就等同于保留版权，虽然开源了，用户只能看看源码，不能用，一用就会侵犯版权。所以软件开源的话，必须明确地授予用户开源许可证。
简诉    类型 MIT  历史  名源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称「X许可协议」（X License）或「X11许可协议」(X11 License）  声明
The MIT License (MIT) Copyright (c) [year] [copyright holders] Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 使用
 可以任意使用、拷贝和修改软件。 可以免费分发或出售软件，分发软件的方式不受限制。 唯一的限制是软件必须包含该许可协议的声明。  项目
 jQuery Rails Lua PuTTY Bitcoin   BSD  历史  修订版 BSD 许可协议（The BSD 3-Clause License / New BSD License / Modified BSD License) 简版 BSD 许可协议（The BSD 2-Clause License / Simplified BSD License / FreeBSD License）  声明
Copyright (c) [YEAR], [OWNER] All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 使用
 可以任意使用、拷贝和修改软件。 可以免费分发软件或者出售软件，分发软件的方式不受限制。 软件必须包含该许可协议的声明。 未获书面许可，不能使用软件贡献者的名称来为软件的衍生产品做任何表示支持、认可或推广、促销之行为。  BSD3 较 BSD2 多的条款   项目
 Go OpenSSH V8（JavaScript引擎） Tengine   GPL  历史  GNU 通用公共许可协议（GNU General Public License）  GPL-2.0 GPL-3.0   声明
GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. &amp;lt;http://fsf.org/&amp;gt; Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. ........... 详见 [GNU General Public License v3.0](https://choosealicense.com/licenses/gpl-3.0) 使用
 可以任意使用、拷贝和修改软件。 可以免费分发软件或者出售软件，分发软件的方式不受限制。 不允许修改后和衍生的代码做为闭源的商业软件发布和销售。 只要在一个软件中使用(「使用」指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用 GPL 协议，既必须也是开源和免费  传染性  不适用商业软件、对代码有保密要求的人    项目
 Linux Git WordPress    LGPL  历史  GNU 宽通用公共许可证（GNU Lesser General Public License）  由自由软件基金会公布的自由软件授权条款  流行版本  V2.1 V3
   声明  详见「参考 - 官方」中的 「GNU Lesser General Public License, version 2.1」和「GNU Lesser General Public License」  使用  如果对遵循 LGPL 的软件进行任何改动和/或再次开发并予以发布，则产品必须继承 LGPL 协议，不允许封闭源代码。 但是如果程序只是对遵循 LGPL 的软件进行任何连接、调用而不是包含，则允许封闭源代码。  项目  Qt    Apache  历史  Apache 许可协议（Apache License） 授予用户适用于版权和专利权的权利  声明  详见 [Apache License 2.0](https://choosealicense.com/licenses/apache-2.0)  使用  权利  权利的永久性  一旦许可证被授予，就可以无限期使用。  权利的世界性  如果许可证在某一国授予，那么它同时也授予给其它所有国家。  获取权利的免费性  不用预先支付任何使用费，也不用为每次使用或基于其它方式而付费。  权利的非排他性  任何人都能使用经授权的软件。  权利的不可撤回性  权利一旦授予，无人能撤回。   义务  如果修改了代码，需要在被修改的文件中说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。  你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。    项目  Apache SVN NuGet    添加  添加新文件，名称为「LICENSE | LICENSE.md」 选择并填充某种「license」模板 确认并提交  参考  作用  如何选择开源许可证？ 开源许可证教程 如何选择和使用开源许可协议 Various Licenses and Comments about Them  明细  Github.Choose license MIT License  示例  whiteplain/LICENSE angular.js/LICENSE  添加  Licensing a repository  Applying a license to a repository with an existing license  Adding a license to a repository  官方  GNU Operating System GNU General Public License, version 2 http://www.gnu.org/licenses/gpl-3.0.en.html GNU Lesser General Public License, version 2.1 GNU Lesser General Public License Apache License   </content>
    </entry>
    
     <entry>
        <title>Python.Conda</title>
        <url>http://domain.yqjdcyy.com/post/python.conda/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Python</tag><tag>Conda</tag>
        </tags>
        <content type="html">  作用  用于科学计算的Python发行版 提供了包管理与环境管理的功能 方便地解决多版本python并存、切换以及各种第三方包安装问题  分类  conda  工具 提供包管理和环境管理 将所有工具、第三方包、python 和 conda自身均当成 package 对待  Anaconda  打包集合  预装 conda 特地版本 python 众多 apckages 科学计算工具   Miniconda  基础版本  仅包含 python 与 conda    安装  参考  Installation—Conda documentation Installing on Windows  确认      指令 环境管理  新增  conda create -n &amp;lt;env_name&amp;gt; &amp;lt;package_names|python[=version]&amp;gt;  删除  conda env remove -n &amp;lt;env_name&amp;gt;  列表  conda env list  进入  Windows  activate &amp;lt;env_name&amp;gt;  OSX | Linux  source activate &amp;lt;env_name&amp;gt;   退出  Windows  deactivate  OSX | Linux  source deactivate   导出配置  conda env export &amp;gt; &amp;lt;/path/environment.yaml&amp;gt;  引入配置  conda env update -f=/path/environment.yml   包管理  安装  conda install [-n &amp;lt;env_name&amp;gt;] &amp;lt;package_name[=&amp;lt;version&amp;gt;]&amp;gt;  卸载  conda remove [-n &amp;lt;env_name&amp;gt;] &amp;lt;package_names&amp;gt;  更新  conda upgrade [-n &amp;lt;env_name&amp;gt;] &amp;lt;package_names&amp;gt; conda upgrade [-n &amp;lt;env_name&amp;gt;] --all conda upgrade [-n &amp;lt;env_name&amp;gt;] [python|conda|anaconda]  列表  conda list   镜像管理  添加   示例  添加「清华TUNA」镜像源至仓库 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes    补充  PIP 导出导入配置  pip freeze &amp;gt; &amp;lt;environment.txt&amp;gt; pip install -r &amp;lt;/path/requirements.txt&amp;gt;   参考  安装  Installation—Conda documentation Installing on Windows  使用  Getting started with Anaconda Python for Visual Studio Code Anaconda使用总结 Conda Anaconda Distribution  指令  初学python者自学anaconda的正确姿势是什么？？ Conda工具使用  补充  pip freeze   </content>
    </entry>
    
     <entry>
        <title>Python.__main__</title>
        <url>http://domain.yqjdcyy.com/post/python.__mian__/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Python</tag>
        </tags>
        <content type="html">  参考  Python 中 name == &amp;lsquo;main&amp;rsquo; 的作用 if name == &amp;lsquo;main&amp;rsquo; 如何正确理解?  作用  保障模块既可以被导入，也可作为脚本来执行  直接运行时，模块名为 main，因为对应代码块可被运行 导入时，代码块不执行   </content>
    </entry>
    
     <entry>
        <title>竞标-厦大海洋学院</title>
        <url>http://domain.yqjdcyy.com/post/%E7%AB%9E%E6%A0%87-%E5%8E%A6%E5%A4%A7%E6%B5%B7%E6%B4%8B%E5%AD%A6%E9%99%A2/</url>
        <categories>
          <category>工作</category>
        </categories>
        <tags>
          <tag>商业</tag>
        </tags>
        <content type="html">  动态效果  http://pubg.qq.com/  整屏滚动  js  swiper   丰富防具  CSS  丰富的天气和地形  天气和地形切换  js&#43; css  鼠标移动，着重显示对应明细  css   瞬息万变 策略为王  呼吸状白圈&#43;号  css3  鼠标移动至白&#43;时，浮现提示  css    http://www.mazda.com.cn/cars/mx-5#1 http://consumer.huawei.com/cn/phones/mate10/ https://www.dji.com/cn https://loudsrl.com/our-projects https://conference.awwwards.com/san-francisco  适合展示老师、历史节点  http://www.uunn.cn/  首屏  上层文字透明底 下层视频  设计尝试  切换  js  动物动画  svg   响应式设计  框中内容上下浮动切换  css     静态布局  https://www.apple.com/cn/iphone-x/ https://www.mi.com/mix2/ http://www.yunkai.com/ https://www.beatsbydre.com  相关 协会 中国航海学会 中国航海博物馆
机关 上海海事局 江苏海事局 浙江海事局
学校  厦门大学海洋与地球学院 上海海事大学  商船学院 上海高级国际航运学院  大连海事大学  航海学院   资源 网站  https://www.awwwards.com/websites/ https://www.behance.net/ https://reeoo.com/ http://www.webdesignfile.com/  图片  免费高清图片 堆糖 500px 站酷 花瓣 pexels stokpic visualhunt Unsplash Beautiful free stock photos Magdeleine dribbble  </content>
    </entry>
    
     <entry>
        <title>庄家杜均</title>
        <url>http://domain.yqjdcyy.com/post/%E5%BA%84%E5%AE%B6%E6%9D%9C%E5%9D%87/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>商业</tag><tag>比特币</tag>
        </tags>
        <content type="html">  【深度调查】 庄家杜均 时间点 2013.7  杜均从腾讯辞职，与李林等人联合创立数字货币交易所——火币网。 昔日的领导戴志康则成了火币网的天使投资人。  2013.11  火币网上线，打出了“免交易手续费”的旗号  发展壮大后，连同国内几大交易所重新开始收取手续费，甚至开始向项目收取巨额的ICO“上币费”   2014  杜均创办了区块链代币媒体“金色财经” 杜均募集了自己的基金”节点资本”  2017.9  中国的监管机构下令禁止境内的ICO（首次代币发行，是用区块链把使用权和加密货币合二为一，来为开发、维护、交换相关产品或者服务的项目进融资的方式）交易，并陆续屏蔽境外ICO交易平台的域名。  2017.12  代币“WAX”登录“火币Pro”交易所后，狂跌99%的惨烈景象 IOST（Internet of Service Token）的区块链项目正在筹划ICO，募资数额巨大 每个币种登录火币Pro开始交易后，开放充值和提现的间隔时间越来越长  2018.1  包括杜均在内，币圈主要人物已经被限制出境  2018.2.15  名为“三点钟无眠区块链”的微信群横空出世，在各种区块链微信群里呼风唤雨的，是薛蛮子、徐小平、蔡文胜和王峰这样的传统天使风险投资人。  2018.3.3  全国政协十三届一次会议开幕，中国进入“两会时期”。  火币网公众号更名为 “huobicom” OKEx公众号被封号   关键点 杜均  重庆开县人，1986年出生 初中期间，杜均曾靠打游戏卖装备、建站赚广告费谋生，是早年间国内互联网野蛮生长时代孕育的无数- 个人站长之一。 凭借常年混迹互联网圈积累的经验和圈子，杜均成功进入知名企业家和天使投资人戴志康创立的康盛创想，在旗下Discuz!担任产品设计相关职务。 康盛创想于2010年被腾讯全资收购，只有高中文凭的杜均得以进入中国最大的互联网公司工作。  IOST  “空气币” “IOST”项目团队与真格基金投资的“多拉打印”团队在人员上高度重合， “IOST”是由火币网旗下Huobi Labs孵化的项目。 火币网是其主要投资方，也是联合首发的交易所，而杜均是火币网的联合创始人、独立董事和股东。 “IOST”和另一个项目“DATA”的共同投资方还有一家叫“节点资本”的机构，该机构专注区块链领域投资，杜均也是节点资本的创始合伙人。 “IOST”在一家区块链垂直媒体——“金色财经”上，曾被积极推荐，而“金色财经”的实际控制人，又是杜均。  火币&#43;金色财经&#43;节点   组成  杜均、火币网和金色财经之间为交叉持股关系，在公司层面是典型的利益关联方  评价  如果以股票市场作比，杜均是一个身兼承销商、证券媒体以及坐市商三大角色于一体的“超级庄家”  流程  用“节点资本”投资早期项目 项目ICO后登陆自己持股的交易所 手上的媒体资源又可以为项目“保驾护航”  项目  节点资本的投资组合里，其中有一半项目完成了ICO，包括炒币者们耳熟能详的Gerano Network、IOST、YEE和aelf等项目。   “WAX”爆跌  经过  2017年12月，一家叫做OPSkins的游戏虚拟资产交易平台宣布ICO，公开发行自己的代币WAX（Worldwide Asset Exchange）。按照原定计划，WAX将在2017年12月20日在火币Pro上线交易。 正式上币的2天前，WAX项目团队突然在Twitter和Medium等社交网络上发出通知：将代币数量拆分，增发至原有10倍，币价瞬间贬值至原价的一成。 但火币Pro在20日却仍以原价格上线WAX，这使许多没有看到通知的散户投资者，在不知情的状况下以原价买入。不出所料，WAX上线后币价旋即跌去99%，大量投资者被套牢。  疑点  WAX在上线前至少2-3天即在Twitter上宣布增发，并于12月19日在Medium上发表公告宣布此事。  而作为WAX唯一且首发的交易所，火币Pro称对此完全不知情，团队在上币前两天与项目方没有任何信息沟通。  WAX是由OPSkins这一项目的团队发行的，该项目上线于2016年，自称全球领先的虚拟游戏装备交易平台。  但Google、维基百科、Steam社区以及各种公开资料中，这个交易平台的信息甚少。  节点资本恰好是WAX的投资者。  WAX是OPSkins团队的代币项目，杜均进入WAX的方式很可能只是公开交易前的私募阶段。 火币网的独立董事及股东之一杜均，作为项目的私募投资方，竟然也不知道WAX要1:10拆币的消息，或者是知情，但没有跟火币网的任何人进行沟通。    币市场  特点  盘面的指标与股票市场基本一致  分析工具  佳庆资金流量  Chaikin Money Flow，简称CMF 股票市场常用分析工具，它用于描述一支股票的强弱状态。 CMF会随着股价缓缓上升，股价下跌CMF也会跟着下跌。当CMF指标大于0时，市场向好，反之则向坏。波动越大，买入/卖出的压力越大。 在同一时间点，CMF如果与价格呈相反状态（如价格上涨CMF下跌），就意味着行情的转变。  成交量摆荡  用曲线方式展示交易量的工具，短期成交量高于长期平均成交量时曲线为正，反之则为负，用来描述交易量的短期变化。   示例  CMF和成交量摆荡同时拉高，在币价达到最高点之前达到顶点并出现向下信号，意味着行情反转，庄家开始出货；
 CMF从0线以下向上抬升、成交量摆荡出现异常波动，但价格未有相应明显变化，说明庄家正在吸货； CMF弱于0线、成交量摆荡波动小，同时价格也趋于平稳，说明此时市场上大额资金很少，主要是散户在博弈； 成交量摆荡大幅波动，CMF和币价却没有出现相应的大幅波动，说明市场上存在大量对敲交易（左手倒右手），这是典型的操纵价格现象。   操作  在项目的私募阶段，基石投资者、早鸟投资者以及其他早期投资者分别用一定折扣认购代币份额，拿到大份额的承销商则会向下分发，帮助散户代投赚取差价。
 多数项目ICO时只有团队和白皮书，没有实体业务和资产，因此需要靠币圈大佬站台，知名人士作为顾问，以及私募投资者和承销商做销售背书，才能获得投资者的关注和信任，并认购份额。  2018年初，币圈名人“宝二爷”（郭宏才）在一次行业分享中说：自己为项目做顾问站台的收费标准是 1% 的待发代币，前不久在美国给几个项目“云站台”就净赚500万美元。  币圈的“控盘者”主要是项目团队本身、机构投资者和交易所三拨人  释放消息拉盘砸盘 掌握筹码对倒操纵价格 震荡洗盘 拉升股价后高位抛货   </content>
    </entry>
    
     <entry>
        <title>CSGO.脚本</title>
        <url>http://domain.yqjdcyy.com/post/csgo.%E8%84%9A%E6%9C%AC/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>游戏</tag><tag>CSGO</tag><tag>脚本</tag>
        </tags>
        <content type="html">  设置项  CSGO详细参数.md  脚本 示例  单人模式  single.cfg  sv_cheats 1 bot_kick sv_infinite_ammo 1 noclip bind &amp;quot;H&amp;quot; &amp;quot;noclip&amp;quot; mp_startmoney &amp;quot;16000&amp;quot; sv_grenade_trajectory &amp;quot;1&amp;quot; sv_grenade_trajectory_time &amp;quot;20&amp;quot; sv_grenade_trajectory_dash &amp;quot;0&amp;quot; sv_grenade_trajectory_thickness &amp;quot;1&amp;quot; sv_grenade_trajectory_time_spectator &amp;quot;1&amp;quot; sv_showimpacts 1 sv_showimpacts_time 25 mp_roundtime 99 mp_timelimit &amp;quot;999&amp;quot; mp_freezetime &amp;quot;0&amp;quot; mp_buy_anywhere &amp;quot;1&amp;quot; mp_buytime 9999 bind &amp;quot;k&amp;quot; &amp;quot;bot_add_ct&amp;quot; bind &amp;quot;l&amp;quot; &amp;quot;bot_add_t&amp;quot; bot_zombie &amp;quot;0&amp;quot;  备注  目前尝试无效项 冻结时间取消 金钱设置 回合时长    开启开发者控制台  「游戏设置选项」  「游戏设置」  「启用开发者控制台」    执行  将 single.cfg 拷贝至 Steam\steamapps\common\Counter-Strike Global Offensive\csgo\cfg 文件夹下 开启游戏时，在命令行中输入的执行 exec single.cfg  参考  CS:GO一鍵買槍，常規參數，網絡參數配置文件 CSGO常用脚本及设置方法（附打包下载 CSGO 单机测试指令 CSGO怎么调出控制台?  </content>
    </entry>
    
     <entry>
        <title>JWT</title>
        <url>http://domain.yqjdcyy.com/post/jwt/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>JWT</tag>
        </tags>
        <content type="html">  定义 Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 实现  组成  header.playload.signature header  typ  声明类型  alg  加密算法  RSA1_5 HS256    playload  组成  Registered Claim Names  iss  Issuer 该 JWT 的签发者 可选项，大小写敏感  sub  Subject 该JWT所面向的用户，局部上下文或全局唯一 可选项，大小写敏感  aud  Audience 接收该 JWT 的一方，指定应用方 可选项，大小写敏感  exp  Expiration Time 过期时间，Unix时间戳 可选项  nbf  Not Before 起始可用时间，Unix时间戳  iat  Issued At 标记签发时间，Unix时间戳 可选项  jti  JWT ID 可选项   Public Claim Names  可添加任意信息  常用于培养出用户、业务相关信息 不建议添加敏感信息   Private Claim Names  提供者和消费者的共同声明    signature  encrypt(base64(header)&#43; &amp;lsquo;.&amp;rsquo;&#43; base64(playload), 私钥)   流程事例  生成 header  填充 header  { &#39;typ&#39;: &#39;JWT&#39;, &#39;alg&#39;: &#39;HS256&#39; }  对 header 进行 base64 加密  eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9   生成 playload  填充 playload  { &amp;quot;iss&amp;quot;: &amp;quot;joe&amp;quot;, &amp;quot;exp&amp;quot;: 1300819380, &amp;quot;http://example.com/is_root&amp;quot;: true }  对 playload 进行 base64 加密  eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9   生成 signature  拼接  {header}&#43; {playload} eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9  加密算法计算  HS256({header}&#43; {playload}, 私钥) TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ   结果  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ    应用 fetch(&amp;#39;api/user/1&amp;#39;, { headers: { &amp;#39;Authorization&amp;#39;: &amp;#39;Bearer &amp;#39; &#43; token } })    优点  跨语言支持 无需在服务端保存会话，易于应用扩展 字节占用小，便于传输  对比  session 认证  实现  登录后将相关信息保存于 cookie 中，便于下次请求时服务器的识别认证  缺点  服务器开销  认证后均需于服务端记录（内存等），增加服务器开销  扩展性  cookie 仅于当前服务器有效，分页性扩展差  可通过 redis 等公用服务支持   CSRF  跨站请求伪造 cookie 被截获，受到跨站请求伪造攻击    token 鉴权  流程  用户使用账号、密码登录 服务器验证用户信息 验证通过后返回给用户以 token 客户端存储 token，并于请求时附上 服务端验证 token 并处理请求  补充  服务端需支持 CORS （跨域资源共享）  配置 Access-Control-Allow-Origin: *     适用场景  一次性认证  参考  jwt 官网 JSON Web Token - 在Web应用间安全地传递信息 什么是 JWT &amp;ndash; JSON WEB TOKEN dgrijalva/jwt-go SermoDigital/jose JSON Web Token (JWT) draft-ietf-oauth-json-web-token-32 Example JWT 讲真，别再使用JWT了 Go实战&amp;ndash;golang中使用JWT(JSON Web Token)  </content>
    </entry>
    
     <entry>
        <title>洋酒入门</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B4%8B%E9%85%92.%E5%85%A5%E9%97%A8/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>酒</tag>
        </tags>
        <content type="html">  洋酒.入门 单一麦芽 The Singleton of Dufftown 12 YO  名称  苏格登达夫镇12年单一麦芽  特征  清淡的鲜花、水果、坚果、香草味，容易入口 销量高  价位  320元  图示     Glen Moray Classic  名称  格兰莫雷经典单一麦芽  特征  以味道清淡著称，清淡而不单调，有着丰富的韵味 最便宜的单一麦芽之一  价位  400元  图示     The Glenlivet 12 YO  名称  格兰威特12年单一麦芽  特征  12年平衡性最佳  价位  300元  图示     Hakushu 12 YO  名称  白州12年单一麦芽  特征  清新的香气，淡而不简单，余韵稍欠  价位  330元  图示     调和威士忌 Famous Grouse  名称  三得利老威士忌  价位  100元  图示     Jameson  名称  尊美醇爱尔兰威士忌  特征  单纯的清淡 仅建议从调和威士忌入门时饮用  价位  130元  图示     Chivas 12 YO  名称  芝华士12年  特征  适合净饮  图示     干邑  80% 产量由四个家族（轩尼诗、马爹利、人头马、拿破仑）包办  Remy Martin VSOP  名称  人头马干邑VSOP  特征  用干邑区里最适合陈年的大、小香槟区的生命之水调配的VSOP 酒体平衡，价格合理 相对山寨货几率更低  图示     Courvoisier VSOP  名称  拿破仑干邑VSOP  特征  用了大香槟区、小香槟区、边缘区、优质林区四个地区的生命之水调配 姜饼、梅子、紫罗兰的气息相当明显  图示     雅文邑  只经过一次蒸馏，酒体中残留的风味物质非常多 经过陈酿以后与橡木桶赋予的味道香融合，整体的风格非常强烈 没有泥煤威士忌那种突出且不易为初学者接受的消毒药水味 Bas-Armagnac  公认品质最好的子产区  Folle Blanche  最适合在年轻时饮用，花香明显   Tariquet VSOP Bas-Armagnac  名称  塔希克VSOP雅文邑  特征  于表现花香  价位  350元  图示     Chateau Laubade Blanche  名称  朗巴德白雅文邑  特征  经过一次蒸馏后酒精含量只在55%左右，酒中残留的风味物质非常多，风格突出，比伏特加之类的白色烈酒有更多风味 先取样送往雅文邑行业管理局，又烈酒专家团进行一次盲品测试  在新鲜度、复杂度、花果香气均达到标准的，才批准装瓶出售 达标的，则不允许出售，只能倒掉卖给产区外的烈酒生产商    参考  对洋酒比较感兴趣，想入门应该买些什么酒来喝？ 100 元以下的价位有什么好喝的酒？  </content>
    </entry>
    
     <entry>
        <title>王垠-如何掌握所有的程序语言</title>
        <url>http://domain.yqjdcyy.com/post/%E7%8E%8B%E5%9E%A0-%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E6%89%80%E6%9C%89%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>思考</tag>
        </tags>
        <content type="html">  王垠-如何掌握所有的程序语言 针对处理  你是编程初学者，不知道该选择什么程序语言来入门。 你是资深的程序员或者团队领导，对新出现的种种语言感到困惑，不知道该投资哪种语言。 你的团队为使用哪种程序语言争论不休，发生各种宗教斗争。 你追逐潮流采用了某种时髦的语言，结果两个月之后发现深陷泥潭，痛苦不堪……  重视语言特性，而不是语言  任何一种“语言”，都是各种“语言特性”的组合  一个程序语言就像一台电脑。不同的语言则相对于不同的品牌。 你得看看它里面装的是什么型号的处理器，有多少个核，主频多少，有多少 L1 cache，L2 cache……，有多少内存和硬盘，显示器分辨率有多大，显卡是什么 GPU，网卡速度，等等各种“配置”。有时候你还得看各个组件之间的兼容性。   通用特点  语言特性
 变量定义 算术运算 for 循环语句，while 循环语句 函数定义，函数调用 递归 静态类型系统 类型推导 lambda 函数 面向对象 垃圾回收 指针算术 goto 语句  掌握通用特性
 比如变量，函数，整数和浮点数运算，这些是每个通用程序语言里面都必须有的 掌握基本的特性后，即可随时将这些知识应用到任何其它语言  学习方法
 手头有问题 用两分钟浏览一下这语言的手册，看看这语言大概长什么样 例子代码来开始修改捣鼓，想法把这代码改成自己正想解决的问题 实现过程中自然带出问题  这个语言的“变量定义”是什么语法，需要“声明类型”吗，还是可以用“类型推导”？ 它的“类型”是什么语法？是否支持“泛型”？泛型的 “variance” 如何表达？ 这个语言的“函数”是什么语法，“函数调用”是什么语法，可否使用“缺省参数”？  补充  因为掌握了语言特性的人都知道，自己需要的特性，在任何语言里面一定有对应的表达方式。 如果没有直接的方式表达，那么一定有某种“绕过方式”。如果有直接的表达方式，那么它只是语法稍微有所不同而已。  带着问题找特性，就像查字典一样，而不是被淹没于大部头的手册里面    语言特性
 一种好的语言，它所特有的新特性，终究不会超过一两种 最好的语言研究者，往往不是某种语言的设计者，而是某种关键语言特性的设计者（或者支持者）  著名的计算机科学家 Dijkstra 就是“递归”的强烈支持者。  早期的程序语言是不支持递归的。 直到 Dijkstra 强烈要求 Algol 60 委员会加入对递归的支持  Tony Hoare 也是语言特性设计者  开发了几个著名的算法，包括Quicksort与Quickselect，却没有设计过任何语言。     合理的入门语言  推荐  Scheme C Java Python JavaScript  原因  集中精力理解最关键的概念  变量 函数 递归 类型 &amp;hellip;  随业务扩展再行补充正则、Web等相关概念   掌握关键语言特性，忽略次要特性  C 语言的语句块，如果里面只有一条语句，可以不打花括号。 Go 语言的函数参数类型如果一样可以合并在一起写，比如 func foo(s string, x, y, z int, c bool) { ... } Perl 把正则表达式作为语言的一种特殊语法 JavaScript 语句可以在某些时候省略句尾的分号 Haskell 和 ML 等语言的 currying  自己动手实现语言特性  只有实现了各种语言特性，你才能完全地拥有它们，成为它们的主人。否则你就只是它们的使用者，你会被语言的设计者牵着鼻子走。  面向对象 面向切面 容器控制反转 反向代理 类型推导 类型检查 惰性求值 &amp;hellip;   总结  不管是初学者还是资深程序员，应该专注于语言特性，而不是纠结于整个的“语言品牌”。 只有这样才能达到融会贯通，拿起任何语言几乎立即就会用，并且写出高质量的代码。  </content>
    </entry>
    
     <entry>
        <title>鸡尾酒</title>
        <url>http://domain.yqjdcyy.com/post/%E9%B8%A1%E5%B0%BE%E9%85%92/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>酒</tag>
        </tags>
        <content type="html">  国际调酒师协会指定比赛鸡尾酒  阿美利加诺（Americano）  做法  依次倒入  30ml甜味味美思（Vermouth） 30ml金巴利（Carmpari） 冰块 少量苏打水  装饰  桔子皮| 柠檬瓣    毕和毕（B&amp;amp;B）  做法  依次倒入分层堆叠  白兰地（Brandy） 香草甜酒（Benedictine）    贝利尼（Bellini）  评价  1948年发明，用于纪念画家贝利尼  做法  依次倒入搅拌  桃子酒* 2&amp;frasl;3 石榴糖浆 葡萄酒* 1&amp;frasl;3    血腥玛丽  评价  被认为是世界上最难喝的鸡尾酒  做法  倒入后晃匀  冰块 辣椒油 伏特加 番茄汁 柠檬汁  搅拌  黑胡椒粉 干辣椒粉  装饰  柠檬片 芹菜杆    布朗克斯（Bronx）  评价  西方世界最受欢迎鸡尾酒前三  做法  摇匀过滤  冰块 琴酒* 60ml 柳橙汁* 30ml 甜香艾酒* 4ml 不甜香艾酒* 4ml 冰块    德思威他（Dolce Vita）  做法  倒入后搅拌  坦布勒杯 草莓甜酒* 1&amp;frasl;10 琴酒* 3&amp;frasl;10 马天尼玫瑰红酒  装饰  橙片| 柠檬片    干冽玫瑰（Dry Rose）  做法  倒入后搅拌  干味美思* 40ml 基尔希樱桃白兰地* 20ml 石榴糖浆* 4ml    佛妙3(Formule 3)  做法  依次加入  坦布勒杯 冰块 西柚汁* 3&amp;frasl;10 草莓甜酒* 2&amp;frasl;10 俄得克酒* 5&amp;frasl;10  加满  汤力水    金菲士（Gin Fizz）  做法  摇匀  糖粉| 糖浆 柠檬汁 金酒  倒至坦布勒杯 补满苏打水   金合义（Gin and it）  做法  依次倒入  辛辣金酒* 1&amp;frasl;2 甜味苦艾酒* 1&amp;frasl;2    乾马天尼  做法  倒入后搅拌  马天尼干酒* 2&amp;frasl;10 金酒* 8&amp;frasl;10  装饰  橄榄| 拧绞柠檬皮    完美马天尼（Medium or perfect Martini）  做法  倒入后搅拌  马天红酒* 3&amp;frasl;10 马天尼干酒* 3&amp;frasl;10 金酒* 4&amp;frasl;10  装饰  鸡尾酒杯 樱桃| 拧绞柠檬皮    甜马天尼（Sweet Martini）  做法  倒入后搅拌  金酒* 6&amp;frasl;10 甜味美思* 4&amp;frasl;10 冰块  装饰  过滤倒入鸡尾酒杯 红樱桃    尼格龙尼（Negroni）  做法  依次倒入  坦布勒杯 冰块 马天尼红酒* 3&amp;frasl;10 马天尼苦酒* 3&amp;frasl;10 金酒* 4&amp;frasl;10  装饰  半片橙片    古典鸡尾酒（Old fashioned）  做法  搅拌  方糖 苦精 苏打水  加满  冰块 威士忌  装饰  柠檬皮 柳橙片 无渍樱桃    波菲利普（Porto Flip）  做法  倒入后摇匀  白兰地* 15ml 波特葡萄酒* 45ml 糖粉 蛋黄 冰块  装饰  倒入鸡尾酒杯 豆蔻粉    罗伯洛伊（Rob Roy）  评价  为苏格兰著名的义贼 Rob Roy 创建  做法  倒入后搅拌  英格兰威士忌* 45ml 甜香艾酒* 15ml 柑橘苦精  装饰  倒入鸡尾酒杯 柠檬皮    苏格兰酸（Scotch sour）  评价    做法  倒入后摇匀  苏格兰威士忌* 60ml 生鲜柠檬汁 糖浆  装饰  过滤倒入 甜酒浸樱桃    螺丝刀  做法  依次倒入  坦布勒杯 冰块 俄得克酒* 4&amp;frasl;10 橙汁* 6&amp;frasl;10    痛击（Stinger）  评价  口味辛辣，适合餐后饮用  做法  倒入后摇匀  冰块 干邑白兰地* 50ml 白薄荷力娇酒* 20ml    汤姆可林（Tom Collins）  评价    做法  倒入后摇匀  冰块 琴酒* 60ml 鲜榨柠檬汁* 22ml 糖浆* 30ml  装饰  过滤后倒入可林杯 苏打水 糖渍樱桃 柳橙片    伏特加丁尼（Vodkatini）  评价  “金汤尼”的伏特加版  做法  倒入后搅拌  冰块 伏特加* 45ml 汤尼水  装饰  柠檬片     分类 亚历山大类  亚历山大 (鸡尾酒)（Alexander）  做法  倒入后摇匀  冰块 白兰地* 1&amp;frasl;3 可可利口酒* 1&amp;frasl;3 鲜奶油* 1&amp;frasl;3  装饰  鸡尾酒杯 豆蔻粉    咖啡亚历山大（Coffee Alexander） 金酒亚历山大（Gin Alexander）  霸克类  金霸克（Gin Buck）  做法  倒入后搅拌  坦布勒杯 金酒* 45ml 柠檬汁* 1&amp;frasl;2 冰块 姜汁汽水  装饰  柠檬片    白兰地霸克（Brandy Buck）  可林类  兰姆可林（Rum Collins）  评价    做法  倒入后搅拌  清淡朗姆酒* 45ml 柠檬汁* 20ml 糖浆* 2 冰镇苏打水  装饰  柠檬片 红樱桃    波本可林（Bourbon Collins）  考比勒类  白兰地考比勒（Brandy Cobbler）  评价    做法  倒入后搅拌  冰块 覆盆子糖浆| 香甜酒* 22ml 水* 30ml 捣汁  去皮凤梨* 1角 柳橙片* 1片 柠檬角* 1个   装饰  过滤 凤梨角 柳橙片    香槟考比勒（Champagne Cabbler） 威士忌考比勒（Whisky Cabbler）  福赞类（Frozen）  冰冻黛克蕾（Frozen Daiquiri）  做法  倒入后搅拌  碎冰 白色朗姆酒* 2&amp;frasl;3 青柠汁* 1&amp;frasl;3 石榴糖浆  装饰  搅拌至成冰糕状 倒至香槟酒杯     菲丽普类  白兰地菲丽普（Brandy Flip）  评价  需尽快饮用，因蛋黄缘故酒体容易分层  做法  倒入后摇匀  白兰地* 45ml 蛋黄 砂糖 豆蔻  装饰  倒入波特酒杯    雪梨菲丽普（Sherry Flip） 味美思菲丽普（Vermouth Flip）  戴兹类  馨馨戴兹（Ching Ching Daisy） 金戴兹（Gin Daisy） 威士忌戴兹（Whisky Daisy）  蛋诺类  白兰地蛋诺（Brandy Eggnog）  评价  北美圣诞节时饮用  做法  倒入后摇匀  冰块* 1&amp;frasl;2 白兰地* 45ml 白朗姆酒* 15ml 鲜奶* 75ml 糖浆* 15ml 蛋黄  装饰  摇至雪克瓶外部结霜 过滤至鸡尾酒杯 豆蔻粉    覆盆子蛋诺（Eggnog Framboise） 波旁蛋诺（Bourbon Eggnog）  宾治类  拓荒者宾治（Plant&amp;rsquo;s Punch）  评价    做法  倒入后摇匀  黑朗姆酒* 45ml 橙汁* 35ml 青柠汁* 20ml 石榴糖浆* 10ml 糖浆* 10ml  装饰  柯林杯 冰块 过滤后倒入 苦酒* 2ml 橙片    苹果白兰地宾治（Applejack Punch） 茶宾治（Tea Punch） 威士忌宾治（Whisky Punch）  鸡尾类  蚱蜢（Grasshopper）  评价  适合女性初试鸡尾酒  做法  倒入后摇匀  绿色薄荷酒* 1&amp;frasl;3 白色可可甜酒* 1&amp;frasl;3 鲜奶油* 1&amp;frasl;3    吉布森（Gibson） 日出特吉拉 杰克玫瑰（Jack Rose） 天堂 粉佳人（Pink Lady） 黑天鹅绒（Black Velvet） 兰潟湖（Blue Lagoon） 白俄 莫斯科驴子（Moscow Mule） 玛格丽塔（Margarita） 反舌鸟  德贵丽类  德贵丽（Daiquiri）  评价  古巴城市圣地亚哥郊外的矿山名称 1896年矿山技师发明  做法  倒入后摇匀  白朗姆酒* 3&amp;frasl;4 酸橙汁* 1&amp;frasl;4 砂糖 冰块  装饰  过滤倒入鸡尾酒杯    菠萝德贵丽（Pineapple Daiquiri） 桃德贵丽（Peach Daiquiri）  推荐 推荐女士 含奶制品类  Grasshopper（绿色蚱蜢） Alexander / Brandy Alexander（亚历山大） White Russian（白色俄罗斯）  透明汽水类  Gin Tonic（金汤力） Mojito Moscow Mule（莫斯科骡子）  果汁类  Cosmopolitan （大都会） Singapore Sling （新加坡司令）  不可描述 无声杀手  Zombie （僵尸） Long Island Iced Tea （长岛冰茶）  烈酒  Appletini / Apple Martini （苹果马天尼） Manhattan （曼哈顿） B-52  参考  酒吧里比较常见且适合女生喝的鸡尾酒 酒吧里最适合女生喝的6类16款鸡尾酒 酒吧里比较常见且适合女生喝的是哪些鸡尾酒，各自有什么特点？ DIY六款高颜值鸡尾酒 灌醉小鲜肉  </content>
    </entry>
    
     <entry>
        <title>PDF部分页面转图片异常</title>
        <url>http://domain.yqjdcyy.com/post/pdf%E9%83%A8%E5%88%86%E9%A1%B5%E9%9D%A2%E8%BD%AC%E5%9B%BE%E7%89%87%E5%BC%82%E5%B8%B8/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>异常</tag><tag>PDFBOX</tag>
        </tags>
        <content type="html">  Error java.lang.IllegalArgumentException: Numbers of source Raster bands and source color space components do not match at java.awt.image.ColorConvertOp.filter(ColorConvertOp.java:482) at com.sun.imageio.plugins.jpeg.JPEGImageReader.acceptPixels(JPEGImageReader.java:1268) at com.sun.imageio.plugins.jpeg.JPEGImageReader.readImage(Native Method) at com.sun.imageio.plugins.jpeg.JPEGImageReader.readInternal(JPEGImageReader.java:1236) at com.sun.imageio.plugins.jpeg.JPEGImageReader.read(JPEGImageReader.java:1039) at javax.imageio.ImageReader.read(ImageReader.java:939) at org.apache.pdfbox.filter.DCTFilter.decode(DCTFilter.java:85) at org.apache.pdfbox.cos.COSInputStream.create(COSInputStream.java:69) at org.apache.pdfbox.cos.COSStream.createInputStream(COSStream.java:162) at org.apache.pdfbox.pdmodel.common.PDStream.createInputStream(PDStream.java:235) at org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject.&amp;lt;init&amp;gt;(PDImageXObject.java:125) at org.apache.pdfbox.pdmodel.graphics.PDXObject.createXObject(PDXObject.java:70) at org.apache.pdfbox.pdmodel.PDResources.getXObject(PDResources.java:409) at org.apache.pdfbox.contentstream.operator.graphics.DrawObject.process(DrawObject.java:53) at org.apache.pdfbox.contentstream.PDFStreamEngine.processOperator(PDFStreamEngine.java:838) at org.apache.pdfbox.contentstream.PDFStreamEngine.processStreamOperators(PDFStreamEngine.java:495) at org.apache.pdfbox.contentstream.PDFStreamEngine.processStream(PDFStreamEngine.java:469) at org.apache.pdfbox.contentstream.PDFStreamEngine.processPage(PDFStreamEngine.java:150) at org.apache.pdfbox.rendering.PageDrawer.drawPage(PageDrawer.java:206) at org.apache.pdfbox.rendering.PDFRenderer.renderImage(PDFRenderer.java:145) at org.apache.pdfbox.rendering.PDFRenderer.renderImageWithDPI(PDFRenderer.java:94) at com.yunkai.component.resource.service.impl.PDFConvertServiceImpl.convertToImage(PDFConvertServiceImpl.java:72) at com.yunkai.component.resource.service.impl.PDFConvertServiceImpl.convertToImage(PDFConvertServiceImpl.java:88) at com.yunkai.component.resource.service.impl.PDFConvertServiceImpl.convertToImage(PDFConvertServiceImpl.java:93) at com.yunkai.component.resource.service.impl.ConvertServiceImpl.pdf2Image(ConvertServiceImpl.java:171) at com.yunkai.training.commons.resource.service.impl.LogicConvertServiceImpl.handlerPDF(LogicConvertServiceImpl.java:319) at com.yunkai.training.commons.resource.service.impl.LogicConvertServiceImpl.convertExerciseToAVI(LogicConvertServiceImpl.java:187) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:302) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.springframework.aop.interceptor.AsyncExecutionInterceptor$1.call(AsyncExecutionInterceptor.java:115) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.lang.Thread.run(Thread.java:745) 参考  Bug 178906 - IllegalArgumentException: Numbers of source Raster bands and source color space components do not match JDK-4893408 : JPEGReader throws IllegalArgException when setting the destination to BYTE_GRAY  优化  单片转空白页 尝试其它类型 ImageType  </content>
    </entry>
    
     <entry>
        <title>小丸压缩视频转M3U8异常</title>
        <url>http://domain.yqjdcyy.com/post/%E5%B0%8F%E4%B8%B8%E5%8E%8B%E7%BC%A9%E8%A7%86%E9%A2%91%E8%BD%ACm3u8%E5%BC%82%E5%B8%B8/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>异常</tag><tag>FFMPEG</tag>
        </tags>
        <content type="html">  异常反馈  2 frames left in the queue on closing  Command  原始转换请求转换语句 &amp;gt; /usr/local/ffmpeg/bin/ffmpeg -i /static/cdn/prod/video/38ad11be-f1c7-4dea-9ce0-6ed13a93d906.mp4 -vcodec libx264 -r 24 -vf scale=640:360,pad=640:360:0:0:black -acodec aac -ar 22050 -ab 24k -map 0 -f ssegment -segment_format mpegts -segment_list /static/cdn/prod/video/38ad11be-f1c7-4dea-9ce0-6ed13a93d906_640x360/index.m3u8 -segment_time 10 /static/cdn/prod/video/38ad11be-f1c7-4dea-9ce0-6ed13a93d906_640x360/%04d.ts  Info  /usr/local/ffmpeg/bin/ffprobe -i /static/cdn/prod/video/38ad11be-f1c7-4dea-9ce0-6ed13a93d906.mp4 客户使用「小丸」进行视频压缩，添加末帧图片作为视频流，导致转 M3U8 时缓存不足引起转换失败  理解为 FFMPEG 进行转码时，对各通道流进行同步缓存 而图片流中图片仅存在于末帧，导致需要缓存的数据过多引发如上异常 仅为与同事探讨的可能，如有知情，请烦请知会 &amp;gt; Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709/unknown/unknown), 1920x1080, 340 kb/s, 25 fps, 25 tbr, 25 tbn, 50 tbc (default) Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 129 kb/s Stream #0:2: Video: png, rgba(pc), 1920x1080, 90k tbr, 90k tbn, 90k tbc   Ask  ffmpeg -max_muxing_queue_size [bug][regression] Too many packets buffered for output stream Conversion failed! by Too many packets buffered for output stream 0:0. in wmv  Try  -max_muxing_queue_size 9999  06:01.69 485 kb/s 1920x1080情况下视频，9999值足够使用 时间超过6min则出现不足异常   TODO Query  具体业务相关，略  Demo  具体业务相关，略  Command /usr/local/ffmpeg/bin/ffmpeg -i /static/cdn/prod/video/57027182-0cba-4746-8eb4-8d4501da66d1.mp4 -vcodec libx264 -r 24 -vf scale=640:360,pad=640:360:0:0:black -acodec aac -ar 22050 -ab 24k -map 0 -f ssegment -segment_format mpegts -segment_list /static/cdn/prod/video/57027182-0cba-4746-8eb4-8d4501da66d1_640x360/index.m3u8 -segment_time 10 /static/cdn/prod/video/57027182-0cba-4746-8eb4-8d4501da66d1_640x360/%04d.ts Kafka.Producer send(av, 1, {&amp;#34;env&amp;#34;:&amp;#34;prod&amp;#34;,&amp;#34;args&amp;#34;:&amp;#34;id_37976-type_exercise&amp;#34;,&amp;#34;req&amp;#34;:{&amp;#34;type&amp;#34;:3,&amp;#34;from&amp;#34;:&amp;#34;/static/cdn/prod/video/57027182-0cba-4746-8eb4-8d4501da66d1.mp4&amp;#34;,&amp;#34;to&amp;#34;:&amp;#34;/static/cdn/prod/video/57027182-0cba-4746-8eb4-8d4501da66d1_640x360&amp;#34;,&amp;#34;args&amp;#34;:&amp;#34;format=phone&amp;#34;}}) Update  具体业务相关，略  Request  具体业务相关，略  </content>
    </entry>
    
     <entry>
        <title>调酒</title>
        <url>http://domain.yqjdcyy.com/post/%E8%B0%83%E9%85%92/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>酒</tag>
        </tags>
        <content type="html">  Mojito 莫吉托 材料  白郎姆酒 40ml 青柠檬汁 30ml  可用屈臣氏青柠汁替换  薄荷叶 6片 白糖 2茶匙 苏打水  可用屈臣氏苏打水替换  冰块  杯子  海波杯  做法  薄荷叶&#43; 白糖&#43; 青柠（檬）汁混合捣碎 加苏打水后，加冰块填满本子 加入郎姆酒后添苏打水至满杯 以薄荷叶或柠檬片装饰  </content>
    </entry>
    
     <entry>
        <title>富爸爸穷爸爸</title>
        <url>http://domain.yqjdcyy.com/post/%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>商业</tag>
        </tags>
        <content type="html">  富爸爸穷爸爸 课程 富爸爸，穷爸爸  我怎样才能付得起？ 贫穷和破产的区别是：破产是暂时的，而贫穷是永久的。  富人不为钱工作  如果你不能下定决心，就永远也学不会如何赚钱。 在生活推着他转的同时，抓住生活赐予的每个机会； 如果你认为是我的问题，你就会想改变我；如果你认为问题在你那儿，你就会改变自己，学习一些东西让自己变得更聪明。大多数人认为世界上除了自己外，其他人都应该改变。让我告诉你吧，改变自己比改变他人更容易。 老鼠赛跑  学习为钱工作很容易，特别是当你一谈到钱就觉得恐惧时，学习为钱工作就更容易了。 没钱的恐惧会促使他们努力工作，得到报酬后，贪婪或欲望又让他们想拥有所有用钱能买到的好东西。  控制欲望，控制自己  你无需告诉别人你的感觉，只有你自己知道。 人生实际上是在无知和觉醒之间的一场斗争。 忠实于你的感情，以你喜欢的方式运用你的头脑和感情，不要让它们控制你。 你有两种感情——恐惧和欲望，如果你让它们来控制你的思想，你就会落入一生中最大的陷阱。   为什么要教授财务知识  只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。 从长远来看，重要的不是你挣了多少钱，而是你能留下多少钱，以及能够留住多久。 聪明人总是雇用比他更聪明的人。 你为别人工作。就像为工资而工作的大多数人一样，你的工作只会使雇主或股东更加富有，你的努力和成功将使雇主更加成功并得以提早退休。 财富就是支撑一个人生存多长时间的能力，或者说，如果我今天停止工作，我还能活多久？ 财富是将资产项产生的现金与支出项流出的现金进行比较而定的。  关注自己的事业  从事你所学的专业的可怕后果在于，它会让你忘记关注自己的事业。人们耗尽一生去关注别人的事业并使他人致富。 只有你把额外的收入用来购买可产生收入的资产，你才能获得真正的财务安全。  不需到场就可以正常运作的业务 股票 债券 能够产生收入的房地产 版税，如音乐、手稿、专利   富人的投资  我们都拥有巨大的潜能——这是上天赏赐的礼物。然而，我们都或多或少地存在着某种自我怀疑的心理，从而阻碍前进的步伐。这种障碍很少是缺乏某种技术性的东西，更多的是缺乏自信。有些人更容易受到外界的影响。 财务知识 投资策略 市场、供给与需求 法律规章 如何寻找其他人都忽视的机会 怎样把精明的人组织起来  学会不为钱工作  财商是会计、投资、市场和法律等各方面知识和能力的综合。  “工作（job）一词就是‘比破产强一点’（just over broke）。” “工人付出最大努力以免于被解雇，而雇主提供最低工资以防止工人辞职。” 在很多情况下，他们贫穷、财务困难或者只能挣到低于他们应得的薪水，不是因为他们已知的东西而是因为他们未知的东西。  这些聪明的年轻人并不去专项钻研某一个部门的业务，而是从一个部门跳到另一个部门，从而学到整个企业各个系统的知识。  能对如何经营一家企业有一个整体的认识，并可以了解不同部门的相互关系。 必需的管理技能  对现金流的管理 对系统（包括你本人、时间及家庭）的管理 对人员的管理。   你在处理人际关系、商务谈判和被拒绝时的恐惧心理等方面做得越好，生活就会越轻松。  开端 克服困难  困难  恐惧心理 愤世嫉俗 懒惰 不良习惯 自负  关键
 我不想要  技巧
 横盘好比一个计算机指令，当股价开始下跌时自动卖出股票，帮助你将损失最小化、收益最大化 我可付不起 禁锢了你的思想，使你无法进一步思考 我可付不起 带来的悲哀和无助感会使人们失望、迟钝以至意志消沉 我怎样才能付得起 打开了充满可能性的快乐和梦想  事例
 1626年，荷兰人用价值24美元的物品从印第安人手中买下了曼哈顿岛，并取名为新阿姆斯特丹。1664年曼哈顿岛被英国人占领，改名为纽约。   开始行动 开始行动  超现实的理由——精神的力量。 作出一个选择，这个选择是我们利用自己的时间、金钱和头脑里学到的东西作出的。 保留了自己习惯的思考方式，同时又学到了彼得·林奇分析同一问题或趋势的思考方式。  学习  选择朋友——关系的力量。 在竞争激烈的市场上，群体往往会反应迟钝，成为被“宰割”的对象。 学习一种新的模式——快速学习的力量。 支付自己——自律的力量。如果你控制不了自己，就别想着致富。  生活之所以能推着你转，不是因为生活的力量很强大，而是因为你缺乏自律。  有胆量不随大流才能致富。  你也许并不软弱，但一旦涉及金钱，往往会变得怯懦。  穷人有一些不好的习惯  其中一个普遍的坏习惯就是随便动用储蓄。富人知道储蓄只能用于创造更多的收入，而不是用来支付账单。  以优厚的报酬——好建议的力量。 要找一位很关心你的利益的经纪人。  许多经纪人会花时间来教导你，那么他们可能是你得到的最好的资产。  印第安给予者——无私的力量。 不只看到投资回报率，而且还能看到，一旦收回投资，就能额外得到的资产。这也是财商。 轻松的道路往往会越走越艰难，而艰难的道路往往会越走越轻松。 对英雄的崇拜——神话的力量。 在市场上或为交易进行谈判时，我下意识地模仿川普的那种气势；当分析某种趋势时，我学着像彼得·林奇那样思考。通过偶像的模范作用，我们挖掘出自身的巨大潜能。 上帝不需要得到，但人类需要付出  还想要更多吗？这里有一些要做的事情  房地产中介并不那么尽力，所以他们常常什么也不做而是去寻找一处更好的房产。 没卖过东西的人，对想卖出东西的迫切心情是不会理解的。 你要知道你在寻找什么，然后开始行动！  我首先寻找想买进的人，然后才去找想卖出的人。   </content>
    </entry>
    
     <entry>
        <title>小王子</title>
        <url>http://domain.yqjdcyy.com/post/%E5%B0%8F%E7%8E%8B%E5%AD%90/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>思考</tag>
        </tags>
        <content type="html">  小王子(65周年纪念版) 旅伴  玫瑰 国王 地理学家 商人 酒鬼 自高自大的人 玫瑰  标注  如果有一个人爱上在这亿万颗星星中仅有的一朵花，这人望着星空的时候，就会觉得幸福。 审判自己，比审判别人难得多。你若是能够公正地审判自己，那你就是一个真正的贤士。 在我看来，你只不过是一个小男孩，跟成千上万的男孩毫无两样。我不需要你，你也不需要我。对你来说我只不过是一只狐狸，跟成千上万的狐狸毫无两样。但是，你如果驯养了我，那么我们俩就彼此相互需要。对我来说，你是世界上独一无二的；我在你看来，也是世界上独一无二的…… 正是因为你为你的玫瑰，花费了时间，才使你的花儿变得那么重要。 无论是房子、星星或沙漠，使它们美丽的东西是看不见的。  </content>
    </entry>
    
     <entry>
        <title>知乎架构变迁史</title>
        <url>http://domain.yqjdcyy.com/post/%E7%9F%A5%E4%B9%8E%E6%9E%B6%E6%9E%84%E5%8F%98%E8%BF%81%E5%8F%B2/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>架构</tag>
        </tags>
        <content type="html">  知乎架构变迁史 引言  You jump off a cliff and you assemble an aeroplane on the way down. - Reid Hoffman 阶段 上线   选型
 Python.Tornado  Python  简单强大、快速上手、开发效率高、社区活跃  Tornado  支持异步、适合实时Comet应用开发、简单轻量、学习成本低 FriendFeed 的成熟案例 Facebook 的社区支持    优化
 主从延迟  参见参考项「MySQL主从复制延迟的监测及缓解」和「彻底终结mysql同步延迟问题」  资源隔离  图片资源独立部署  内网优化  更换设备  硬盘升级   应用层灵活调用 Redis Shard  github.com/zhihu/redis-shard   工具
 Profiling  性能分析 (performance analysis) 以收集程序运行时信息为手段研究程序行为的分析方法，是一种动态程序分析的方法  统计性的事件汇总（轮廓，profile） 所有事件的记录流（踪迹，trace） 用hypervisor持续性的交互监控（针对事件连续性或周期性显示在显示屏上）   Werkzeug  Python.WSGI工具包  Puppet  开源系统配置管理工具  Shipit  实现自动化的多服务器部署    日志    zhihu/kids
 支持分布式收集、集中存储、实时、可订阅和简单 参考  Scribe 不支持订阅  选型  Kafka Scala-技术储备不足 Flume Java-技术储备不足    事件驱动  场景
 添加答案  更新通知 更新动态 更新索引 更新计数 内容审查 &amp;hellip;     示例
 用户回答问题  将问题插入 Mysql 将消息插入至 Sink 将问题返回给用户  Sink 通过 Miller 将任务分发给 Beanstalkd， worker自行找到任务并处理   页面渲染优化  特点  计算密集型 IO 密集型  优化  组件化 调整中数据获取机制  页面组件结构树，自上而下获取数据   框架  ZhihuNode    SOA-RPC  版本迭代
 Wish  Protocol Buffers&#43; STP&#43; TCP  PB的描述代码过于冗长、校验严格不便使用   Snow  JSON&#43; STP&#43; TCP  服务升级时，难以确认哪些服务需要调整   Zone  Apache.Avro|JSON&#43; STP|Binary&#43; TCP   服务拆分
     工具  Dash  Linux 服务器监控系统 PHP 实现，直观展示 Linux 服务器的当前整体概况  内存、磁盘、网络、安装软件、用户、运行进程   Heroin Crony  参考  知乎架构变迁史 ASBJ2014-李申申-知乎架构变迁史.pdf 从0到100——知乎架构变迁史 MySQL主从复制延迟的监测及缓解 彻底终结mysql同步延迟问题 zhihu/kids Python 工具包 werkzeug 初探 Puppet：开源系统配置和管理工具 生成树协议 linux-dash Linux监控系统linux-dash安装和使用小结  </content>
    </entry>
    
     <entry>
        <title>阅读清单-2018</title>
        <url>http://domain.yqjdcyy.com/post/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95-2018/</url>
        <categories>
          <category>阅读</category><category>一切按计划进行</category>
        </categories>
        <tags>
          <tag>思考</tag>
        </tags>
        <content type="html">  技术  Java7&amp;amp; 8 Apache Common/ Guava 等常用工具类 JVM Java并发编程实践 深入Java虚拟机 算法  思考  凯文·凯利  失控  沈君山  浮生三记 浮生再记  丁文江  少数人的责任  黄仁宇  万历十五年  尼尔.波兹曼  娱乐至死  史铁生  我与地坛   金融相关  罗伯特·清崎和莎朗·L·莱希特  穷爸爸与富爸爸  朱宁  投资者的敌人  格林斯潘  动荡的世界：风险、人性与未来的前景   </content>
    </entry>
    
     <entry>
        <title>海姆立克急救法</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B5%B7%E5%A7%86%E7%AB%8B%E5%85%8B%E6%80%A5%E6%95%91%E6%B3%95/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>急救</tag>
        </tags>
        <content type="html">  海姆立克急救法 参考  海姆立克急救法  简介  海姆立克急救法（Heimlich Maneuver），又名“海氏急救法” 美国医师亨利·海姆力克（Henry J·Heimlich）1974年发明的一套利用肺部残留气体，形成气流冲出异物的急救方法。  手法 成人  急救者首先以前腿弓，后腿登的姿势站稳，然后使患者坐在自己弓起的大腿上，并让其身体略前倾 将双臂分别从患者两腋下前伸并环抱患者 左手握拳，右手从前方握住左手手腕，使左拳虎口贴在患者胸部下方，肚脐上方的上腹部中央，形成“合围”之势，然后突然用力收紧双臂，用左拳虎口向患者上腹部内上方猛烈施压，迫使其上腹部下陷   婴幼儿  幼儿趴在自己大腿上，面向地板，身体和头部向下倾斜 一手拖住宝宝的颈部，另一手拍击宝宝两侧肩胛骨中间，观察异物是否吐出 否则将幼儿转身面朝上，头部稍微向下倾斜，手指并拢胸骨下凹陷按5下 随时观察孩子嘴里有没有东西出来，如果有东西，救护应该用手指将异物勾取出来，千万不要捅   自救  无工具
 一只手握拳，并用大拇指的一侧顶住上腹部，在肋弓之下肚脐之上 用另一只手抓住握拳的那只手，并迅速用力向上挤压 重复动作，直至导致窒息的物体排出  有工具
 依靠在一个固定的水平物体上（如桌子边缘、椅子、扶手等） 用物体的边缘对上腹部施压，制造出强大的向上冲击力 重复挤压，直至导致窒息的物体排出    注意事项  尤其对老年人，因其胸腹部组织的弹性及顺应性差，故容易导致损伤的发生  如腹部或胸腔内脏的破裂、撕裂及出血、肋骨骨折等 应首先采用其他方法排除异物，在其他方法无效且患者情况紧急时才能使用该法。   </content>
    </entry>
    
     <entry>
        <title>扫描二维码自动连接WIFI</title>
        <url>http://domain.yqjdcyy.com/post/%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5wifi/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>二维码</tag><tag>WIFI</tag>
        </tags>
        <content type="html">  扫描二维码自动连接WIFI 参考  想更优雅地分享 Wi-Fi 密码，只需一枚二维码 Wifi Network config  场景  手机扫描二维码，自动弹出「连接 WI-FI」建议  连接指令  WIFI:T:【加密类型】;S:【Wi-Fi 名称】;P:【你的密码】;;  例  WIFI:T:WPA2;S:Z905;P:nd123456;;   指定协议支持，可参考 PC 端的 mailto: 指令  推荐 IOS  使用 EFQRCode 创建二维码  支持 GIF 等形式   注意事项  需要支持 zxing 提出的「Wifi Network config (Android)」编码形式  支持该类编码的设备，捕获到如上指令时则自动弹出「加入 WI-FI」的建议  需要在 WI-FI 覆盖范围内  </content>
    </entry>
    
     <entry>
        <title>IDEA.快捷键</title>
        <url>http://domain.yqjdcyy.com/post/idea.%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>IDEA</tag><tag>快捷键</tag>
        </tags>
        <content type="html">  快捷键 包、结构或视图  Alt&#43;回车 导入包,自动修正 Ctrl&#43;Alt&#43;O 优化导入的类和包 Ctrl&#43;E 最近打开的文件 Ctrl&#43;H 显示类结构图，比如查看实现类 Ctrl&#43;Q 显示注释文档 Alt&#43;F1 查找代码所在位置 Alt&#43;1 快速打开或隐藏工程面板 Ctrl&#43;Alt&#43; left/right 返回至上次浏览的位置 Alt&#43; left/right 切换代码视图  文件操作和视图  Ctrl&#43;N 查找类 Ctrl&#43;Shift&#43;N 查找文件 Ctrl&#43;Shift&#43;Alt&#43;N 查找类中的方法或变量 Ctrl&#43;F12 显示当前类结构 ctr&#43;G 定位某一行 Alt&#43; Up/Down 在方法间快速移动定位
 Alt&#43;F1 查找代码所在位置 Ctrl&#43;O，显示可重载方法 Ctrl&#43;Q，查看方法定义；而Ctrl&#43;P 查看参数定义  代码相关  Ctrl&#43;Alt&#43;L 格式化代码 Ctrl&#43;Alt&#43;Space 类名或接口名提示 Alt&#43;Insert 生成代码(如get,set方法,构造函数等) Ctrl&#43;Shift&#43;Space 自动补全代码 Ctrl&#43;空格 代码提示 Ctrl&#43;/ 或 Ctrl&#43;Shift&#43;/ 注释（ 或者/&amp;hellip;/ ） Ctrl&#43; Alt&#43; T，用指定方法体围绕代码行 Ctrl&#43;Shift&#43;Up/Down 代码向上/下移动。 F2 或Shift&#43;F2 高亮错误或警告快速定位 Ctrl&#43;Shift&#43;先上键 将该功能代码上移 Ctrl&#43;X 删除行 Ctrl&#43;D 复制行 Ctrl&#43;J Live Templates列表 选中变量后按 Alt&#43;F7，可以查看该变量的所有应用场景 Ctrl&#43;B，跳转至对应类 Ctrl&#43;Alt&#43;B，显示接口相应的实现类 Ctrl&#43;Shift&#43; Alt&#43; U，显示类关系图 Ctrl-Shift-Backspace，可切换回之前修改的代码处  文字类型相关  Shift&#43;F6 重构-重命名 ctr&#43;shift&#43;U大小写转化 代码标签输入完成后，按Tab，生成代码。 选中文本，按Ctrl&#43;Shift&#43;F7 ，高亮显示所有该文本，按Esc高亮消失。 选中文本，按Alt&#43;F3 ，逐个往下查找相同文本，并高亮显示。 Ctrl&#43;Up/Down 光标跳转到第一行或最后一行下 Ctrl&#43;W 向上层级代码选中 Ctrl&#43;Shift&#43;J，自动缩进合并多行代码  Debug 相关  alt&#43;f8 debug时选中查看值 f8相当于eclipse的f6跳到下一步 shift&#43;f8相当于eclipse的f8跳到下一个断点，也相当于eclipse的f7跳出函数 f7相当于eclipse的f5就是进入到代码 alt&#43;shift&#43;f7这个是强制进入代码 ctrl&#43;shift&#43;f9 debug运行java类 ctrl&#43;shift&#43;f10正常运行java类 command&#43;f2停止运行  参考  Intellij IDEA 快捷键整理（TonyCody） IntelliJ IDEA导航特性Top20  </content>
    </entry>
    
     <entry>
        <title>彻底终结MySQL同步延迟问题</title>
        <url>http://domain.yqjdcyy.com/post/%E5%BD%BB%E5%BA%95%E7%BB%88%E7%BB%93mysql%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>MYSQL</tag>
        </tags>
        <content type="html">  彻底终结MySQL同步延迟问题 参考  彻底终结MySQL同步延迟问题 Binary Logging Options and Variables Estimating potential for MySQL 5.7 parallel replication  版本  MySQL.Version  5.7  Storage.Engine  TokuDB   影响因素 网络  主机或者从机的带宽打满 主从之间网络延迟很大  机器性能  从机使用了烂机器
 比如主机使用SSD而从机还是使用的SATA  从机高负载
 很多业务会在从机上做统计，把从机服务器搞成高负载 使用 top 查看使用情况  从机磁盘有问题
 检查磁盘、raid卡、调度策略  raid卡电池充放电的时候，在没有设置强行write back的情况下得会将write back模式修改为write through。  使用 iostat 命令查看 DB 数据盘的 IO 情况，是否是单个 IO 的执行时间很长，块大小和磁盘队列情况等，   大事务  检查是否经常有大事务  在RBR模式下，执行带有大量的delete操作 在MBR模式下删除的时候添加了不确定语句（类似limit）， 一个表的alter操作等  通过查看 processlist 相关信息 使用 mysqlbinlog 查看 binlog 中的 SQL 就能快速进行确认  锁  检查锁冲突  从机上有一些 select .... for update的 SQL， 使用了MyISAM引擎  去 processlist 查看 information_schema 下面和锁以及事务相关的表  参数  innodb  使用环境调整 innodb_flush_log_at_trx_commit、sync_binlog 参数来提升复制速度，  TokuDB  优化tokudb_commit_sync、tokudb_fsync_log_perid、sync_binlog 等参数来做调整   多线程  版本
 5.1 &amp;amp; 5.5  mysql 单线程复制瓶颈  5.6  mysql 正式支持多线程复制   参数
 通过 show processlist 查看是否有多个同步线程，也可以查看参数的方式查看是否使用多线程
 show variables like &amp;lsquo;%slave_parallel%&amp;rsquo;     Variable_name Value     slave_parallel_type DATABASE   slave_parallel_workers 0       Variable_name Value     slave_parallel_type LOGICAL_CLOCK   slave_parallel_workers 8    启用多线程
 STOP SLAVE SQL_THREAD;SET GLOBAL slave_parallel_type=&#39;LOGICAL_CLOCK&#39;;SET GLOBAL slave_parallel_workers=8;START SLAVE SQL_THREAD;   统计
 将线上从机相关统计打开（出于性能考虑默认是关闭的） &amp;gt; UPDATE performance_schema.setup_consumers SET ENABLED = &amp;lsquo;YES&amp;rsquo; WHERE NAME LIKE &amp;lsquo;events_transactions%&amp;lsquo;; UPDATE performance_schema.setup_instruments SET ENABLED = &amp;lsquo;YES&amp;rsquo;, TIMED = &amp;lsquo;YES&amp;rsquo;WHERE NAME = &amp;lsquo;transaction&amp;rsquo;;
 创建一个查看各个同步线程使用量的视图 &amp;gt; USE test; CREATE VIEW rep_thread_count AS SELECT a.THREAD_ID AS THREAD_ID,a.COUNT_STAR AS COUNT_STAR FROM performance_schema.events_transactions_summary_by_thread_by_event_name a WHERE a.THREAD_ID in (SELECT b.THREAD_ID FROM performance_schema.replication_applier_status_by_worker b);
 统计各个同步线程的使用比率 &amp;gt; SELECT SUM(COUNT_STAR) FROMrep_thread_count INTO @total; SELECT 100*(COUNT_STAR/@total) AS thread_usage FROMrep_thread_count;
   组提交  LOGICAL_CLOCK的方式下，并发执行的多个事务只要能在同一时刻commit，就说明线程之间没有锁冲突 尽可能地使所有线程能在同一时刻提交，这样就能很大程度上提升从机的执行的并行度，从而减少从机的延迟。
 参数
 binlog_group_commit_sync_delay  延迟SQL的响应  binlog_group_commit_sync_no_delay_count  在达到binlog_group_commit_sync_no_delay_count设定的值的时候，不管是否达到了binlog_group_commit_sync_delay设置定的阀值，都立即进行提交    </content>
    </entry>
    
     <entry>
        <title>美国-夏威夷</title>
        <url>http://domain.yqjdcyy.com/post/%E5%A4%8F%E5%A8%81%E5%A4%B7%E4%B9%8B%E6%97%85/</url>
        <categories>
          <category>旅游</category>
        </categories>
        <tags>
          <tag>美国</tag><tag>夏威夷</tag>
        </tags>
        <content type="html">  夏威夷 参考  ALOHA! 夏威夷之旅  路线  夏威夷大岛（Islandof Hawaii） 茂宜岛（Maui） 欧湖岛（Oahu）檀香山  夏威夷大岛 - 火山  由两座活火山组成，分别为基拉韦厄（ Kilauea）和冒那罗亚（Mauna Loa） 路线
 火山国家公园  火山口链路  雨林 海岸  越野十英里 岩浆活跃区   赏析
                 茂宜岛  路线
 Kahului市 海纳之路 山顶牧场 哈雷阿卡拉死火山口 观鲸  赏析
                   欧湖岛  赏析        </content>
    </entry>
    
     <entry>
        <title>阿里为什么不去清华招人？</title>
        <url>http://domain.yqjdcyy.com/post/%E9%98%BF%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8E%BB%E6%B8%85%E5%8D%8E%E6%8B%9B%E4%BA%BA/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>商务</tag>
        </tags>
        <content type="html">  阿里为什么不去清华招人？ 参考  阿里为什么不去清华招人？｜草铺半生  整理 卫哲  29岁，成为普华永道史上最年轻的合伙人之一 32岁，担任百安居中国区总裁，也是最年轻的世界500强中国区总裁 36岁，执掌阿里巴巴 嘉御基金的创始人，管理着10亿美金的资产  示例   微软.Steve Ballmer  我们和苹果竞争，和索尼竞争，和 Cisco 竞争，和 Oracle 竞争，我们是如何跟他们斗争的，又如何消灭他们的。 Steve Ballmer 下台，第二天股票涨了7%。微软的 7% 是多少？相当于300亿美金。  谷歌.Larry Page  NASA（美国宇航局）、Obama administration（奥巴马政府）  阿里巴巴  2005年,工程师和销售的离职率 10%/ 月。    招聘建议 不轻易下放招聘权  阿里巴巴刚创建的时候，大概在公司 400-500 人的时候，任何人加入公司，马云都要见，亲自面试。任何人，包括我们的前台接待，包括我们公司的保安。 因为你没有招对人，你没有把时间放在招聘上，形成了恶性循环。因为招的人不行，你要替他们去干，他们本来该干的事。 很多跨国公司，至少坚持跨两级招人，阿里巴巴一度恢复到跨四级招人。  重视专业技能以外的考核  业务技能很简单，很好判断。 因为人的分类没有对错。错的是什么呢？  是不同类的人，天天要坐在一起，天天要在一起共事。可想而知，心情不愉快，工作效率低。 &amp;gt; 同学，你能不能跟我描述一下，你这辈子吃的最大的苦是什么？ 同学，你能不能跟我讲讲，你这辈子吃过的最大的亏是什么？   跨一两级选拔人才  平凡的人做非凡的事情，我们不追求精英文化 你要招一个月薪大约1万的人，我们通常就在 8000-10000 里面去挑。结果来了以后，这些人的流失率很高，因为他们会认为，我原来挣 8000 ，跳槽后挣 10000 很正常。 你要在三四千块里面，挑出来一个你愿意付1万块的人，你大概要看三四十个人，但一定会有的，我相信一定会有的。 阿里很多最优秀的工程师，都是武汉邮电、华中科技这些大学招聘过来的  别总讲规模，多谈谈效率  互联网最大的作用就是提升效率。 商业的本质，除了增长以外还有效率。    晚餐补助，通过领导审批通过后领取饭票。一顿晚饭公司出15块钱。但  问题一：谁也没有规定工作到几点以后是加班。 问题二：我们从来没有去想，每天五、六千个人，提加班申请，主管批准，发一张券，这个动作，花了多少时间，花了多少钱。  取消报批制  一年下来，大概前一年加班餐费在1400万左右，年末多了大概100万，变成1500万了。而流程中节省人员时间等消耗，远超过100万。     提高个人效率，除了自我激励以外，不要有太多级约束。  人不是成本，人应该是投资   苹果公司这么一个技术公司，把奢侈品牌巴宝莉（Burberry） 的 CEO 找来做实体零售业的负责人 苹果店的存在，就是体验。所以苹果本身就是一种新零售 一定要对原有的零售门店加以再利用。  第一，房租成本，租金不能降低； 第二，人工成本，没法降低。     人均产出大幅度上升，每平米产出（坪效）大幅度上升。  如何让我们的公司变得好玩？  硅谷创业公司也好，大公司也好，见面第一句话，不是互相问“你们这的期权多少？”； 见面第一句话都是“你们那午饭怎么样？”“你们那的中餐水平怎么样？”
  好吃、好玩、好住，也可以是公司的卖点  </content>
    </entry>
    
     <entry>
        <title>设计模式</title>
        <url>http://domain.yqjdcyy.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>设计模式</tag>
        </tags>
        <content type="html">  设计模式 参考  《HEAD_FIRST 设计模式》 图说设计模式 design pattern 包教不包会  设计原则  找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起  系统中某部分改变不会影响其它部份  针对接口编程，而不是针对实现编程  变量声明为抽象或接口，执行时动态赋值  多用组合，少用继承 为了交互对象之间的松耦合设计而努力 类应该对扩展开放，对修改关闭  根据业务和重要性，来取舍是否  依赖倒置原则  要依赖抽象，不要依赖具体类  变量不可以持有具体类的引用  工厂  不要让类派生自具体类  派生至接口或抽象类  不要覆盖基类中已实现的方法  避免破坏基类中被继承的抽象    最少知识原则  减少对象之间的交互  好莱坞原则  别调用（打电话给）我们，我们会调用（打电话给）你 避免高、低层组件的相互依赖，导致依赖腐败 低层组件挂靠在高层组件，高层组件决定调用时机和方式  单一责任原则  一个类应该只有一个引起变化的原因 高内聚  一个模块或一个类，被设计仅支持一组相关功能时    设计模式 策略模式  定义  定义算法族；分别封装后，让它们之间相互替换 行为被封装进一组类中，并于需要时动态改变  UML     观察者模式  定义  定义对象之间的一对多依赖；当一个对象状态改变时，所有依赖者都会收到通知并自动更新  Java.Observervable Java.Observer   UML      装饰者模式  定义  动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更为弹性的替代方案  装饰者可在所委托被装饰者的行为之前有或之后，加上自己的行为，以达到特定的目的   UML      工厂模式  定义  定义创建对象的接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类  把类实例化推迟到子类   UML       单例模式  定义  确保一个类只有一个实例，并提供全局访问点  UML    优化  多线程  synchronized getInstance()  性能效率降低非常  private static Singleton ins= new Singleton();  JVM 加载时即人创建唯一实例  private volatile static VolatileSingleton ins;  双重检查加锁，最大限度减少同步 volatile 可保障对应变量     命令模式  定义  将请求封装为对象，以便使用不同的请求、队列或者日志来参数化其它对象  宏命令用于支持多个命令   UML     适配器模式  定义  将一个类的接口，转换成客户期望的另一个接口  让原本接口不兼容的类可以使用无间 类型  对象适配 类适配，需要语言支持多重继承    UML      外观模式  定义  提供统一的接口，用于访问子系统中的一群接口  定义高层接口，让子系统更容易使用 提供简化接口的同时，依然将完整的功能暴露出来 将业务从子系统中解耦出来，有调整需求时仅须调整外观代码   UML     模板方法模式  定义  在一个方法中定义一个算法的框架，将一些步骤延迟到子类中  子类在不改变算法结构的前提下，重新定义算法的部分步骤 通过预留钩子方法，保证算法的灵活性   UML     示例  java  Arrays.sort InputStream.read(byte b[], int off, int len)  模式  工厂模式    迭代器模式  定义  提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示  UML      组合模式  定义  允许将对象组合成树形结构来表现整体/ 部分的层次结构 组合能让客户以一致的方式处理个别对象以及对象组合  UML      状态模式  定义  允许对象在内部状态改变时改变它的行为  对象看起来好像修改了它的类 状态类可被多个 Context 实例共享   UML     代理模式  定义  为另一个对象提供一个替身或占位符以控件对这个对象的访问  适合远程、创建开销大、需要安全控制的对象 缓存代理、保护代理、虚拟代理   步骤  启动 rmiregistry 服务 编译并使用 rmic proxy.proxy.ProxyRemoteImpl 自动生成 ProxyRemoteImpl_Stub 运行 ProxyRemoteImpl 服务 运行 ProxyRemoteClient 请求服务  常见异常  未在启动远程服务前先启动 rmiregistry 服务 须确认变量和返回值类型可序列化  编译时不可见，只在运行时发现  未给客户端提供 stub 类  UML       复合模式  定义  结合两个或以上的模式，组成一个解决方案  解决一再发生的一般性问题   UML      桥接模式  定义  将抽象部分与实现部分分离，保障它们独立地变化  实例  跨平台视频播放器  多平台：Windows、Linux、Unix 等 多格式：MP4、AVI、RMVB 等   UML     生成器模式  定义  封装产品的构造过程，并允许按步骤构造  UML     责任链模式  定义  让一个以上对象都有机会能处理某个请求  UML     绳量|享元模式  定义  为某个类提供多个虚拟实例  UML     解释器模式  定义  定义出其文法的一种表示，并同时提供一个解释器  UML     中介者模式  定义  集中相关对象之间复杂的沟通和控制方式  通过将对象彼此解耦，增加对象的复用性 将控制逻辑集中，简化系统维护   UML      备忘录  定义  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 可以将该对象恢复到原先保存的状态  UML      原型模式  定义  用于在保证性能的前提下，创建重复的对象 java.Cloneable  UML     访问者模式  定义  封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作  UML     注意事项  实现一个接口，非特指利用implement关键词实现接口，泛指实现某个超类型的某个方法 模式是在某情境下，针对某问题的某种解决方案  针对该问题约束的，可以解决此约束的通用设计 关键词：问题、情境、解决方案  推荐书籍  设计模式：可利用面向对象软件的基础 The Timeless Way of building A Pattern Language   </content>
    </entry>
    
     <entry>
        <title>Hello.区块链</title>
        <url>http://domain.yqjdcyy.com/post/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%B5%85%E8%AF%86/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>区块链</tag>
        </tags>
        <content type="html">  区块链技术浅识 参考  区块链技术  前情  存在着各种互相孤立的数据系统及运作体系，这极大地影响了金融市场效率的进一步提升。 在世界银行的报告中，跨国汇款的成本接近 8%。 金融机构之间不能够无条件地信任对方，造成了金融领域数据孤岛的现象，进而导致了数字资产在互联网上流通成本居高不下。  特点  比特币系统就是基于区块链的记账机器；以太坊就是基于区块链的智能合约机器等等。 信任秘诀在于区块链的加密、公开且不可篡改的特性：  加密  区块链技术是以密码学和数学为基础的，这是信任的根本。  包括，椭圆曲线数字签名算法、非对称加密、哈希函数、梅克尔树等等。   公开  公开是赢得信任的最好手段。 基于区块链技术的系统的规则(程序)和数据都是公开的。 任何参与方都可以通过运行区块链的程序的方式加入进来，进而对数据进行验证。 在自己能验证，也能依靠第三方进行验证情况下，自己验证更可靠；  不可篡改  区块链技术不可篡改的特性，是数字资产不可复制的基础 删、改的操作的可行性几乎为零。  原理 状态机  比如以太坊系统，实际上就是多个节点维护同一个账本。 记账机器会在账本上记录每笔交易的信息。通过初始时各个账户的余额和已记录的信息，就可以推断出任意时刻的各个账户的余额。 区块链记账机器完成记账功能的基本原理是：状态机 &amp;gt; 在 state1 时，A B 都有 100；A 发起了一笔交易，支付 100 给 B，而这笔交易会被区块链系统记录下来。 我们可以通过 state1 的账户余额和区块链上的交易记录，计算出 state2 时 A B 的账户余额：A 有 50，B 有 150。  双重支付 描述  去中心化记账过程中遇到的双重支付的问题  双重支付就是同一笔钱可用于两次支付 &amp;gt; A 将 100 元，既支付给 B，又支付给 C。如果出现这种情况，A 就相当于把 100 元钱，当做 200 元钱来花了。 在中心化的记账系统中，无论这两笔交易是否同时进行，中心化的记账系统处理这两笔交易一定会有一个先后顺序。 去中心化的记账系统中的一些节点会先收到 B 的交易信息；另一些节点会先收到 C 的这笔交易信息。在去中心化的记账系统中，所有节点都是平等的。   处理  确定交易信息的先后顺序；
 确定交易顺序的数据结构就是区块链。 “区块链”中的“区块”，指的是在同一段时间内的交易信息及相关数据的集合；“链”就是把区块按产生的先后顺序连接在一起。  需要一个共识机制，来保证所有节点都认可这个顺序。
 共识机制是区块链系统上独立节点们通过遵守一套相同的规则，自发地对区块的先后顺序达成共识。  所有节点质押成本(如：算力)竞争记账权，由胜利者产出并广播区块(记账信息)，并获得收益(如，比特币)奖励。  保障了每个节点都会出于“自私”的目的，“诚实”地参与到区块链系统中来。  “自私”指的是，节点都是为利润(收益 - 成本)而来。 “诚实”指的是，遵循区块链的共识机制。   每个节点独立的对新区块进行验证，并组装进区块链。  保障了每个节点都可以对竞争胜出的节点的记账信息进行校验。 保障了颠倒交易的先后顺序在经济上是不可行的。  当捣乱链的长度，超过诚实链的长度的时候，整个交易的顺序就被颠倒过来了。 捣乱节点可以在某个节点 Fork 原先的链，再用比诚实节点更快的速度，制造出一个最长捣乱链。 在技术上是有可能的，但是经济上是没有可能的。 &amp;gt; 买通 51% 的节点才能在制造区块的速度上，超过剩余 49% 的诚实节点。 假使捣乱节点只要制造 6 个节点即可成功捣乱，制造 6个捣乱节点需要 60*60s。 也就是说，捣乱的土豪至少要支付 51% 的节点在 1 个小时内所花费的算力成本。 比特币系统的全球算力为 9211434 TH/s； 1 TH/s 算力大概要消耗 0.15 度电，每度电 0.32 元。 这个捣乱的土豪至少需要付出 8 亿人民币。 51% * 921143 * 0.15 * 0.32 * 60 * 60 = 811785256   每个节点对区块链进行独立选择，选择长度最长的区块链。    机遇  区块链技术的本质是通过公开的、加密的不可篡改的技术手段，为解决多方信任问题提供了一个方案。 最关键原因是每秒确认交易的笔数太少、确认交易的时间又太长  </content>
    </entry>
    
     <entry>
        <title>恩佐·法拉利博物馆</title>
        <url>http://domain.yqjdcyy.com/post/%E6%81%A9%E4%BD%90%E6%B3%95%E6%8B%89%E5%88%A9%E5%8D%9A%E7%89%A9%E9%A6%86/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>汽车</tag>
        </tags>
        <content type="html">  恩佐·法拉利博物馆 参考  恩佐·法拉利博物馆 List of Ferrari competition cars  简介 经典车型  GTO F40 F50 EnzoFerrari LaFerrari  经典系列  250 系列 Dino  经典赛车 F40  1987年在法兰克福车展首次亮相 庆祝建厂40周年而设计的 第一台时速能超过320km/h（最高极速324km/h）的民用跑车 创始人恩佐法拉利带领他的设计制造团队完成的最后一部法拉利作品   GTO  品牌释义是“天地之间，任我驰聘” 于1962年推出的250 GTO曾经横扫GT类比赛   F50  纪念建厂50周年发布了旗舰级超级跑车   Enzo  作为法拉利F50的替代品 于2002年制造，采用12缸中置引擎 采用了大量F1的技术，并配备F1的顺序换档变速箱和超大的碳纤陶瓷刹车碟 舒马赫也参加了该车的开发 官方0-100km/h加速为3.65s 极速则达到了350km/h以上   LaFerrari  于2013年3月在日内瓦车展首次亮相 限量499台 0-100km/h加速时间&amp;lt;3 秒。极速高达350km/h以上   F60America  庆祝北美分公司成立60周年推出 限量发售10台，售价高达$320万美元   Ferrari Superamerica  兼备法拉利12缸berlinetta的卓越性能以及多功能敞篷车上各种独创设计的优点 首个采用创新型旋转车顶的跑车 采用了专为大型玻璃表面研发的电致变色技术，在数秒之内即可将车辆从双门小轿车变身为敞篷跑车。   </content>
    </entry>
    
     <entry>
        <title>第二届创始人代表大会</title>
        <url>http://domain.yqjdcyy.com/post/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%88%9B%E5%A7%8B%E4%BA%BA%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A/</url>
        <categories>
          <category>工作</category>
        </categories>
        <tags>
          <tag>会议纪要</tag>
        </tags>
        <content type="html">  第二届创始人代表大会 流程  14:00  集合  14:30  各人发言  针对产品和公司的想法 现阶段的阻碍和思考 冲刺方向的准备   15:00  问答规类  公司形态 战略方向 流程合理化 996 等相关企业文化  三巨头逐一回答  19:00  晚餐  19:30  三巨头继续回答  23:30  散会   初步结果 反思 个人  诉求
 情感  部分人需要的是认同感 部分人需要的是参与感 部分从暂无相关表述  工作内容  已放弃，或者更努力接受许式伟提及的服务观念  技术人员应该考虑你提供的是一项服务，而不是一项特有的技术 实现优先，技术权衡    定位
 位置决定你以什么角度来思考 而给予对应定位的权利和利益后，你才会认可并真正坐到这个位置  敌视态度
 恋爱般错误合作观  三巨头对于其它合伙人的态度不容乐观  发言时，A对其它人发言时的表情、眼神 期间提到B对于家人的关爱和三巨头之间的交流沟通甚密之事，理解其实是可以做到的，但不需要对你做 对于真正诉求，不具备耐心；仍然存在辩论过于讨论  长达八小时的会议，毫无成果的讨论  对比携程的反思讨论会  200人3小时 下级直接对 CEO 提出尖锐的问题，及得到的经过认真思考的回复     个人对于公与私的要求或期望过于模糊、过界  期间数次情绪无法自控  好听点，是对团队仍存在依赖和信赖 不好听，个人情商、情商严重不足，对于其中的游戏规则思考不足  毕竟害人之心不可有，防人之心不可无！ 建议下次携带笔记本，做笔记转移、思考    个人主动越级沟通？  思考位置不同，深度和思考范围不同 对方是否想听这方面的意见，你需要自觉听懂客套话 所以想到半夜三点时，我放弃了  因为觉得根本上的原因，他并不想听    期权、股权  请配合定位进行，除了个人定位问题，觉得三巨头在对其它人的定位上，也存在着如上的问题 历史  2016.8  离开原有岗位，全职投入  咱们是厦门最牛逼的技术团队   2016.12  天使轮  就是靠A 和B 我们俩才拿到的   2017.2  年会，氛围全然改变 获得期权-承诺书  权益值基本等于离职出来，工资* 2，比例 0.X% 无合同，无投票权 第一次信任危机   2017.5  A 提及之前有人知道创业之事后，提示需要签订事前合同，确认股份而非期权  但出于信任，拒绝了 后面看到书面材料，都不知道摆出什么表情   2017.7  被告知天使轮前，快支撑不下去但未及时告知  第二次信任危机   2017.11  第一次创始人会议  CTO任职  后缀仅邮件，相关职业并未变更 理解仅义务没权利，主职接锅，次职架构       表达
 个人表达能力不足  没想清楚，没站在至高点 不愿意重申、多种角度去改变、尝试让别人理解  觉得懂不懂没意义的心态  自己更适合碎片化的语言整理   零碎
 公司的成功，个人尝试的实践，个人收益的稳定和成功  那么，你们屁都不会放一个    公司  战略  第四次转型  会议 个人 机构&amp;amp; 大型企业 中小企业  新一期上线内容的预定目标和潜在目标 转移于服务中小型企业  思路  智询 MBA/ 阿里/ 京东 提供数百万中小型企业 AMA、秦训等提供优质课程 而由公司提供通路产品用以串联  疑惑  中间任一断路的后果 营收点 对合伙人的说词，还是画饼居多    结果决定你的想法  因为现在处于初步阶段，一切不顺利，所以你觉得都是问题 而如果现在已然是大公司，钱多事少，那你一定在找理由邀功讼德  然而并不觉得，因为很多问题就在那，你不解决就不可能过去   针对 996 等加班文化  A 说 996 本来就不需要，要取消 B 说 996 之所以这么做，是因为我发现你们有人请假了，也不用加班，后面也一样做完了 集体的尝试和努力，被粗暴地否决  感觉在大家等待结果的第一步的成果时，来自 A的立即反驳，就导致了初燃的激情又消失了 后面知道仅因为单个人的因素，导致了多数人的灾难，觉得 A的说法实在不合理 后面听 C 说，才知道是 D 个人影响导致 但觉得这种多少算以偏盖全，而且当初 B 就没办法让 D 做到，却又换任后立马要求 C 立马能让 D 做到  本身这事就不公平     换位  CEO 的岗位上，不可能和所有的人交心  与三四个负责人持续跟进就可以  996的思考  并非好的解决方法 选择了，就应该相信，支持对方去尝试自己的方法  而不应该再持续为施压、影响当前的思路  人不可能是自觉的，但可以互相影响  比如前端追着服务端要接口，测试找前端要时间，产品根据测试反馈以得到整理进度，而服务端反思产品的设计   交流  和小你多级，或者你以为的远不如你的人，请尝试听对方真正想表达的点 别人是最愿意、最敢和你说的人   </content>
    </entry>
    
     <entry>
        <title>伏特加</title>
        <url>http://domain.yqjdcyy.com/post/%E4%BC%8F%E7%89%B9%E5%8A%A0/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>酒</tag>
        </tags>
        <content type="html">  伏特加 参考  无论打冷战还是“冷战”，伏特加永不退场！！  Banya桑拿浴  美国大厨兼作家安东尼伯尔顿 &amp;gt;在气温零度的日子，湖边小浴场最适合这种桑拿浴——你要先在长凳上趴好，被拿着一捆泡过水的白桦树枝，对你的背部一顿猛抽。 当你被抽得浑身发烫，每个毛孔都张开之时，开门直通结冰的湖面，这时你要瑟瑟发抖地穿过冰湖到达对面 你的奖励是一杯伏特加。   定义  伏特加是可由一切农作物制成的烈酒，一般是谷物与马铃薯。  发酵完成后的发酵液经柱式蒸馏器蒸馏成不低于95度的中性酒精，以优质水源稀释至40度左右。  俄罗斯当代作家叶罗菲耶夫 &amp;gt; 对于俄罗斯人来说，喝伏特加的过程不是最重要的，结果才是，你甚至可以把伏特加注射到你的静脉里。  战争  战争中的必需品  原料中必须含有足够的谷物和马铃薯 二战时期，军方给每名士兵每天派发100毫升伏特加，坦克兵200毫升。  弗拉基米尔一世当年决定推行东正教的一大原因就是其他宗教不允许喝酒。   电影 极寒之城  查理兹·塞隆 Lorraine从倒满冰块的浴缸里出来，随手捞出几块冰扔进脚边的玻璃杯里，倒酒，举杯，一饮而尽。  背景音乐  David Bowie The Queen George Michael Nena     推荐 Tito’s Handmade Vodka  产地  美国  味道  美国手工伏特加的先驱者，以玉米为原料，有着独特的甜玉米、蘑菇、白胡椒般的气息。    Sipsmith Barley Vodka  产地  英国  味道  以英国麦芽为原料，小规模铜质蒸馏器蒸馏，未经过滤，有着圆润的香草与饼干滋味。    Black COW Pure Milk Vodka  产地  英国  味道  100%全脂奶发酵后蒸馏而来的伏特加，在辛辣之余多一层迷人的奶香。    </content>
    </entry>
    
     <entry>
        <title>ImageMagick</title>
        <url>http://domain.yqjdcyy.com/post/imagemagick.basic/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>ImageMagick</tag>
        </tags>
        <content type="html">  ImageMagick Reference  官网  Anatomy  convert|composite|montage|compare|import|conjure [input filenames] [image settings] [image operators] [sequence operators] [stacks] [output image filenames]  Input FileNames FileName Globbing  Analysis  pattern match about */?  Example
 convert *.jpg images.gif
Explicit Image Format  Analysis
 specified a explicit image format is better than in the case of the image donot contain a signature of identify format  Example
 convert -size 640x480 -depth 8 rgb:image image.png
Built-in Image and Pattern  Analysis
 you can use a number of built-in image/ patterns to build image  Example
 convert -size 640x480 pattern:checkerboard checkerboard.png
STDIN·STDOUT·File Descriptors  Analysis
 output could be piped to the input fd:[0/1/2] -&amp;gt; STDIN/ STDOUT/ STDERR fd:N(N&amp;gt;2) -&amp;gt; pseudonym for file  Example
 convert rose: gif:- | convert - -resize &amp;ldquo;200%&amp;rdquo; bigrose.jpg&amp;rsquo;
 ! no work for me in linux
Selecting Frames   Analysis
 deal with the image which has more than one frames Unix shells generally interpret brackets so we enclosed the filename in quotes above  Example
 convert &amp;lsquo;images.gif[0]&amp;rsquo; image.png convert &amp;lsquo;images.gif[-1]&amp;rsquo; image.png  last frame  convert &amp;lsquo;images.gif[0-3]&amp;rsquo; image.png  stash into image-[0-3].png  convert &amp;lsquo;images.gif[3,2,3]&amp;rsquo; image.mng
 .mng support for multi frames
Selecting an Image Region   Analysis
 select a part region of the origin image as a new one  Example
 convert -size 100x100 &amp;lsquo;hexagons.png[50x50&#43;25&#43;25]&amp;rsquo; hexagon-50x50.png convert &amp;lsquo;hexagons.png[30x30&#43;35&#43;35]&amp;rsquo; hexagon-30x30.png
Inline Image Resize  Analysis
 resize iamge  Example
 convert mid-frame-0.png -resize 100x100 mid-frame-0-resize-100x100.png convert &amp;lsquo;mid-frame-0.png[1000x1000]&amp;rsquo; mid-frame-0-resize-1000x1000.png
Inline Image Crop  Analysis
 crop the region of image  Example
 convert &amp;lsquo;*.jpg[120x120&#43;10&#43;5]&amp;rsquo; thumbnail%03d.png
Filename References  Analysis
 user file or pattern to stash filenames  Example
 convert @mid-frame.txt mid-frame.gif  frame001.jpg frame002.jpg frame003.jpg  convert image-%d.jpg[1-5]
 image-1.jpg image-2.jpg image-3.jpg image-4.jpg image-5.jpg
Stream Buffering   Analysis Example
 convert logo: gif:- | display -define stream:buffer-size=0 gif:-   Command-line Options ImageSetting Image Operator Image Sequence Operator Image Geometry Image Stack Example  添加全屏水印图
 composite -tile /data/cdn/resource/repeat.png /data/tmp/yao/from/yk-white.jpg /data/tmp/yao/from/yk-white-repeat.jpg   于指定位置添加水印图
 convert slide-rId3.jpg &amp;quot;/data/cdn/resource/logo.png[300x100]&amp;quot; -gravity northeast -geometry &#43;24&#43;20 -composite jpg:- | convert - slide-rId3-logo.jpg   添加文字水印
 失败 convert -size 140x80 xc:none -fill grey -gravity NorthWest -draw &amp;quot;text 10,10 &#39;live.yunkai.com&#39;&amp;quot; -gravity SouthEast -draw \&amp;quot;text 5,15 &#39;live.yunkai.com&#39;\&amp;quot; miff:- | composite -tile - slide-rId3-font.jpg slide-rId3-font-watermark.jpg convert slide-rId3.jpg -gravity southeast -fill white -pointsize 16 -draw &amp;quot;text 5,5 &#39;http://live.yunkai.com&#39;&amp;quot; slide-rId3-font-watermark.jpg  图片质量调整
 convert -quality 75 slide-rId3.jpg slide-rId3-075.jpg    动态图倒放
 convert from.gif from/%d.png ls -[r]t from | paste -s -d convert -delay 10 - all.gif   </content>
    </entry>
    
     <entry>
        <title>许式伟</title>
        <url>http://domain.yqjdcyy.com/post/%E8%AE%B8%E5%BC%8F%E4%BC%9F/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>商业</tag>
        </tags>
        <content type="html">  参考  许式伟：十一年逆流顺流，首席架构师到CEO  问答 创业公司做这种重大决策要冒很大风险，能不能谈谈做这些决策背后的思路？  选择和信息的对称程度有关系。  当你越不了解一个东西，越会趋向选择保守性的方案，而当你对某个领域了解得足够透彻，你的决策过程会非常自然。 当你深入研究了新技术的思考方式，以及它要解决的问题，就会知道它和自己要解决的问题有多大的相关性。  Go把其全新的编程理念，称为[面向连接的语言]    不迷信权威，独立思考的思维方式，是从什么时候形成的？这种思维方式给你带来了哪些益处？  凡事都要问个为什么，要有打破沙锅问到底的精神，不可人云亦云。 这个世界没有学科之分，计算机、代数、物理，并没有非常明显的边界。 想用更低的成本去存，就要用到域代数。从这10份数据里取出一份校验数据，数据变成了11份，它的冗余度是1.1。  存储的未来还会有哪些趋势？  如何能让存储系统在常温、不耗能的情况下运行，是接下来我们要面临的一个重要问题。 创业是一个不断降低不确定性的过程，刚开始创业的时候，充满了各种不确定性和不可控性，但不能停滞不前。 对针对数据的使用场景，帮助客户做标准化处理，实现数据价值的最大化。 目前存储最多的数据是图片，图片用户的典型使用场景，是需要不同尺寸的缩略图，我们提供了这样的功能，用户就省心多了，不用去重复去建设这个过程。  毕业后仅用2年时间，就成为WPS的首席架构师，这个过程是如何实现的？  分配给我的任务，是软件的读盘和存盘模块。  要求你理解软件的所有功能，以及每个功能的数据表达方式。 软件系统最核心的东西——数据。顺着这条线索，我研究了微软Office各个功能模块的数据存储方式，据此修改原有软件的设计。 为了实现对微软Office文件格式的兼容，I/O成了战略层面的技术，存盘功能从边缘模块，一下变成了整个WPS研发的核心模块。 随着对存储更深入的理解，我们在软件架构层面做出了创新，引入了一个数据层，抽象出所有数据的存储过程。 数据层带来的好处，是让所有的数据天然可回滚，可以轻松支持多版本存盘、Undo/Redo（撤销/重做），以及各种异步操作。  任何一件事情，想要做到极致，必须把它当成一个学科来研究，把它琢磨透。  金山向互联网转型的这个阶段，也是你自己职业生涯中很痛苦的阶段，你是如何度过的？  如果产品无法让最终用户买单，从某种意义上说，你的价值并没有被认证。 2006年是我成为产品人的开始，一下子感觉到光有技术真的不行，必须理解业务及其运作方式，思考产品和商业的关系。  一方面广泛参加行业里的会议、沙龙，找不同朋友聊产品方向。 另一方面，我做了一个技术社区ECUG，探讨Server端相关技术演进。这期间，我逐渐跳出办公，横向接触其它领域。   后来你离开金山去盛大，又经历了哪些故事？  执行得不如预期，同时高层有一些不好的声音，认为这个部门短期难以见到利益。 盛大创新院，但在早期，就已经有迹象能看出来它做不成。  样板还没树立起来，就急速扩张。 整个创新院的扶持职能一直没有形成，某些做法甚至对创业有抑制作用。   七牛创立过程中遇到过哪些困难？你怎么看待云计算领域的竞争？  七牛2011年6月正式成立，一开始的产品方向是网盘，9月中旬产品发布，10月决定转向底层存储，期间就花了一个月思考。  当时国内云计算环境还不够好，七牛如果做网盘，很难找到一个第三方存储供应商。 团队的基因偏极客，对终端用户并不那么了解，如果不清楚用户的喜好和习惯，很难做出打动他们的产品。  今天我对竞争的考虑比以前要成熟，在金山的时候，眼里光盯着微软，这其实是不对的。  任何一个新兴的东西，都在颠覆旧有的秩序。 真正的思考应该关注：用户群体为什么需要我们？以及我们到底在颠覆什么？  应该考虑你到底要做什么，再考虑你应该如何做。  从技术到管理是一道坎，你从什么时候开始对管理产生兴趣？  小team自然而然会形成好的协同方式  不要过度优化 企业运营过程也类似，你得观察公司当前的门槛是什么，有针对性地去做优化。  创业团队发展必然经过研发、营销、管理这三大门槛，创始人在不同阶段，关注的侧重点会有所不同。
 开发阶段关注的重点，是研发效率问题； 接下来的重点是营销，让更多人知道你的产品； 第三阶段则要关注如何在人数扩张的情况下，仍然保持团队间的协同效应。  如何构建出一个协同良好的团队
 用自组织团队取代自上而下的组织架构  搭建出全职能的小团队 团队成员可自行选择、自发形成、相互欣赏，而不是由上级强行组建，以保证协作的通畅性  用服务认知取代工种认知  很多人认为自己到三十岁之后就不能做程序员了，原因就是基于工种认知。 我为谁提供服务的认知，比我是哪个领域的程序员更重要  服务认知首先要知道自己的代码有人用才有价值 你就得去思考我为什么要做这个服务？为了把服务做好，要做哪些功能？某个功能为什么会受到用户群的欢迎。 所有的人都是产品经理的概念，落实到最终执行，就是弱化工种意识，把服务放到最核心的维度。  “补位意识”，如果短期招不到某方面的人，有可能的话，我自己去补上    许多创业公司都面临招聘困难的问题，你如何解决这个难题？  想清楚你对人才的吸引力在哪里，想清楚你需要什么样的人。  让每一个进来的人靠谱，比让更多人进来更重要。  如果在分布式工作的情况下，还能保持很高效的协作能力，自然能跨地域获取人才。  做CEO之后，你怎么平衡自己的时间？  这个时代的CEO必须是首席产品官，你得知道用户在想什么。  因为所有决策的依据一定是来自用户的反馈，如果离开了这个重要的信息来源，想法可能会和现实出现较大差距。 确保产品方向正确 确保整个公司的运作机制足够高效  想了解公司当前的最大瓶颈，只能从一线获得信息  review代码，以了解公司的研发效率是什么水平，还有什么样的提升空间 离员工越远，决定就越盲目     你从草根创业者成长起来，怎么看待社会上升通道的抑制？  在教育，中国的教育体制偏命令式、填鸭式，告诉学生们一堆知识，而不是激发学生思考背后的为什么。 政府资源整个偏向大公司，对创业的扶植力度不够。  美国政府努力去政府职能化，甚至连造火箭这样的事，都是民营企业在玩。 与其抱怨，不如花点精力去做你觉得能让这个社会变好的事情。   思考 业务  核心业务未定位清楚  想做什么，服务提供，还是一体化服务商？ 目标客户？ 营业目标？套融资？卖公司？  不能够用战术上的勤奋，掩盖战略上的愚蠢
机制 现有团队组织形式，成员自升级，但最上级存否认态度
 两者并不存在问题，因为都是为了整体达到最优状态，只是战略上定义不清，导致迷之敌对
  </content>
    </entry>
    
     <entry>
        <title>Linux.Crontab</title>
        <url>http://domain.yqjdcyy.com/post/linux.crond/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Linux.Crontab 简介  用来周期性的执行某种任务或等待处理某些事件的一个守护进程 系统任务调度
 系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等 /etec/crontab
SHELL=/bin/bash # 指定 Shell 版本 PATH=/sbin:/bin:/usr/sbin:/usr/bin # 指定系统执行命令的路径 MAILTO=&amp;#34;&amp;#34; # 指定 crond 任务执行消息将通过指定邮件发送给 root 用户 HOME=/ # 指定在执行命令谨脚本时使用的主目录 # run-parts 51 * * * * root run-parts /etc/cron.hourly 24 7 * * * root run-parts /etc/cron.daily  用户任务调度
 用户定期要执行的工作，比如用户数据备份、定时邮件提醒等 /var/spool/cron   配置  /etc/cron.deny  列举不允许使用 crontab 命令的用户  /etc/cron.allow  列举允许使用 crontab 命令的用户  /var/spool/cron/  所有用户 crontab 文件存放的目录   格式  minute hour day month week command  字段  minute  0- 59  hour  0- 23  day  1- 31  month  1- 12  week  0- 7  0和 7 均代表星期天   command  可选项  *  所有可能值  ,  值列表，如 1,2,5,7  -  值范围，如 2-6  /  指定间隔频率，如 */10，表示每隔十分钟执行一次   说明      服务  /sbin/service crond [start|stop|restart|reload|status] ntsysv  查看服务是否设置为开机启动  chkconfig -level 35 crond on  将 crond 加入开机自动启动  ntsysv | chkconfig --list  查看 crond 是否已添加至开机启动  chkconfig –level 35 crond on  将 crond 添加至开机启动 本地尝试无果   格式  crontab [-u user] file crontab [-u user] [-l | -r | -e] [-i] [-s] crontab -n [ hostname ] crontab -c  参数  -u &amp;lt;user&amp;gt;  调用指定用户 &amp;lt;user&amp;gt; 名下的定时任务  -l  于标准输出流中展示当前的定时任务列表  -r  移除当前定时任务  -e  以 视图 或 编辑器 编辑，并于离开编辑器时，修改的定时任务将自动被安装  -i  配合 -r 使用，用于删除前的提示，避免误操作  -s  于定时任务编辑或替换发生前，追加安全内容字符串作为 MLS_LEVEL 设置  -n  配合 -c 使用，支持集群 设置集群主机，用于运行 /var/spool/cron 下的定时任务 若提供主机名被匹配，将被选择运行指定的定时任务；若无主机匹配，则定时任务不再运行；而若主机名被忽略，则当前主机升级为默认主机 参数不影响 /etc/crontab 和 /etc/cron.d 中的定时任务的运行  -c  允许支持集群，用于查询当前集群中哪台主机用于执行 /var/spool/cron 中的定时任务   事例 异常  no crontab for root  crontab -l 时触发，因为该用户第一次使用，尚未生成对应文件导致 可使用 crontab -e 后保存以解决   参考  每天一个linux命令（50）：crontab命令 Linux之crontab定时任务  </content>
    </entry>
    
     <entry>
        <title>Linux.Expect</title>
        <url>http://domain.yqjdcyy.com/post/linux.expect/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Linux.Expect 参考  expect spawn、linux expect 用法 expect spawn、linux expect 用法小记  作用  代替实现与终端的交换，根据系统的输出运行相应的命令 需要 Tcl 编程语言的支持  参数 Run  -c  在命令行中直接执行  i  脚本把多个参数当成一个连续的列表 事例  expect -i arg1 arg2 arg3   d  输出调试信息  D|Debug
 用于是否立即启动调试器，后面接入参数 0/1 事例
 expect -c &#39;set timeout 10&#39; -D 1 -c &#39;set a 1&#39;
 优先执行 set timeout 10 调适器启动后执行 set a 1
SPAWN    -re
 表示指定的字符串是一个正则表达式  eof
 标识子进程已结束   安装  whereis tcl  yum install tcl  whereis expect  yum install expect   事例  自动登录  #!/usr/bin/expect set timeout 30 # 设置延时 30 秒 spawn ssh -l username 192.168.1.1 # 进行 expect 模式，为后续运行进程加壳以传递交互指令 expect &amp;quot;password:&amp;quot; # 判断上一次输出结果是否包含 `password:`，有则继续执行后续指令 send &amp;quot;ispass\r&amp;quot; # 执行交换指令，输入 `ispass` 并回车 interact # 完成后保持交互状态，把控件权交给控件台   </content>
    </entry>
    
     <entry>
        <title>约翰·帕森</title>
        <url>http://domain.yqjdcyy.com/post/%E7%BA%A6%E7%BF%B0-%E5%B8%95%E6%A3%AE/</url>
        <categories>
          <category>艺术</category>
        </categories>
        <tags>
          <tag>建筑</tag>
        </tags>
        <content type="html">  约翰·帕森 简介  John Pawson，极简主义之父，师从传奇设计大师仓俣史朗  参考  极简主义大师：约翰·帕森  风格  极简主义  作品  Moritzkirche教堂 以色列特拉维夫W酒店样板房 Hotel Puerta Picornell House St Tropez Houses North Sea Apartment  赏析              </content>
    </entry>
    
     <entry>
        <title>Hello.UML</title>
        <url>http://domain.yqjdcyy.com/post/uml/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>UML</tag>
        </tags>
        <content type="html">  UML 参考  看懂UML类图和时序图  大纲    使用  StarUML  UML.mdj   </content>
    </entry>
    
     <entry>
        <title>Linux.Lsof</title>
        <url>http://domain.yqjdcyy.com/post/linux.lsof/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  参考  lsof 一切皆文件  功能  查看当前系统文件的工具 支持文件类型  普通文件 目录 网络文件系统的文件 字符或设备文件 函数共享库 管道、命名管道 符号链接 网络文件（NFS、Socket）   参数  -a  列出打开文件存在的进程  -c &amp;lt;进程名&amp;gt;  列出指定进程所打开的文件  -g  列出GID号进程详情  -d &amp;lt;文件号&amp;gt;  列出占用该文件号的进程  &#43;d &amp;lt;目录&amp;gt;  列出目录下被打开的文件  &#43;D &amp;lt;目录&amp;gt;  递归列出目录下被打开的文件  -n &amp;lt;目录&amp;gt;  列出使用NFS的文件  -i &amp;lt;条件&amp;gt;  列出符合条件的进程。（4、6、协议、:端口、 @ip）  -p &amp;lt;进程号&amp;gt;  列出指定进程号所打开的文件  -u  列出UID号进程详情  -h  显示帮助信息  -v  显示版本信息   示例  lsof | more
 Result
   COMMAND PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAME     进程名称 进程标识符  进程所有者 文件描述符 文件类型 指定磁盘 文件大小 索引节点 打开文件的确切名称   systemd 1  root cwd unknown    /proc/1/cwd(readlink: Permission denied)    FD
 cwd  表示current work dirctory，即应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改  txt  该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序  lnn  library references (AIX);  er  FD information error (see NAME column);  jld  jail directory (FreeBSD);  ltx  shared library text (code and data);  mxx  hex memory-mapped type number xx.  m86  DOS Merge mapped file;  mem  memory-mapped file;  mmap  memory-mapped device;  pd  parent directory;  rtd  root directory;  tr  kernel trace file (OpenBSD);  `v86 VP/ix mapped file; 0  表示标准输入  1  表示标准输出  2  表示标准错误一般在标准输出、标准错误、标准输入后还跟着文件状态模式- r、w、u等  u  表示该文件被打开并处于读取/写入模式  r  表示该文件被打开并处于只读模式  w  表示该文件被打开并处于只写模式  空格  表示该文件的状态模式为unknow，且未被锁定  -  表示该文件的状态模式为unknow，且被锁定,同时在文件状态模式后面，还跟着相关的锁  N  for a Solaris NFS lock of unknown type;  r  for read lock on part of the file;  R  for a read lock on the entire file;  w  for a write lock on part of the file;（文件的部分写锁）  W  for a write lock on the entire file;（整个文件的写锁）  u  for a read and write lock of any length;  U  for a lock of unknown type;  x  for an SCO OpenServer Xenix lock on part of the file;  X  for an SCO OpenServer Xenix lock on the entire file;  space  if there is no lock.   TYPE
 DIR  表示目录  CHR  表示字符类型  BLK  块设备类型  UNIX  UNIX 域套接字  FIFO  先进先出 (FIFO) 队列  IPv4  网际协议 (IP) 套接字    lsof -i :6666 -r 3
 每三秒查看端口占用情况  lsof error.log
 查看指定文件的相关进程  lsof -u appuser | more
 查看用户 appuser 打开的文件列表  lsof -c java | more
 查看 Java 进程所打开的文件  lsof -p 12617 | more
 查看 12617 进程所打开的文件  lsof -n -i tcp | grep LISTEN | less
 查看处于连接状态的 TCP 连接   </content>
    </entry>
    
     <entry>
        <title>网络.七层协议</title>
        <url>http://domain.yqjdcyy.com/post/%E7%BD%91%E7%BB%9C-%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>网络</tag><tag>OSI</tag>
        </tags>
        <content type="html">  参考  深入浅出－网络七层模型&amp;amp;&amp;amp;网络数据包 网络七层协议  定义  网络七层协议，理论模型 OSI（Open System Interconnection）    分层 应用层  直接为应用进程提供服务  根据提供的特性分组，称为服务元素  公共应用服务元素 CASE  所有用户可用，主要为应用进程通信，分页系统的基本控制机制  特定应用有服务元素 SASE  特定服务，如文卷传送、访问管理、银行业务等    示例  HTTP FTP SMTP/ POP3/ IMAP4 TELNET   表示层  定义数据格式、加密  如 FTP 下可选择以二进制或 ASCII 格式传输  懂中机通信的公共语言  IBM 主机使用 EBCDIC 编码 通用 PC 机采用 ASCII 码 转换以保证一致的数据形式  示例  ASCII EBCDIC  解决不同系统间的通信  LPP NBSSN   会话层  如何开始、同步和结束一个会话  使用校验点来保证通信失效后，由该校验点进行通信恢复 将会话地址映射为 IP 地址  示例  RPC SQL SSL TLS DAP   传输层  选择[无]差错恢复协议，在同一主机上对不同应用的数据流复用  对接收顺序有误的数据包排序  端对端数据的缓存层 面对会画层的界面端口 示例  TCP UDP SPX  端口通信    网络层  定义端对端的包传输 定义所有结点的逻辑地址，进行 路由|寻址 定义如何将包分解成更小的包的分段方法 示例  IP/ IPv6 EGP AHH/ ESP   数据链路层  定义在单个链路上如何传输、拆解包 每次通信时，建立起来的数据收发关系  链路连接的建立、拆除和分享 帧定界、同步 差错检测和恢复 链路标识、流量控制  示例  PPTP/ L2TP/ L2F/ ATMP ARP/ RARP  产品  网卡 网桥   物理层  为通信的两个数据终端设备提供连接，形成通路  将信息编码转换为电流脉冲或其它信号形式进行传输 方式  点对点 单点对多点 串行|并行 半双工|全双工 同步|异步   与传输介质有关  涉及连接头、帧、帧的使用、电流、编码、光调制等  示例  Rj45 将数据转换成 0|1 802.3   理解  应用层  入口 如动车站购票点、网上购票  表示层  定义编码、通用协议 如各国人购票（无座、二等座、一等座）  会话层  IP 映射&amp;amp; 会话 如动车站  传输层  缓冲 如动车站、安检  网络层  寻址&amp;amp;路由 如列车长  数据链路层  传输、分发、流量控制 如站点  物理层  实际路线 如铁轨   </content>
    </entry>
    
     <entry>
        <title>网络.四层协议</title>
        <url>http://domain.yqjdcyy.com/post/%E7%BD%91%E7%BB%9C-%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>网络</tag><tag>TCP/IP</tag>
        </tags>
        <content type="html">  参考  TCP/IP四层模型 深入浅出－网络七层模型&amp;amp;&amp;amp;网络数据包 TCP/IP四层模型 OSI七层和TCP/IP四层的关系  定义  网络事实上的标准 又名 TCP/IP 协议族或 TCP/IP 协议栈  Transmission Control Protocol 传输控制协议 Internet Protocol 互联网协议      分层 应用层  定义  = OSI.应用层&#43; OSI.表示层 &#43; OSI.会话层  示例  FTP/ TELNET/ HTTP   传输层  定义  = OSI.传输层 对数据进行缓存、报文的拆解和重组  示例  TCP  传输控制协议 transmission control protocol  UDP  用户数据报协议 user datagram protocol    网间层  定义 = OSI.网络层  将数据分组，并沿不同路径同时传递 定义分组格式和协议，即 IP 协议 支持不同类型网络的互连  示例  IP   网络接口层  定义  = OSI.物理层&#43; OSI.数据链路层   概念  报文    套接字  套接字= IP地址&#43; 端口号  三次握手     </content>
    </entry>
    
     <entry>
        <title>中国-福建-厦门</title>
        <url>http://domain.yqjdcyy.com/post/%E4%B8%AD%E5%9B%BD-%E5%8E%A6%E9%97%A8.%E7%BE%8E%E9%A3%9F/</url>
        <categories>
          <category>美食</category>
        </categories>
        <tags>
          <tag>中国</tag><tag>福建</tag>
        </tags>
        <content type="html">  美食 - 厦门 参考  吃遍了厦门正港美食，本地人有张清单想告诉你~  沙茶面  菜品 炸豆腐 猪肝沿 瘦肉 剔骨肉 鸭胗 推荐店铺 沙糖 月华 思明区镇邦路78号，民立小学对面 开禾 思明区厦禾路126号  龟苓膏  菜品 苦茶 西米露 西多士 推荐店铺 陈佳甜品 思明区镇邦路65号  大排档  菜品 醋肉 腰花 花菜大肠煲 豆干炒肉 炒泡面 炒法海瓜子 推荐店铺 良山大排档 海鲜一般，尽量错开就餐时间 思明区开元路250号（第八菜市场内） 202海鲜大排档 思明区斗西路108号 夏商海鲜批发市场 夏商中埔食材批发商城 兴旺海鲜城 湖里区港中路1453号A138-143  卤味  菜品 鸡翅 鸡爪 推荐店铺 真真卤味 思明区蜂巢山路20-104号  鸭肉粥  菜品 鸭肉粥 推荐店铺 浮屿大同鸭肉粥 思明区厦禾路174号 厦港大同鸭肉粥 思明区思明南路378号  花生汤  菜品 花生汤 酥脆韭菜盒 糯米炸 推荐店铺 思北花生汤店 思明区思明北路64号  潮福城  菜品 虾饺皇 推荐店铺 轮渡店 思明区鹭江道33号3楼 滨北店 思明区湖滨北路28号建业大厦裙边  客家菜  菜品 酒香河田鸡 黄骨鱼焖豆腐 推荐店铺 鑫客家客家菜 湖里区仙岳路601号  盐鸭  菜品 盐鸭 推荐店铺 阿呆盐鸭 到下午一点前 同安区东山路55号  封肉  菜品 封肉 推荐店铺 同安区祥福市场阿呆盐鸭角落  马蹄酥  菜品 素净马蹄酥 喜饼 推荐店铺 双鹿老铺 同安区南门路46号1楼  海蛎炸  菜品 海蛎炸 推荐店铺 林添发匙仔炸 集美区灌口小叮当幼儿园附近 坤赐小吃 同安区东山路47号（在阿呆旁边哦）  </content>
    </entry>
    
     <entry>
        <title>中国-福建-厦门-同安</title>
        <url>http://domain.yqjdcyy.com/post/%E4%B8%AD%E5%9B%BD-%E5%8E%A6%E9%97%A8-%E5%90%8C%E5%AE%89.%E7%BE%8E%E9%A3%9F/</url>
        <categories>
          <category>美食</category>
        </categories>
        <tags>
          <tag>中国</tag><tag>福建</tag>
        </tags>
        <content type="html">  参考  揣着100块钱来同安吃1整天！  路线  T4候机楼站 凤岗大肠国大肠血  BRT快2线，至同安枢纽站  阿呆盐鸭店  630A，由同安枢纽站至小西门  鑫旺旺汤包  步行  味源小吃  630A，由小西门至同安电视台站  台湾番婆冰  步行  肥栋满煎糕  步行  秀英食品  步行  双鹿老铺  步行  陆丰煎饼  612，由金安大厦至新西桥站  杨强芙蓉香骨鸡腿  625，由新西桥至同安劳动力市场站   介绍 凤岗大肠国  位置  凤岗岗头里786 同安枢纽站 直行50米左转进入凤岗路 直走600米  特色菜  纯猪血大肠  单价  15元/碗    阿呆盐鸭店  位置  小西门 下车前行50米后左转200米进入东山路  特色菜  盐鸭  单价  50元/只    鑫旺旺汤包  位置  沿着东山路走250米，进中山路再走200米  特色菜  汤包  单价  10元/笼    味源小吃  位置  同安电视台站  特色菜  碗仔粿  单价  3元/小碗 4元/大碗    台湾番婆冰  位置  沿着凤山路往南门桥走350米  特色菜  芒果冰 芋泥  单价  22元/芒果冰 6元/芋泥    肥栋满煎糕  位置  出了番婆冰右转20米就到  特色菜  满煎糕  单价  10元/个    秀英食品  位置  从番婆冰门口上桥，过桥左转沿路走到尽头右转300米，再右转上同新路，80米后左转直行100米  特色菜  醋肉  单价  20元/份    双鹿老铺  位置  从秀英出门右转到松柏林中路，200米后右转进南门路，再走70米  特色菜  马蹄酥  单价  6元/袋-10个    陆丰煎饼  位置  612路 金安大厦-新西桥站（2站） 步行到古庄大社里21号 下午三点开门  特色菜  煎饼  单价  4元/个 5.5元/个 - 加蛋    杨强芙蓉香骨鸡腿  位置  同安劳动力市场站  特色菜  鸡腿 鸡翅  单价  5元/根 6元/根   </content>
    </entry>
    
     <entry>
        <title>云开-服务端架构-20171203</title>
        <url>http://domain.yqjdcyy.com/post/%E4%BA%91%E5%BC%80-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%B6%E6%9E%84-20171203/</url>
        <categories>
          <category>工作</category>
        </categories>
        <tags>
          <tag>架构</tag><tag>会议纪要</tag>
        </tags>
        <content type="html">  流程  华山分享现有架构整理 志高补充压测等情况 讨论瓶颈优化  系统架构  客户端  微信 NW 老师端 PC 学习端  连接方式  HTTP TCP/IP  微服务  用户中心 直播相关 业务服务相关 推荐相关  模块  用户 直播  FFMpeg Nginx rtmp  NFS IM 转换  PPT  Gateway NSQ PPT.Command  音视频   底层服务  日志 持久化  Mysql，主从  缓存  Redis，仅主从无集群  文件数据   讨论  实现目标  两万人并发 目前900 QPS  确认瓶颈  缓存  解决方案  Twemproxy  参考  twitter/twemproxy Redis 存储分片之代理服务Twemproxy 测试 存储分片和Twemproxy核心解读  性能  性能损耗，最差低于 20%  优点  统一对外节点，多服务池 长连接，pipelinling 处理请求和响应，大大减少连接数 哈希分片，请求分配均匀  缺点  无法平滑地扩容或缩容 运维管理困难，无操作界面   Codis  参考  Redis集群技术及Codis实践 常见的redis集群方案有哪些优缺点？ []()  性能  最初比Twemproxy慢20%，现在比Twemproxy快近100%    优点  有图形化界面，扩容及运维方便 开发简单，对应用透明 不负责主从同步，轻量伦 提供 Jodis，支持 Java 程序的 HA  缺点  修改过 Redis 代码，无法与官方版本同步，新特性跟进缓慢 Value 字段大小小于 888B 字节时，性能较优秀 第三方组件较多     相关工作  AV-Server  可能存在问题？  CPU 使用率  GO 中使用  如何快速扩容  Kafka，多服务连接    Talk.Operate  将画笔等过重的数据存储化  PPT-Convert  PPT 存在失真 Excel 打印时，需要手动点选确认！  Nginx 策略  权重配置，但于瞬间分配不均匀   学习补充  LVS
 Linux Virtual Server Linux服务器集群系统   HAProxy
 负载均衡&#43; 动静分离 haproxy 官网   </content>
    </entry>
    
     <entry>
        <title>Kafka</title>
        <url>http://domain.yqjdcyy.com/post/kafka/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Kafka</tag>
        </tags>
        <content type="html">  Kafka 参考  Kafka剖析（一）：Kafka背景及架构介绍 Apache kafka 工作原理介绍 Quickstart Kafka系列2-producer和consumer报错 Using new consumer API with a Deserializer that throws SerializationException can lead to infinite loop How to find the kafka version in linux  简介  Linkedin 开发，Scala编写 特点  解耦 水平扩展 高吞吐率  缓冲 异步通信  可恢复性  冗余，确保安全保存至使用完毕后 处理消息进程宕机，仍可于启动后重新接收处理  顺序保证   架构 名词解析  Broker  集群中的服务器名称 支持水平扩展的节点  Topic  集群消息中类别  Partition  Topic 下包含一至多个 Partition  Producer  生产者 将消息发布至 Kafka broker  Consumer  消费者 向 Kafka broker 读消息的客户端  Consumer Group  各 Consumer 属于特定 Group 不指定时，则属于默认 Group   结构拓扑  整体拓扑    分析  kafka 通过 Zoopkeeper 管理集群配置  选举 Leader Consumer Group 变更时的 ReBalance  物理上 Topic 对应一至多个 Partition  每个 Partition 在物理上对应一个文件夹  消息 索引  结构  root 4k topic1-1 - 日志文件 root 4k topic1-2 ... root 4k topic1-n   log entrie  每个日志文件都是一个 log entrie 序列  log entrie 内容 message length： 4 bytes (value: 1&#43;4&#43;n) &amp;quot;magic&amp;quot; value： 1 byte crc ： 4 bytes payload ： n bytes   segment  log entries 由多个 segment 组成 以第一条消息的偏移量命名 以 .kafka 作为后缀  34477849968.kafka  message-34477849968 message-34477850175 &amp;hellip; message-35513434344         冗余  保留所有消息，无论其被消费与否 删除策略  基于时间 基于 Partition 文件大小  配置
 $KAFKA_HOME/config/server.properties
# The minimum age of a log file to be eligible for deletion log.retention.hours=168 # The maximum size of a log segment file. When this size is reached a new log segment will be created. log.segment.bytes=1073741824 # The interval at which log segments are checked to see if they can be deleted according to the retention policies log.retention.check.interval.ms=300000 # If log.cleaner.enable=true is set the cleaner will be enabled and individual logs can then be marked for log compaction. log.cleaner.enable=false  注意
 为每个 Consumer Group 保留部分 metadata 信息  metadata= 当前消费者的消息偏移值 broker 无状态  不需要保证消息已经消费 不需要保证各 Consumer Group 只有一个 Consumer 消费某一记录       扩展 Push &amp;amp; Pull  Pulll  由 Producer 向 broker push 消息，并由 Consumer 从 broker pull 消息 根据 Consumer 的消费能力以适当速率消费消息  Push  目标是尽可能以最快速度传递消息  容易造成拒绝服务及网络拥塞  Facebook.Scribe 和 Cloudera.Flume   消息策略  At most once  消息可能丢，但绝不会重复传输  读完消息后，先 commit，再处理消息   At least one  默认项 消息绝不会丢，但可能会重复传输  读完消息后，先处理，完成后再 commit   Exactly once  每条消息肯定会且仅传输一次  协调 offset 和实际男人出  两阶段提交 将 offset 与 操作输入 存放在同一地方     使用  dowwnload  tar -xzf kafka_2.11-1.0.0.tgz  server.*  bin/zookeeper-server-start.sh config/zookeeper.properties bin/kafka-server-start.sh config/server.properties  topic.*  bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic [av] bin/kafka-topics.sh --delete --zookeeper localhost:2181 --topic avRes bin/kafka-topics.sh --list --zookeeper localhost:2181  producer  bin/kafka-console-producer.sh --broker-list localhost:9092 --topic [av]  consumer  bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic [av] --from-beginning  version  find ./libs/ -name &#39;kafka_*.jar.asc&#39; |head -n1 | cut -d&#39;/&#39; -f3 find ./libs/ -name \*kafka_\* | head -1 | grep -o &#39;\kafka[^\n]*&#39;  kafka_2.10-0.8.2-beta.jar  2.10  Scala.version  0.8.2-beta  Kafka.version      异常 本地生产、消费进程启动时报错  异常信息  [2016-06-03 11:44:16,932] WARN Error while fetching metadata with correlation id 0 : {test=LEADER_NOT_AVAILABLE} (org.apache.kafka.clients.NetworkClient)  修复  vim config/server.properties  listeners=PLAINTEXT://localhost:9092    Java 接收消息时报错  版本  kafka  0.10.0.0 1.0.0  java  spring-kafka-1.0.3.RELEASE.jar  go  github.com/Shopify/sarama  Version 1.14.0    异常消息  2017-11-28 15:46:30.927 ERROR 53444 --- [afka-consumer-1] org.apache.kafka.clients.NetworkClient : Uncaught error in request completion: org.apache.kafka.common.errors.SerializationException: Size of data received by IntegerDeserializer is not 4  解决
 KafkaIntegerDeserializer
public class KafkaIntegerDeserializer implements Deserializer&amp;lt;Integer&amp;gt; { @Override public Integer deserialize(String topic, byte[] data) { if (data.length != 4) { System.err.println(&amp;#34;Size of data received by IntegerDeserializer is not 4&amp;#34;); // 将 throw new SerializationException 更新为提示，并跳出处理 return null; } KafkaConfig
@Configuration public class KafkaConfig { private Map&amp;lt;String, Object&amp;gt; consumerConfigs() { props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, KafkaIntegerDeserializer.class); // 替换 IntegerDeserializer 为 KafkaIntegerDeserializer   </content>
    </entry>
    
     <entry>
        <title>Git.Subtree</title>
        <url>http://domain.yqjdcyy.com/post/git.subtree/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Git</tag>
        </tags>
        <content type="html">  参考  Git Subtree的使用 Git Tools - Subtree Merging 用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册  描述  简介 &amp;gt; 经由 Git Subtree 来维护的子项目代码，对于父项目来说是透明的，所有的开发人员看到的就是一个普通的目录，原来怎么做现在依旧那么做，只需要维护这个 Subtree 的人在合适的时候去做同步代码的操作。
 适用情况
 使用 github 的 page 功能实现项目主页功能，结合 hugo 生成 public 文件夹后同步到 gh-pages 分支，作为分支完整内容 项目 A 和项目 B 存在公用模块，A 中的修改、新增等操作，均同步至项目 B  可用方案
 Git Submodule  Git 官方早期推荐方案 允许其它仓库指定 commit 嵌入仓库子目录  但需要 init 和 update  产生 .gitmodule 文件记录 submodule 版本信息 删除较费劲  Git Subtree  Git 1.5.2 版本后推荐  npm  node package manager  composer  npm.php 版本    指令  usage
 git subtree add --prefix=&amp;lt;prefix&amp;gt; &amp;lt;commit&amp;gt; git subtree add --prefix=&amp;lt;prefix&amp;gt; &amp;lt;repository&amp;gt; &amp;lt;ref&amp;gt; git subtree merge --prefix=&amp;lt;prefix&amp;gt; &amp;lt;commit&amp;gt; git subtree pull --prefix=&amp;lt;prefix&amp;gt; &amp;lt;repository&amp;gt; &amp;lt;ref&amp;gt; git subtree push --prefix=&amp;lt;prefix&amp;gt; &amp;lt;repository&amp;gt; &amp;lt;ref&amp;gt; git subtree split --prefix=&amp;lt;prefix&amp;gt; &amp;lt;commit...&amp;gt;  commons.option -h, --help - 显示帮助文档 -q - 静默执行 -d - 显示 Debug 信息 -P, --prefix ... - 将要分离出去的子目录名称 -m, --message ... - 使用给定信息作为提交合并提交的备注信息
 [add|merge|pull].option
 --squash  将子树提交合并为一次提交   split.option
 --annotate ...  为新的提交消息添加前缀  -b, --branch ...  为子目录新建一分支  --ignore-joins  优先忽略 --rejoin 提交  --onto ...  尝试将新目录与已存在的目录进行关联  --rejoin  合并提交至新分支的起点    实例  前情提要
 项目 P1、P2 拥有共同的项目 S  初始化项目 S
 cd P1 git subtree add --prefix=[path for S] [git path for S] [branch]  更新项目 S
 git subtree push --prefix=[path for S] [git path for S] [branch]  遍历针对 S 目录的更改，一并提交到项目 S 的 git 上   拉取项目 S
 git subtree pull --prefix=[path for S] [git path for S] [branch]  创建新起点
 git subtree split --rejoin --prefix[path for S] --branch [new git path for S] git push [git path for S] [new git path for S]:master   </content>
    </entry>
    
     <entry>
        <title>20岁的你</title>
        <url>http://domain.yqjdcyy.com/post/20%E5%B2%81%E7%9A%84%E4%BD%A0/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>思考</tag>
        </tags>
        <content type="html">  20岁时做什么到40岁时才不会后悔？ 要点  知道什么是生命中最重要的东西 尽量不要去想太多竞争 善待那些喜欢自己的人 学会欣赏这个世界 为健康打下基础 试错和重启 谨慎选择与谁一起共度 谨防短期情绪波动 一定要把收入的一部分用于储蓄 投资 写作将点燃你的头脑 要建立良好的个人品牌 设计你的生活永远不会太迟 没有人把一切都想通了  忧虑就是你在偿还你并未欠的债 - 马克吐温  了解，沟通是一切 提问 如果你发现自己不知道或不确定，就主动发问吧 做饭 冥想让头脑深度休息 更新你的心灵的操作系统  关键字  健康、控制情绪 尝试  投资理财 做饭  提问、思考、设计人生  </content>
    </entry>
    
     <entry>
        <title>Apache.Beam的前世今生</title>
        <url>http://domain.yqjdcyy.com/post/apache.beam%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Beam</tag>
        </tags>
        <content type="html">  Apache Beam的前世今生 开源原因  意识到开源软件的巨大价值 足够多模型才能促使项目成功  简介  基础  Cloud Dataflow  介绍  构建、管理和优化复杂数据流水线的方法 用于构建移动应用、调试、追踪和监控产品级云应用  技术  Flume：数据高效并行处理 MilWhell：互联网级别流处理，优秀的容错机制     介绍  统一编程框架，提供开源、统一的编程模型  特点  统一：对于批处理和流式处理，使用单一的编程模型 可移植：可以支持多种执行环境，包括Apache Apex、Apache Flink、Apache Spark和谷歌Cloud Dataflow等 可扩展：可以实现和分享更多的新SDK、IO连接器、转换操作库等  适用场景  并发数据处理任务  将要处理的数据集分解成许多相互独立而又可以并行处理的小集合  ETL任务 数据整合  组成  Beam SDK  针对各数据来源、形式，采用相同的数据模型处理、封装  Beam Pipeline Runner  将 Beam 模型定义开发的处理流程，翻译成底层分布式数据处理平台支持的运行时环境 需要指明底层的 Runner  目前支持 Flink/ Spark/ Apex/ Cloud Dataflow     设计  问题  数据  已持久化的有限数据集，如 HDFS文件，HBase 表 实时数据流，如 Kafka中的系统日志流，Twitter 流 注：有限数据集可看为实时数据流的一个子集  时间  process time：数据进入分布式处理框架时间 event time：数据产生时间  乱序  数据到达时间与 event-time 无法完全符合   解决方法(WWWH)  [W]hat are you computing  Element-Wise 元素级 Aggregating 聚合 Composite 复合  [W]here in event time    [W]hen in processing time  使用 Trigger 机制，配合 SDK 中的水位线和触发器进行时机指定  [H]ow do refinements relate  指定如何处理迟到数据，增量或合并输出 由 SDK 中的 Accumulation 指定    </content>
    </entry>
    
     <entry>
        <title>Java.9.Feature</title>
        <url>http://domain.yqjdcyy.com/post/java.9.feature/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  深入解读 Java 9 新特性 参考  深入解读 Java 9 新特性 Java9先睹为快：JShell动手实践 JavaOne 2016——观众得以一睹JShell的威力  Jigsaw  核心 -实现 Java 平台模块化系统 - JPMS (Java Platform Module System)
 针对问题
 易错的 classpath  应用不同部分依赖同一类库的不同版本 ClassLoading 复杂而不明确，导致 ClassNotFoundException、 NoClassDefFoundError 等异常  JDK 过于臃肿，无法按不同需求进行定制或优化  目标
 可靠配置  明确模块边界和模块间的依赖关系  强封装性  通过封装模块内部私有细节，避免不希望发生的依赖关系   拆分 JDK 增强提议 (JEP)
 JEP 261  Module System，实现模块化系统；  JEP 200  The Modular JDK，将JDK自身进行模块化；  JEP 201  Modular Source Code，按照模块化的形式，重构源代码,因为现有代码并不是划分到一个一个的模块里的。  JEP 220  Modular Run-Time Images，重新设计JDK和JRE的结构，定义新的URI scheme操作模块，类和资源（jrt）。  JEP 260  Encapsulate Most Internal APIs，按照模块化封装性的要求，将不希望暴露的内部API封装起来，如果确实证明是广泛需要的，就作为公共API公开出来。  JEP 282  jlink: The Java Linker。新的link工具   模块图
   开发角度
 工具和 API 新增或修改，用以编译、链接和运行时的模块支持 Java/ Javac 等增加对模块的支持，支持 module path Java9 增加可选链接阶段 (Linking Phase)，创建最小依赖关系的 Java 运行时  示例
 jlink  $ jlink --module-path jmods/ \ --add-modules java.sql.rowset,java.activation \ --output myimage $ myimage/bin/java --list-modules java.activation@9 java.base@9 java.datatransfer@9 java.logging@9 java.naming@9 java.security.sasl@9 java.sql@9 java.sql.rowset@9 java.xml@9 $ myimage/bin/java –m company.application    类库新特性  工具 API
 JEP 102  Process API Updates 新增 ProcessHandle 抽象，优化 Process 扩展，以提升对进程操作的支持  ProcessHandle current = ProcessHandle.current(); current.info() .totalCpuDuration() .ifPresent(d -&amp;gt; System.out.println(&amp;quot;Total cpu duration :&amp;quot; &#43; d)); current.children() .forEach(p -&amp;gt; System.out.println(&amp;quot;Pid:&amp;quot; &#43; p.getPid()));   JEP 269
 Convenience Factory Methods for Collections 针对集合的工厂方法优化 Set&amp;lt;String&amp;gt; alphabet = Set.of(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;);  JEP 166
 Java 并发(Concurrency)API 更新 最小集合 API 以支持 Reactive Stream  Flow API= Publisher &#43; Subscriber&#43; Processor  异步方式处理数据流   新标准或协议支持
 安全  JEP 219  支持Datagram Transport Layer Security (DTLS)。 支持DTLS version 1.0 (RFC 4347) and 1.2 (RFC 6347)，以提供安全的UDP传输。 目前，基于UDP实现的类似SIP或者电子游戏协议，被证明是很有实际价值的。  JEP 229  默认keystore格式从JKS替换为PKCS12。  JEP 244  TLS Application-Layer Protocol Negotiation(ALPN) Extension, 这是完整支持HTTP/2协议的前提之一。  JEP 249  支持OCSP Stapling for TLS，减少证书状态验证的网络开销，提高性能。  JEP 273  实现基于DRBG的SecureRandom，对于Deterministic Random Bit Generator (DRBG) 机制，您可以参考NIST 800-90Ar1相关文档。  JEP 287  SHA-3 Hash Algorithms。   网络  JEP 110  HTTP/2 client API，支持 HTTP 1.1，HTTP/2 和 WebSocket协议，实现了全新的 HTTP client API，用于替换老旧的HttpURLConnection 支持同步和异步操作模式，充分利用了 Reactive style 编程   编码  JEP 227  Unicode 7.0  JEP 267  Unicode 8.0  JEP 226  UTF-8 Property Files    性能优化
 JEP 254  Compact String，Java 9 中，修改 String 实现，以 byte[] 数组和一个编码标记替换 char[] (16 bits) 数组 Latin 语系编码字符串会节省近半空间。 这个修改对 API 的使用者完全透明。  JEP 232  提高安全应用性能。 开启 security manager 通常会导致10-15%的性能下降，Java 9的改进显著降低了开销。 优化包括用标准的并发容器替换自定义的同步逻辑，或者去掉不必要的检查等等。  JEP 24  利用CPU指令优化GHASH和RSA。 充分利用Intel x64或者SPARC CPU的部分新指令。 部分加密函数的性能提高非常显著  在 benchmark 中，相比于 JDK 8，AES 性能提高了至少 8 倍。 这是相对保守的数据，测试数据大多在几十倍提升。     语言和工具的变化  Jshell  简单易用的交互式执行 Java 代码   Multi-Release JAR Files  扩展 JAR 文件格式，支持不同版本 class 文件共存 release指令  Javac --release N = Javac -source N -target N -bootclasspath rtN.jar   Javadoc Search  JVM 领域新特性  将 G1 作为默认垃圾收集器
 目前 server 模式的默认选项是 ParallelGC= 吞吐量优先 延迟比吞吐量更能提高用户体验，G1 可以直接设定延迟目标，达到延迟 SLA 要求 最坏场景的延迟表现优于 CMS = 设计原理导致碎片化问题  AOT
 Ahead-of-Time Compilation= 提前编译 利用新的编译工具 jaotc，把 class 编译成类似类库的文件  编译  aotc –output libHelloWorld.so HelloWorld.clas  使用  java -XX:AOTLibrary=./libHelloWorld.so HelloWorld   实验阶段，目前支持 Linux 64 平台 不能直接编译成可执行文件，还需要结合 Jlink 或 JavaPackager  移除过时的GC组合
 移除在JDK 8中标记过时的 Incremental CMS= iCMS 输入 java 不支持的参数，将于启动阶段直接报错  统一日志
 引入适用于 JVM 各个模块的通用日志机制 在此基础上解决过于碎片化的 JVM 日志选项。  JVM 性能优化
 改进竞争锁  改进高度竞争的 Java Object Monitor 性能  Spin-Wait Hints  循环等待提示  Thread.onSpinWait()   Java 发布模式  切换到以时间驱动  六个月周期  针对企业需求  三年周期  Long Term Support    </content>
    </entry>
    
     <entry>
        <title>Java.Native</title>
        <url>http://domain.yqjdcyy.com/post/java.native/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  参考  http://blog.csdn.net/xw13106209/article/details/6989415 http://www.iteye.com/topic/304594  概念  Jni  sun 提供 支持通过与 c/c&#43;&#43; 交互调用系统的相关技术  Jawin  sourceforge 提供基于 Jni 的应用库 支持调用 com 对象，和win32-dll 动态链接库的方法  Jacob  sourceforge 提供 提供调用 microsoft 的 com 对象方法  补充        开发流程  Java 调用类 javah 生成 c/c&#43;&#43; 原生函数头文件 c/c&#43;&#43; 中实现原生函数 将项目依赖的所有*原生库和资源*加入至 java 项目的 java.library.path 生成 java 程序 发布 java 应用和 dll 库  </content>
    </entry>
    
     <entry>
        <title>Java.泛型</title>
        <url>http://domain.yqjdcyy.com/post/java.%E6%B3%9B%E5%9E%8B/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  泛型 与 C&#43;&#43; 的比较  优点  泛型实现参数化类型 创建泛型的一个实例时，编译器负责转型并保证类型的正确性  缺点  其它语言能做、好做的，java 中却不支持，难以实现  注
 理解泛型的边界！
简单泛型  告诉编译器想使用类型，然后由编译器帮你处理一切细节
 元组：一组对象打包存储于一单一对象
泛型接口 事例
public interface Generator&amp;lt;T&amp;gt; { T next(); } 基本类型无法作为类型参数
泛型方法 事例
public &amp;lt;T&amp;gt; void printClass(T t) { System.out.println(t.getClass().getName()); } 类型推断只对赋值操作有效
泛型内部类 构建复杂模型 类型安全且可管理
擦除的神秘之处 在泛型代码内部，无法获得任何有关泛型参数类型的信息
 T extends class/interface
 于静态类型检查期后，所有泛型类型均被擦除，并替换为其非泛型上界
 List&amp;lt;T&amp;gt; -&amp;gt; List &amp;lt;T&amp;gt; -&amp;gt; Object  使用擦除实现，唯一知道是在使用一个对象
 List&amp;lt;String&amp;gt;= List&amp;lt;Object&amp;gt;= List List&amp;lt;Integer&amp;gt;= List&amp;lt;Object&amp;gt;= List  与 C&#43;&#43; 对比
template&amp;lt;Class T&amp;gt; class Manipulator{ T obj; public: Manipulator(T t){obj=t;} void manipulator(){**obj.f();**} // 实例时，检查是否有f()方法，如果没有则返回编译期错误 // java 则是编译不通过 // 但可通过 T extends XXX 来限定 } 原因
 从非泛化代码转变为泛化代码过程中，在不破坏现有类库条件下，通过类型擦除来兼容  缺点
 转型|instanceof|new 等均无法显式调用  擦除在方法体中移除了类型信息，即在运行时的问题就是边界（对象进入和离开方法的地点）
擦除的补偿 边界 class Solid class Bounded extends Dimension implements HasColor, Weight
  </content>
    </entry>
    
     <entry>
        <title>Linux 单TCP连接占用最少内存</title>
        <url>http://domain.yqjdcyy.com/post/linux-%E5%8D%95tcp%E8%BF%9E%E6%8E%A5%E5%8D%A0%E7%94%A8%E6%9C%80%E5%B0%91%E5%86%85%E5%AD%98/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>TCP</tag>
        </tags>
        <content type="html">  Linux 单 TCP 连接占用最少内存 结构  错  TCP 连接建立的时候会分配接收缓冲区和发送缓冲区，各 4KB，一共是 8KB。如果加上 TCP 协议控制块（protocol control block）的 2KB，一共是 10KB。  测试  &amp;gt;= 2944 B 没有数据时，接收、发送缓冲区是没有数据的   TCP 解析 TCP  三次握手  struct socket_alloc  包含 struct socket/ struct inode 作用于连接 VFS 和 tcp_sock  VFS | virtual File System 让open()、read()、write()等系统调用不用关心底层的存储介质和文件系统类型就可以工作的粘合层    socket 文件缓冲  struct dentry  struct file *  理解对应缓冲时的文件    进程调用  struct socket_wq  wait queue，主要用于阻塞 IO 时挂起当前线程    实测 - Least  基本消耗 | struct | size | slab cache name | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | | file | 256 | &amp;ldquo;filp&amp;rdquo; | | dentry | 192 | &amp;ldquo;dentry&amp;rdquo; | | socket_alloc | 640 | &amp;ldquo;sock_inode_cache&amp;rdquo; | | tcp_sock | 1792 | &amp;ldquo;TCP&amp;rdquo; | | socket_wq | 64 | &amp;ldquo;kmalloc-64&amp;rdquo; | | inet_bind_bucket | 64 | &amp;ldquo;tcp_bind_bucket&amp;rdquo; | | epitem | 128 | &amp;ldquo;eventpoll_epi&amp;rdquo; | | tcp_request_sock | 256 | &amp;ldquo;request_sock_TCP&amp;rdquo; |
 额外开销
 SLAB 额外开销  sizeof(struct tcp_sock) == 1792 &amp;amp; 4KB page= 2* tcp_sock =&amp;gt; sizeof(struct tcp_sock)= 2048 sizeof(dentry) = 192 &amp;amp; 1 page = 21 dentry =&amp;gt; sizeof(dentry[10000])= (10000/ 21)* 4= 1908 KB  1 TCP= 1 ephemeral port= 1 inet_bind_bucket &amp;amp; 服务端共享 listening socket.inet_bind_bucket 服务端使用 epoll 处理并发，每添加一个 sockfd 则会创建一个 epitem 对象，大小为 128 B  epoll 为 Linux 内核的可扩展 I/O 事件通知机制    代码示意图     </content>
    </entry>
    
     <entry>
        <title>Linux.Vimium</title>
        <url>http://domain.yqjdcyy.com/post/linux.vimium/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Vimium 快捷键指南 页面导航  j 向下滚动 k 向上滚动 d 向下翻页 u 向上翻页 gg 滚动至顶部 G 滚动至底部
 r 刷新界面
 yy 复制当前界面 URL
 p 在当前标签页打开剪贴板中的 URL
 gu 跳转至当前 URL 的上一层
 http://www.phperz.com/article/15/1231/179223.html http://www.phperz.com/article/15/1231/  gU 跳转至当前 URL 的最高层
 http://www.phperz.com/article/15/1231/179223.html http://www.phperz.com/  f 在当前标签页打开此标签页中的一个链接
  使用 Vomnibar  o 搜索书签和历史记录 T 搜索已打开标签页 b 搜索书签  使用查询  / 进入查询模式 n 切换至下一个匹配值处  标签操作  gt 移动至下一标签页 g[\d] 跳转至指定标签页 yt 复制当前标签页 x 关闭当前标签页 X 恢复已关闭的标签页  其它  ? 显示帮助  </content>
    </entry>
    
     <entry>
        <title>PowerPoint.CoverExport</title>
        <url>http://domain.yqjdcyy.com/post/powerpoint.coverexport/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>PowerPoint</tag>
        </tags>
        <content type="html">  文件法 实现  将 .pptx 文件后缀更新为 .zip 获取 /docProps/thumbnail.jpeg  缺点  仅适用于 .pptx  windows api &#43; code 实现 环境要求&amp;amp; 版本限制  v4.0.30319  缺点  与「文件法」一致，导出图片尺寸过小  PPT 操作导出 - 79KB 1024x766 api 导出 - 24KB 960x720  部分 PPT 无缩略图，导出的均为 PPT 默认图片  OpenXML &#43; code 现服务转换方式  高清无码  环境要求&amp;amp; 版本限制  v2.0.50727 安装有 Microsoft.PowerPoint  缺点  要求本地安装有指定以上版本 PPT  </content>
    </entry>
    
     <entry>
        <title>ServiceMesh</title>
        <url>http://domain.yqjdcyy.com/post/servicemesh/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>ServiceMesh</tag>
        </tags>
        <content type="html">  参考  Java未来也许不再是电商的首选开发语言 从零开始k8s  明细 首选语言  优点  JVM 运行时强大 工具链成熟 Spring 庞大的生态  dubbo Spring Cloud   缺点  开发繁琐 包体积大 运行时开销大   框架 Service Mesh  定义  基础设施层，处理服务间通讯 轻量网络代理，负责复杂服务拓扑的请求的可靠传递 对应用程序透明 利于多语言应用共存  优点  聚焦于业务逻辑 不再于开发层面关注负载均衡、路由、熔断、限流、服务注册  工具  Kubernetes   </content>
    </entry>
    
     <entry>
        <title>不可描述</title>
        <url>http://domain.yqjdcyy.com/post/%E4%B8%8D%E5%8F%AF%E6%8F%8F%E8%BF%B0/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  参考  香辣家常菜 0/6   料理 黄油炒蛋 [2&amp;frasl;5] 材料  鸡蛋* 3 全脂牛奶 玉米粉/ 土豆粉 黄油 盐、胡椒  步骤  鸡蛋撑匀 全脂牛奶溶玉米粉，搅拌均匀后与鸡蛋混合 黄油于不粘中融化，煮开后加入鸡蛋，并关火搅动  麻辣烫 材料  汤底  干辣椒 豆瓣酱 浓汤宝  鲜鸡汁 猪骨汤|清水  葱、姜、蒜、八角、花椒  煮料  鱼丸、蟹肉棒、肥牛 豆泡、冻豆腐、玉米、香菇、土豆、青菜   流程  材料洗净、切段、片、末 热锅热油，加葱、姜、蒜和花椒爆香，后加入干辣椒和八角翻炒2分钟 加入4勺豆瓣酱炒香后，加入浓汤宝，煮开后转小火煮15分钟 完成后捞出配料，并加入食材即可 调味可补蒜末、醋、芝麻酱和菊花等  蒸水蛋  材料  鸡蛋* 2 温水 盐、酱油、油  流程  鸡蛋打散，加入1/2茶匙盐、些许酱油、3滴油后打发 一边加入3倍温水，一边顺时针拌匀，并用勺子舀走泡泡 蒸锅放入热水，大火蒸10分钟 取出后于表面淋少许酱油  青椒肉丝 材料  大青椒 猪里脊肉 姜、蒜 料酒、老抽、生抽、清水、麻油 盐、糖 干淀粉、水淀粉  流程  青椒横剖去芯后，顺纹理切丝 肉丝加老抽、生抽、糖、料酒抓匀后腌15分钟 肉里加一汤匙清水、麻油后，抓肉至水被吸收，再加干淀粉抓匀 热锅少油，煸青椒丝至微软 热锅热油后，萋蒜片爆香，大火炒散肉丝至八成熟，加青椒炒匀 加入盐、糖、水淀粉勾芡炒匀  茭白毛豆鸡丁 材料  茭白* 2 毛豆 鸡脯肉* 2 红尖椒 盐 生抽 水淀粉  流程  各材料切丁，鸡肉用盐、生抽和水淀粉抓匀 毛豆焯水，热锅凉油滑肉变色后盛出 茭白翻炒后，加毛豆、水许水、盐烹炒入味 加鸡丁、红椒和一勺蚝油，翻炒出锅  干煸四季豆 材料  四季豆 猪肉末 蒜、姜、干辣椒 生粉 花生油、生抽、鸡精、盐、料酒  流程  四季豆去筋折段后洗净沥干，姜蒜切片、干辣椒切段 猪肉末放入油、生粉和料酒后抓匀 热锅热油炸四季豆至表皮微黄后捞出 留微油爆香肉末后盛出 热锅微油煸炒干辣椒、姜、蒜后，倒入四季豆和肉末，并放入生抽、盐、鸡精翻炒均匀即可  木须肉 材料  鸡蛋 *2 瘦肉 黄瓜、胡萝卜、黑木耳 盐、生粉、白糖、生抽、淀粉
流程 瘦肉切片，用盐、生粉和油腌制15分钟
 胡萝卜切片，黑木耳撕小朵后泡水、黄瓜切片
 大火热锅起油，倒入瘦肉片滑炒至变色后盛出
 鸡蛋磕入碗中，拌少许盐，热锅翻炒切块盛出
 起油热锅，倒入胡萝卜，洒水煸炒至软
 依次加入黑木耳、黄瓜、肉片翻炒
 加盐、白糖、生抽、水翻炒
 最后倒入鸡蛋、水淀粉翻炒即可
  苦瓜炒蛋 材料  鸡蛋 *3 苦瓜
流程 苦瓜去瓤，并刮净内层白膜（苦味来源），后切丁
 加盐、油和水烧开，苦瓜焯至变色后捞出
 鸡蛋加入少许盐、清水，与苦瓜丁混合搅拌
 热锅热油后煎炒即可出名
  日式毛豆 材料  毛豆 盐  流程  毛豆洗净沥干，加两勺盐揉搓，腌15分钟 水烧开后放入腌过的毛豆，水开后再煮5分钟 捞出沥干、降温  盐水毛豆 材料  毛豆 葱、姜 八角、桂皮、香叶、茄香、干辣椒 盐、料酒  流程  毛豆搓洗、沥干后，去角 葱切段，姜切片，备好八角、桂皮、香叶、茴香和干辣椒 上述材料放入水中烧开后，倒入毛豆，待再次煮沸后加入盐和料酒，转中火煮5分钟 浸泡30分钟  干锅菜花 材料  菜花 五花肉 姜、蒜、辣椒 酱油  流程  菜花削朵，用淡盐水浸泡10分钟，后充分晾干 五花肉、辣椒切圆、生姜切片、大蒜切块 五花肉加生姜，小火煸油 开大火热锅后，倒入菜花30秒后翻炒 盖锅盖，转中火焗30秒 加入辣椒、大蒜、酱油炒匀 洒盐出锅  香煎豆腐 材料  豆腐 葱 酱油、蚝油、白砂糖  流程  豆腐洗净、沥干、切小块 热锅热油后，转小火滑入豆腐 转中火煎至金黄后，调小火翻面 待煎熟后加入酱料蚝油:酱油:砂糖:水= 1: 3: 0.5: 5 加入葱花后，收汁装盘  香辣花甲 材料  花甲 大蒜、洋葱、姜片 郫县豆瓣酱、白糖、蚝油、料酒、酱油 干辣椒、花椒  流程  洋葱切条、姜切片、蒜压扁，花甲清水吐沙 热油加入蒜、洋葱、花椒粒、干辣椒爆香，后下豆瓣酱炒香炒出红油 花甲下锅翻炒至部分开口，再加料酒炒香 加入开水、酱油、白糖、蚝油和盐调味后大火煮开，花甲全部开口后立即盛出  葱烧牛肉 材料  牛柳肉 鸡蛋 大葱 生姜、大蒜、红椒 食盐 胡椒 老抽 蒸鱼鼓油 蚝油 淀粉  流程  牛柳叶逆条纹切 0.3 厘米左右小片，生姜切菱，大蒜切片，红椒切片、大椒切段 牛肉清洗后挤压沥干，加入食盐、胡椒、老抽后拌至粘手 后依次加入鸡蛋清、干淀粉、植物油拌匀 倒入较多油，加热至120度后，加入牛肉滑散九成熟后盛出 留底油炒生姜、大蒜和红椒，炒至断生后加蚝油和甜面 然后依次倒入牛肉、大葱、料汁和油  料汁= 蒸鱼鼓油&#43; 料酒&#43; 盐&#43; 胡椒&#43; 淀粉 大葱炒二十秒至断生口味最佳   </content>
    </entry>
    
     <entry>
        <title>代码整洁之道.程序员的职业素养</title>
        <url>http://domain.yqjdcyy.com/post/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93.%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>编程思想</tag>
        </tags>
        <content type="html">  代码整洁之道 - 程序员的职业素养 专业主义 为自身错误埋单 注重自测  要求自测基本完整覆盖
建议要求 设计模式
 GOF* 24 POSA 中多数模式的实战  设计原则
 了解 SOLID 原则 深刻理解组件设计原则  方法
 XP Scrum 精益 看板 瀑布 结构化分析 结构化设计  实践
 测试驱动开发 面向对象设计 结构化编程 持续集成 结对编程  工作
 UML 图 DFD 图 结构图 Petri 网络图 状态迁移图 流程图 决策图
站在 雇主/客户/产品 的角度   说“不” 拒绝说“试一试”  在上级眼里意味着你可以 另一方面，如果能完成，意味着之前有所保留，并未全然尽力
描述清楚实现的难度 认真理解说“是”的成本  说“是” 承诺用语  为自己的承诺负责 理解对方言语承诺的成分 坚守原则，避免放松代码追求  承诺无效 关键词  需要|应当  我们要把这个活干完 有人应当负责去推动这件事  希望|但愿  希望明天我能完成这件事 但愿我有时间做这件事  让我们
 让我们回头见
特点  表现事情不在自己掌控范围
 不愿意承担个人责任
  承诺 关键词  我将在……之前……
关键 只承诺自己能完全掌握的事情，并推进依赖项的进展
 目标可能无法完成，仍需尽可能地接近和掌握情况
 目标无法兑现，应尽早反馈，调整他人预期或协调资源
  编码 前提  信心 出错感知  初始化  保证代码解决问题 保证注释、代码结构，以确保其它人可以阅读你的代码 避免疲劳、焦虑时书写代码  优先通过休息，或尝试解决，保证代码时间状态的可控  避免进入流态区  比如单纯复制、粘贴等导致重复劳动而无实际思考  接受不可控制中断，并通过其它方式控制  结对编程 TDD  通过结对编程、休息（上厕所、洗澡）来解决阻塞 尝试「创造性输入」（音乐、小说、电影）来实现「创造性输出」 关注调试、调试时间 保持节奏，拒绝盲目冲刺 接受帮助，并积极帮助他人  测试驱动开发 关键词  Kent beck TDD
法则 单元自测未实现前，不编写产品代码
 单元自测失败、无法通过编译时，不再写测试代码
 产品代码恰好让当前失败的单元测试通过即可
  优势  确定性 缺陷注入率 勇气  重构的勇气  文档  测试单元即文档  设计  代码开发前，先编写失败场景 帮助隔离功能范围，避免耦合   局限  场合并非全然适用  练习 项目  编程柔道场 卡塔 瓦萨  开源 验收测试 过早精细化  不确定原则 预估焦虑
迟来的模糊性 开发前才会将需求具体化
  验收测试  完成定义  代码开发完成 测试通过 QA和需求方认可  沟通 自动化测试 与测试开发人员协商 验收测试和单元测试 持续集成  测试策略 QA 找不到任何错误  目标如上 QA 也是团队的一部分，帮助进行需求定义和特性描述
自动化测试 单元测试
 XUnit 开发自测 ~100%  组件测试
 API 测试为主，测试为辅的业务测试 ~50%  集成测试
 API 架构师或主设计师编写 编排测试，不测试业务，主要测试组件装配协调情况 ~20%  系统测试
 GUI 系统架构师和技术负责人编写 针对整个集成系统运行的自动化测试 ~10%  人工探索式测试
 ~5%   时间管理 会议  认知  会议是必需的 会议浪漫大量时间  拒绝  管理自己的时间，确保会议对工作有显著成效  离席  觉得浪费时，找理由退出  开会准备  提供议题、时间、所要取得的成效 开会途中保证议程在范围内  立会  问题  昨天干了啥？ 今天打算干啥？ 遇到了什么问题？  要求 每人发言不超过1分钟  迭代计划会议  控制时间  回顾和 Demo 会议  推荐最后一天下班前45分钟 20分钟回顾，25分钟演示  争论  5分钟解决不了的争论，用数据论证   注意力点数  来源  充足的睡眠！  辅助  咖啡因，适量  恢复  转移注意力，如散步、聊天、沉思 运动：用肌肉注意力来改善   时间拆分  番茄工作法  流程  连续工作25分钟（保证注意力不转移） 休息5分钟 四个番茄时间后休息30分钟  推荐  番茄工作法图解：简单易行的时间管理方法    避免行为  优先级错乱  试图通过借口优先处理某任务，来逃避真正紧急的任务  死胡同  发觉后，及时止损  泥潭  确保专业性   预估 正常对待预估  承诺  必须完成！ 不能实验的承诺也是欺骗，仅比明目张胆的欺骗好一点  预估  预估= 概率分页 墨菲定律  可能出错的，那么就一定会出错  暗示性承诺  PERT
 解释  Program Evaluation and Review Technique 计划评审技术 1957年时，为支持美国海军的潜艇极地航行计划而设想实现  使用  参数  乐观预估 O  最快可能完成日期  标称预估 N  概率最高的完成日期  悲观预估 P  最晚可能完成日期   计算  期望完成时间 μ = (O&#43; 4N&#43; P)/ 6 = μ1&#43; μ2&#43; μ3&#43; &amp;hellip; 偏差可能性 σ = (P- O)/ 6 = (σ1^2&#43; σ2^2&#43; &amp;hellip;)^(1&amp;frasl;2)    预估任务
 德尔菲法  一组人集合讨论某任务，预估完成时间，直至意见统一  亮手指  针对任务，讨论涉及点、复杂因素和实现 各人预估0-5个手指的工作量（单位提前约定） 若基本偏差值在二以内则通过  规划扑克  手扑克的形式来实现“亮手指”的功能  关联预估  将任务均写在卡片上，然后打散 后逐一将任务卡由认定的工作量从左到右，从少到多排列 若某卡片被移动多次，则抽出单独讨论   大数定律
 将任务拆分后，预估再合并累加   压力 避免  认真应对承诺 保持代码整洁 坚持你保持的纪律  应对压力  既然改变不了，就冷静下来，寻求最好的解决办法 和团队、主管沟通  调整计划 请求支援  寻求帮助，比如结对编程  协作 程序员与人  雇主  注意力集中于雇主的需求 深刻理解业务目标  了解编写代码的业务价值 了解企业从你工作中能获得的回报   程序员  避免代码个体所有 结对编程  一起工作时效率最高的方式    结论  认知自己做程序员是为了避免过多交流 认知想做好，更需要学会交流  团队与项目 项目分配  不推荐！  有凝聚力的团队  创建  需要时间建立关系 学习协作，了解彼此的癖好、强弱项  12人  程序员* 7 测试* 2 分析师* 2  为需求编写自动化验收测试  项目经理* 1  发酵期  &amp;gt;= 6月  以团队优先  保障凝聚力的形成 默契配合，稳定顺利 若出现紧急情况，团队侧重转移即可保证项目的顺利进行   辅导 学位教育  被动接受，你了解的只是别人的一部分；如果你幸运的话 多写多试  辅导  观看别人的代码，观察别人的编码习惯 主动请求别人的帮助 代码 Review  学徒期思考  医生、电工、画家等都有适应过程，但程序员为什么不需要、不关心？ 把试错成本想得太低 观念上，对于技术层面的督导太过看淡  软件工程师各时期  大师  丰富从业经验 领导和协作多个团队 设计师和架构师  熟练工  学习如何卓越工作 学习成为团队领导者  学习生  在熟练工督导下工作，结对编程   追求技艺 工具 </content>
    </entry>
    
     <entry>
        <title>卡西欧-CASIO</title>
        <url>http://domain.yqjdcyy.com/post/%E5%8D%A1%E8%A5%BF%E6%AC%A7-casio/</url>
        <categories>
          <category>艺术</category>
        </categories>
        <tags>
          <tag>手表</tag>
        </tags>
        <content type="html">  品牌 简介  1946年4月  由㭴尾忠雄创立 生产香烟指环  1954年成功研制首台电子计算机 1957年  卡西欧推出14-A型、全球首款全电子计算机 公司更名称卡西欧计算机株式会社，专门研发电子产品  1983年  伊部菊雄设计的首款 G-Shock 问世   参考  CASIO 官网 G-Shock 官网  明细 G-SHOCK MTGS1000V-1A 价格  7,000  机芯  SMART ACCESS  规格  表壳纵向尺寸  58.6mm  表壳横向尺寸  53.5mm  表壳厚度尺寸  15.5mm  重量  188g   功能  3G防护构造 200M 防水 夜光 太阳能 6局电波 指针位置自动修正 世界时间(29个城市) 秒表（1/20秒） 倒计时 蜂鸣响音闹铃 低电量警告 全自动日历  参考  一块与众不同的G-SHOCK-MTG-S1000V-1AJF MTGS1000V-1A  欣赏       </content>
    </entry>
    
     <entry>
        <title>妙梅家招牌</title>
        <url>http://domain.yqjdcyy.com/post/%E5%A6%99%E6%A2%85%E5%AE%B6%E6%8B%9B%E7%89%8C/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  蒸鸡 [2.5&amp;frasl;5] 材料  八角 桂皮 香菇 香葱头 当归 料酒 生姜 鸡  工具  电饭锅 蒸架  流程  鸡洗净过水，各材料切好洗净 盐，料酒里外抹一下 各材料塞里面，隔水蒸一小时  腌萝卜 材料  白萝卜* 1 小米椒* 8 姜* 1 醋* 5 盐* 1&#43; 1 糖* 1  流程  白萝卜去皮、切条或薄片 加盐揉匀后静置三十分钟以上 小米椒、姜切丁 将白萝卜沥干后倒入容器，加入小米椒、姜、醋、盐和糖后拌匀，隔天食用  </content>
    </entry>
    
     <entry>
        <title>宝珀-Blancpain</title>
        <url>http://domain.yqjdcyy.com/post/%E5%AE%9D%E7%8F%80-blancpain/</url>
        <categories>
          <category>艺术</category>
        </categories>
        <tags>
          <tag>手表</tag>
        </tags>
        <content type="html">  品牌 简介  1735年，Jehan-Jacques Blancpain创立宝珀品牌 1926年，宝珀制表厂与制表师John Harwood合作，推出首款自动上链腕表。 1953年推出的五十噚腕表，成为潜水腕表的标杆之作。 制表厂加入瑞士钟表工业股份有限公司（Société suisse pour l’industrie horlogère，SSIH），与欧米茄、天梭、Lemania等品牌并驾齐驱。 1735腕表，汇集五大复杂功能：三问报时、陀飞轮、万年历、月相与追针计时码表。     参考  blancpain 品牌历史 腕表之家-宝珀  明细 五十噚 5000-0130-B52 A 基本信息  自动机械 男士
价格 ¥ 98000
机芯 机芯型号： 1315
 机芯直径： 30.60毫米
 机芯厚度： 5.65毫米
 宝石数： 35
 零件数： 227
 动力储备： 120小时
外观 表径： 43.60毫米
 表壳厚度： 13.40毫米
 表壳材质： 缎面磨砂黑色陶瓷
 表盘颜色： 黑色
 表盘形状： 圆形
 表镜材质： 蓝宝石水晶玻璃
 表带颜色： 黑色
 表带材质： 帆布
 表扣类型： 针扣
 表扣材质： 钛金属
 背透： 背透，蓝宝石水晶玻璃表背
 防水深度： 300米
功能 日期显示
参考 [](http://www.blancpain.com/zh-hans/5000-1110-b52a)
 宝珀五十噚系列5000-0130-B52 A腕表
 [开箱作业] 低调内秀 - BLANCPAIN五十噚深潜器【黑色陶瓷版】
补充 科技陶瓷的重量已经比钢要轻60%
欣赏           </content>
    </entry>
    
     <entry>
        <title>工装鞋</title>
        <url>http://domain.yqjdcyy.com/post/%E5%B7%A5%E8%A3%85%E9%9E%8B/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>鞋</tag>
        </tags>
        <content type="html">  参考 鞋靴 | 我要给第1次买工装靴的人，挑一双穿10年的靴子
品牌 顶端 Viberg  炒作嫌疑，价格虚高，不推荐   Wesco、White&amp;rsquo;s Boots  现货 $400&#43;， 定制 $600&#43;   中端 Danner  户外、军靴，全地形、防水   Red Wing  美产，经典款875、8111、9111、9013   Chippewa  工程师靴创始人   Wolvrine 1000mile  耐磨皮大底，接近皮鞋   低端 Timberland  大黄靴10061，非手工靴   CAT  打折 $50&#43;   Red Wing 875 介绍  选用了 Oro Legacy 皮革，鞋头偏翘。橡胶制鞋底，有小型的胎面设计，缓冲功能极高 1200&#43; ， 专柜 2600&#43;
样式    9111 介绍  圆头工作靴，为农民打造 选用的是 S.B. Foot Tanning Co. 出产的油鞣革 Copper Rough &amp;amp; Tough Leather，可以防水防污，透气性比较高，颜色看起来也很自然。 Goodyear（固特异） 的制法，还可以在鞋底磨损后更换新底。 专柜 2500&#43;
样式   8111 介绍  琥珀色皮革，Nitrile Cork 鞋底 专柜 2500&#43;
样式   9013 介绍  自厂出品Chestnut Featherstone 皮革，圆形鞋头设计，Roccia 鞋底 高端产品，为创始人 Charles Beckman 为自己设计的商务靴 专柜 3000&#43;
样式    2268 介绍  重型工程师靴，为铁路工程师设计，受骑士追捧
样式   搭配      养护 油面皮 清除  清除皮革灰尘和沙粒，尤其注意车缝线处
清洁 清洁剂需均匀涂抹，避免留下难以去除的斑点
护理 擦皮革护理膏，注意车缝线和与鞋底接合处
打磨 搁置一天后擦除残留油迹至光泽透亮 -  麂皮 Featherstone皮面 </content>
    </entry>
    
     <entry>
        <title>技术人员的发展之路</title>
        <url>http://domain.yqjdcyy.com/post/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E7%9A%84%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>思考</tag>
        </tags>
        <content type="html">  技术人员的发展之路 阶段和标志 20-30岁  提升学习和解决难题的能力 提升领导力  高效学习能力  基础扎实，触类旁通 寻找前沿知识 看清问题和技术的本质 独立思考  解决问题能力  见过许多场景 犯过、处理过很多错误 防火   帮人解决问题 被人所信赖  发展方向 职场打拼  去顶尖公司 去真正的创业公司  小心了解创始人和业务情况、想法、理念 排除创业时的.侥幸和驱利心理  职业生涯发展  关心并处理复杂人事关系 学会使用政治手段  在下属和领导，员工和公司之间周旋 审时站队，迎合、妥协和交换 厚黑与真诚    经历有意义、价值的事  到技术创新的发源地去经历创新 去经历下一个热点技术的发展  追求一种自由的生活  工作自由  能力出众，不愁找不到工作  技能自由  自由职业者  自动化 App 上做软件个体户 开源软件，社区捐款   物质自由  投资&amp;amp; 风险 关注未来和长远的成长   </content>
    </entry>
    
     <entry>
        <title>歌川广重</title>
        <url>http://domain.yqjdcyy.com/post/%E6%AD%8C%E5%B7%9D%E5%B9%BF%E9%87%8D/</url>
        <categories>
          <category>艺术</category>
        </categories>
        <tags>
          <tag>浮世绘</tag>
        </tags>
        <content type="html">  歌川广重 简介  1811年他在江户成为浮世绘大师歌川丰广的学生 于1833～1834年间的55幅风景画系列《东海道五十三次》确立了他作为有史以来最受欢迎的浮世绘画家之一的地位 风格较为亲民、清丽，而有小品风范  风格  寓人手法  绘图主题是风景，但他会在画面上加入小人物的日常生活描绘，增添画面的生动感  四季情景的描绘  利用明暗、阴暗等技巧的呈现，可以在他的作品中感受到季节转换的感觉   作品  东海道五十三次 六十余州名所図会 江戸名所百景  赏析 </content>
    </entry>
    
     <entry>
        <title>水</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B0%B4/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  蒸 蒸馒头  10:00  蒸肉包  &amp;gt;= 12:00  蒸地瓜、玉米  &amp;gt;= 15:00 大块地瓜需要切段  煮 水煮蛋  水烧开后煮 7:30  速冻肉粽  水烧开后煮 15:00  速冻辣肠  水烧开后煮 15:00  </content>
    </entry>
    
     <entry>
        <title>汤</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B1%A4/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  冬瓜排骨汤 材料  排骨 冬瓜 葱、姜 盐
流程 葱挽结，姜、冬瓜切片
 排骨洗净，过开水焯后，冲净撇去血末
 冷水烧开后转小火煲一小时，后加冬瓜煲制十五分钟
 加盐、撇葱花后出锅
  土豆番茄牛腩汤 材料  牛腩 土豆、番茄、胡萝卜 姜、葱 盐、生抽、料酒
流程 牛肉泡水后洗净切块，焯水捞出
 姜切片，葱切段，番茄划线后过水去皮
 姜片、葱段、一半番茄、料酒、生抽与适量牛肉，大火煮开后炖2小时
 胡萝卜、土豆去皮切块，待番茄煮烂后与另一半番茄一同加入炖煮1小时
 加少许盐调味出锅
  黄豆花生猪脚 材料  猪脚 黄豆、花生 葱、姜 料酒、盐
流程 花生、黄豆提前泡8小时，猪脚拨毛、洗净、斩块、焯水后再洗净
 料酒、花生、黄豆、姜、葱炖煮2小时
 出锅前用盐调味
  奶白鲫鱼汤 材料  鲫鱼 葱、蒜、大白菜 白胡椒粉、盐 开水  流程  葱、大白菜洗净，蒜剥瓣 鲫鱼杀好，去鳞、鱼肚内黑膜后，洗净控干 热锅凉油，姜片爆香后放入鲫鱼，煎至两面金黄 煎好后加入葱段、蒜瓣，倒入开水后大火熬煮十五分钟 打去浮沫后，加入豆腐、大白菜转中火煮十分钟 出锅前五分钟加入盐、白胡椒粉即可  注意  煎鱼是为了去腥和定形 小火清汤，大火白汤 盐于最后放，避免破坏食材营养、口感  </content>
    </entry>
    
     <entry>
        <title>浏览器缓存知识小结及应用</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>Cache</tag>
        </tags>
        <content type="html">  浏览器缓存知识小结及应用 分类  强缓存  判断命中，则直接从浏览器缓存中读取资源，不发请求至服务器（200）  协商缓存  发请求至服务器，协商缓存命中，则返回请求（304），告知浏览器从缓存中加载   实现  强缓存  请求资源时，资源及其 response header 一并被缓存 再次请求时，优先比对该资源 header 中的  Expries（失效时间） 或 Cache-Control：max-age=315360000 &amp;amp; Date: Mon, 11 Jan 2016 06:41:22 GMT  对比判断是否命中 注：Cache-Control 为相对时间，都使用客户端时间进行判断，相比 Expries 的服务器时间对比更安全。  协商缓存  请求资源时，资源及其 response header 一并被缓存 再次和服务器请求该请求时，一并传上  header.Last-Modified: Tue 12 Jan 2016 03:08:53 GMT - 服务器上该资源的最后修改时间 header.If-Modified-Since: Tue 12 Jan 2016 03:08:53 GMT - 上一次浏览器请求时返回的 Last-Modified 值 或 ETag: &amp;ldquo;17fd8-5291a5f96fd20&amp;rdquo; - 请求资源的唯一标识 If-None-Match: &amp;ldquo;17fd8-5291a5f96fd20&amp;rdquo; - 上一次请求时的 ETag 值    </content>
    </entry>
    
     <entry>
        <title>甜</title>
        <url>http://domain.yqjdcyy.com/post/%E7%94%9C/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  芒果西米露 [4&amp;frasl;5] 材料  西米 小芒果 牛奶 蜂蜜  流程  芒果剖开刮下果肉 大量水煮西米，15分钟至剩下白芯后关火加盖焖熟 完全透明后捞起过冰水 起碗加入西米、牛奶、芒果和蜂蜜即可  南瓜饼 材料  南瓜 糯米粉 白糖  流程  南瓜去皮、去籽、切块后，倒入碗中，覆以保鲜膜后蒸10分钟蒸熟 加入白糖搅拌 冷却后，少量多次地加入糯米粉，和到不粘手 搓小圆后拍扁，后小火煎熟  </content>
    </entry>
    
     <entry>
        <title>精酿啤酒入门</title>
        <url>http://domain.yqjdcyy.com/post/%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92.%E5%85%A5%E9%97%A8/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>酒</tag>
        </tags>
        <content type="html">  酒-精酿啤酒 参考  夏日炎炎，来瓶啤酒 - 一次关于精酿啤酒的安利 推荐7款精酿的啤酒，也许能让你爱不释手 角鲨头 Dogfish Head——一个神奇的啤酒厂 BrewDog 啤酒狗顛覆你對啤酒的想像!  分类 拉格 Lager  工业啤酒，保证生产规模 下层发酵，酵母在底部发酵，温度在 10℃ 以下，发酵时间长 口味清淡，味道单一  艾尔 Ale  上层发酵，酵母在麦汁顶部，温度于 10℃-20℃，发酵时间短  推荐 Blue Moon - Belgian White  比利时白色小麦啤酒 特点  淡麦芽香和少量橙香 入口柔和清甜，水果风味突出 模仿福佳白  欣赏    推荐  口粮酒   Hoegaarden Belgian Witbier  福佳白 比利时白色小麦啤酒 特点  口感清淡，酒体轻盈 小麦和蔬菜清香，微微酸甜 类似口感如 1664 白啤  欣赏    推荐  入门级   燕京原浆白啤  特点  酒体琥珀，泡沫稀少，口感轻盈 丁香、香蕉和面包香气  欣赏    推荐  性价比   Tripel Karmeliet  比利时三料啤酒 特点  小麦、燕麦和大麦混合酿造 酒体金黄，泡沫深厚持久 味道偏浓 前调  麦香&#43;酵母&#43;复合果味 麦香、胡妥、花香  中调  橙子、香蕉、蜂蜜  后调  回甘   欣赏    推荐 -  Orval Belgian Pale Ale  比利时淡色艾尔 特点  酒体粽红，泡沫极为丰富细腻 浓烈的酒花香，橙香，浓郁的花香和药香 浓郁的酒花香气，玫瑰花瓣的香气以及酵母带来的独特微酸口感  欣赏     推荐 -  Westvleteren 12 (XII)  比利时四料啤酒 特点  棕褐色酒体，泡沫轻盈一指高 复杂的水果香气，熟苹果、梨、糖浆、麦子、坚果和草药香，复合的香料味道以及浓郁的酵母气息 甜蜜轻柔，回味悠长  欣赏    推荐  号称世界第一   Jacob Leinenkugel Grapefruit Shandy  特点  西柚香，汽水口感，偏甜  欣赏    推荐  牛饮   Stone Coffee Milk Stout  增料世涛 特点  口感醇厚，酒体咖啡色，泡沫稀少 浓郁咖啡豆、巧克力、糖浆和烧烤麦芽香 入口厚重，丝滑奶油感  欣赏     推荐 -  Lefthand Milk Stout Nitro  氮气牛奶世涛 特点  氮气封装，开瓶后泡沫更柔和细腻 酒体浑浊黑亮，泡沫稀少但细腻 入口顺滑，苦味下降，回味清淡 奶味、巧克力、烧烤麦芽香  欣赏    推荐 -  Stone go to IPA  Session IPA 特点  清淡型，充满水果香，口感爽脆 建议即时享用  欣赏    推荐  牛饮   Stone Imperial Russian Stout 2016  帝国世涛 特点  每年放出，实力产品 黑色酒体，几乎无泡沫， 焦糖、烘烤、酱油、咖啡以及酒精味 酒体非常厚重，深色水果的甘甜，糖浆味，太妃糖，烘烤麦芽散发出的厚重苦味 酒精感强，回味较长，酱味、酒精味  欣赏     推荐  Top 50   Stone ARROGANT BASTARD ALE  美式烈性艾尔 特点
 酒体琥珀深红，泡沫不多，轻盈的麦香酒花香 前调  入口味道刺激，超高IBU的苦度和酒精感直冲脑门 酒花的果实香气以及青草香气非常强烈和鲜明  中调  复合的柑橘类水果香气以及焦糖甜  后调  强烈而持久的苦   欣赏
    推荐  Flying dog BloodLine Orange IPA &amp;amp; Gonzo Imperial Porter  特点  血橙IPA，橙黄色酒体，泡沫比较丰富 微甜、微酸、苦  青草、菠萝、橙皮 酒花气息 浓郁的黑可可、黑咖啡，焦香伴 随烘烤麦芽以及酵母的香气   欣赏     推荐  易饮   North Coast Old Rasputin Russian Imperial Stout  帝国世涛 特点  黑色酒体，少泡沫，比较浓的咖啡豆味和酱味 酒体厚重，浓郁持久的烘烤麦芽、焦香、咖啡味  欣赏    推荐  典型代表酒款   Founder Porter  波特 特点  黑色的酒体，少泡沫 浓郁的麦芽、咖啡豆香气 酒体中等厚重，奶油班顺滑，先甜后苦  欣赏    推荐  典型代表酒款   Founders Breakfast Stout  增料世涛 特点  黑色酒体，稀少泡沫，咖啡、麦芽香 入口非常柔和，非常平衡的甜苦度 前调  咖啡香  中调  可可豆、烘烤麦香和燕麦  后调  咖啡、可可以及麦芽   欣赏     推荐  口粮酒 TOP 排行榜常客   Founders Lizard of Koz  过桶增料帝国世涛 特点  酿酒师 Kosmick 为他妹妹 Eilzabeth 庆生的特别配制款，8个月波本桶陈酿，12个月完成 酒体深黑色，无泡沫 焦糖、树莓、黑巧克力风味，酒精感强烈  可能会体现出塑料味   欣赏    推荐  猎奇   Founders KBS 2017  过桶帝国世涛 特点  基酒 breakfast stout，波本桶陈酿 深黑色酒体，泡沫稀少 前中调  黑巧克力、咖啡豆、香草 &#43; 波本威士忌  后调  烘烤麦芽、全麦面包和酒精   欣赏     推荐  限量款 顶级   Goose Isalnd Bourbon Country Brand Stout 2015  过桶帝国世涛 特点  酒体纯黑厚重，泡沫近乎无 波本威士忌、黑咖啡、黑巧克力、香草、酸梅  欣赏      推荐  限量 里程碑   ALE Smith SPEEDWAY STOUT COFFEE  咖啡帝国世涛 特点  酒体深黑色 黑咖啡。香草、黑巧克力、烘烤麦香 口感厚重，咖啡香气缓缓展开  欣赏   ![]()  推荐  ALE Smith酒厂的绝对主力   Firestone Walker PARABOLA &amp;amp; STICKEEMONKEE  过桶比利时四料 特点  纯黑色酒体，泡沫稀少 烘烤麦芽、椰香、黑巧克力、香草、咖啡、水果干 甜苦平衡、糖浆感重，回味持久  欣赏     推荐  Firestone Walker的顶级佳酿   The Lost Abbey RED POPPY  老棕啤/红啤 特点  酒体深棕色，泡沫较稀薄，较强的单宁和酵母味 陈皮、柠檬、车厘子、木头和酵母  欣赏     推荐  开胃酒   Dogfish Head 120 Minute IPA Limited Edition  帝国IPA 特点  深琥珀色酒体，气泡丰富，没有泡沫，酒精度高（15%-20%） 极高的苦味度，丰富的麦香酒花香以及酒香  欣赏     推荐  限量   RUSSIAN RIVER Pliny the elder 07/12/2017 release  Double IPA 特点  IPA酒花、橙子、菠萝和青草  欣赏     推荐  Double IPA 的开山鼻祖、No.1   60 minute IPA  dogfish head 特点  淡琥珀酒体，泡沫细腻持久 酒花、橘皮、青草  欣赏    推荐 -  90 minute IPA  dogfish head 特点  琥珀色酒体 柑橘、焦糖、麦香  欣赏    推荐  全美销量最好   PUNK IPA  BrewDog 特点  淡黄色酒体，泡沫丰富持久 水果、酵母、酒花香 苦味、酒花味回味持久  欣赏     推荐  口粮酒   Rochefort Trappistes 10  Brasserie Rochefort 特点  红褐色酒体，泡沫细腻持久 水果、麦香、酒花、焦糖、巧克力 层次丰富，厚重持久  欣赏    推荐 特点
 酒体浅黄色，淡淡啤酒花香，酸梅香，青苹果香 入口清淡，似工业酒  欣赏
   推荐
 仅供尝鲜   目标  Blue Moon Westvleteren 12 dogfish head  60 minute 90 minute  Brewdog  punk IPA  Rochefort Trappistes 10  备注  评分  ★☆☆☆☆ ★★☆☆☆ ★★★☆☆ ★★★★☆ ★★★★★   </content>
    </entry>
    
     <entry>
        <title>肉</title>
        <url>http://domain.yqjdcyy.com/post/%E8%82%89/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  参考  高分肉菜 - 0/7  料理 啤酒鸭 [4&amp;frasl;5] 材料  鸭 啤酒 姜、蒜 干辣椒、八角 盐、糖、食用油、老抽、生抽  工具 流程  鸭肉洗净切小块，淋水备用 炒锅加热，倒油后加入姜片、葱段、蒜瓣、八角和干辣椒炒香 加入鸭块大火翻炒到鸭皮收缩、颜色发白，后调至小火煸炒出鸭油 倒入少许老抽上色、适量生抽提味，少许糖、盐并翻炒均匀 倒入啤酒没过鸭肉一厘米，并中小火焖30分钟 鸭肉熟软后，大火收汁  豆腐烧肥牛 [4.3&amp;frasl;5] 材料  肥牛片 嫩豆腐 大葱* 0.5d、葱花、蒜末* 2 酱油* 2 料酒* 1 水* 3 糖* 1  流程  肥牛切片，豆腐切块，大葱切段，调味料搅拌均匀 分次放入调味料、豆腐、肥牛和大葱 加盖煮开，转小火闷8分钟  可乐鸡翅 [4&amp;frasl;5] 材料  翅中 可乐 盐、料酒、老抽、生抽 生姜片* 5 桂皮* 0.5  流程  鸡翅划刀，放入葱姜片和水煮开，后捞出沥干 小火微油，将鸡翅煎至金黄 放入可乐、一大勺料酒，一勺老抽，两勺生抽，桂皮和盐 烧开后转小火炖煮至收汁适宜  红烧肉 [4.5&amp;frasl;5] 材料  五花肉 葱、姜、蒜、花椒、大料、小茴香、干辣椒 冰糖、生抽、老抽、盐  流程  五花肉洗净切块，大小均2厘米，葱切段，姜、蒜切片 热锅冷油，放入葱、姜、蒜、花椒、大料和小茴香、干辣椒，煸炒出香味 转中火，放入五花肉煸炒至变色出香 大火热油，放入冰糖一捧，炒化后转小火并与炒好的肉翻炒 加热水没过肉，并加入生抽和些许老抽，煮开后转小火慢炖30分钟 加入盐和少量冰糖，翻炒后转大火收汁即可  咖喱鸡肉 [5&amp;frasl;5] 材料  鸡腿肉 咖喱块* 4 椰汁 紫皮洋葱* 1 土豆、胡萝卜 淀粉  步骤  鸡肉切块，土豆、胡萝卜切丁，洋葱切丝 鸡肉加淀粉、料酒、些许酱油和盐抓匀 加油轻炒土豆、胡萝卜至土豆出味、表面金黄 小火些油，焯洋葱出甜味后，加入鸡肉翻炒至变色 加入土豆、胡萝卜、咖喱块，并加清水没过全部食材 小火煮，加入椰汁适当搅拌 最后放入少许洋葱丝、黑胡椒粉提味  泡椒凤爪 材料  鸡爪 泡椒 姜、蒜、八角、桂皮、香味、花椒 白醋、盐、鸡精
流程 鸡爪洗净去角对开
 鸡爪入锅，加姜片、蒜瓣、花椒、香叶、八角、桂皮、盐煮13分钟
 鸡爪捞出冲水晾凉
 用凉白开、泡椒、白醋、鸡精和盐调味后，放入鸡爪腌3-5小时
  黄焖鸡 材料  鸡肉 香菇、青椒、红萝卜 姜、蒜、葱头 盐、生抽、老抽、料酒、蚝油 生粉
流程 鸡肉洗净切块、姜切片，蒜去皮，葱头洗净，干香菇泡发、青椒去籽后和红萝卜一并切块，
 加入姜片、料酒、盐、生抽、蚝油和生粉抓匀后腌制20分钟
 热锅冷油，下姜、葱、蒜大火爆香
 鸡块煸炒至鸡皮收缩，后加入香菇、红萝卜翻炒
 加入盐、生抽、老抽、蚝油和白糖翻炒均匀
 加过肉一半的开水，烧开后转中火料焖煮二十分钟
 大火烧干后放入青椒，翻炒出锅
  泡椒凤爪 材料  鸡爪 泡椒 小米椒 大葱/ 生姜 花椒/ 桂皮 白酒/ 盐/ 冰糖/ 芝麻油/ 鸡精 白醋  流程  鸡爪洗净后去指对切，萝卜切条，生姜切片，泡椒剪开，大葱切段 鸡爪冷水下锅，水开后多煮4分钟，后捞出冲洗多次 倒入泡椒水，并放入适量水/ 生姜/ 冰糖/ 盐，水一开就盛起 热锅热水，倒入葱/ 姜/ 花椒/ 桂皮/ 白酒，煮9分钟 鸡爪捞出冲洗凉透后放入泡椒水里，倒入白醋/ 芝麻油/ 鸡精 搅拌均匀  香卤牛肉 材料  牛腱 八角、沙姜、桂皮、草果、香叶、花椒、陈皮、干辣椒 姜、葱 生抽、料酒、盐 纱布袋  流程  清水烧开，将香料装入纱布袋后置入，并加适量料酒、生抽、盐和糖；大火烧开后转小火加盖煮15分钟 牛腱洗净切大块，冷水、花椒和数滴料酒下锅，不断翻动确认焯干净 牛腱焯水后捞出冲洗干净，置于冷水浸泡 烧开卤汗，放入牛腱后转中大火煮15分钟，后转小火焖煮80分钟 关火后捞出葱等材料，让牛腱在卤汁中浸泡过夜  注意  蘸汗  生抽、姜、葱、蒜、花椒、辣椒粉、醋、香油  香料袋  小粒  花椒、干辣椒等  易煮烂  陈皮   卤汁收藏  过滤、煮开后，待冷却后装瓶密封冷冻 若冷冻雪藏一个月内不用，需要拿出解决、重新煮沸、冷却、装瓶、冷冻  卤汁再用  加水至基本淹没食材，并补充盐、生抽、料酒和其余香料（一半以下即可）   吉野家牛肉饭 材料  肥牛肉 洋葱 料酒、米酒、酱油 糖  流程  洋葱切丝，待水烧沸后放入，并添加料酒、米酒和糖 放入肥牛肉片，去沫 加酱油，中小火煮20分钟  洋葱酥卤肉饭[4.5&amp;frasl;5] 材料  五花肉* 500g 洋葱 油菜 鸡蛋* 4 葱/ 姜/ 蒜/ 香菇 八角 冰糖/ 食盐/ 老抽/ [绍兴黄酒|加饭酒]  流程  五花肉、香菇切丁，葱、姜、蒜切末 鸡蛋水煮后泡凉水后去壳 洋葱切条后，小火油炸至金黄，待控油晾凉后切碎 热锅冷油，炒五花肉至变白出油 依次加入香菇、葱姜蒜末、老抽、黄酒、油葱酥翻炒均匀 加入温水、八角、冰糖煮开后，加入水煮蛋、食盐转小火慢炖90分钟  注意  汤汁浓稠但绝不能干  辣子鸡 材料  鸡腿肉 干辣椒 花椒 葱、姜、蒜、芹菜 八角、香叶 料酒、糖、盐、五香粉、酱油、白酒  流程  鸡腿肉去骨、切块，用料酒、五香粉、盐和葱、姜腌制20分钟 辣椒洗净切段 热油中小火，将鸡肉完全炸熟，颜色由白转黄后捞出 热油大火，将鸡肉炸至金黄后，捞出沥干备用 热锅底油，依次炒香花椒、姜，葱、标、八角和香叶，辣椒 加入鸡块翻炒，并放入少量的糖和盐，料酒|白酒和五香粉 最后加入芹菜段，翻炒至断生即可出锅  黑蒜子牛肉粒 材料  牛里脊* 500g 大蒜* 25粒 白胡椒粉、黑胡椒碎、淀粉 生抽、老抽、料酒、糖 黄油、花生油 洋葱、 蛋清  流程  大蒜剥瓣、洋葱切丝 牛里脊洗净晾干水分后，切1.5厘米见方大丁 牛肉丁加生抽、料酒、白胡椒粉、老抽和洋葱丝，腌制1小时 挑掉洋葱丝，加入鸡蛋清和2大勺淀粉，搅拌均匀 热油后炸蒜瓣到金黄后，捞出备用 滑炒牛肉至变色后，捞出备用 小碗中倒入黑胡椒碎和生抽各一勺，糖和水淀粉各2大勺，搅拌均匀 冷油中加入黄油，热锅至黄油冒泡后，依次倒入牛肉粒、酱汁、蒜瓣翻炒均匀即可  笋干烧肉 材料  五花肉 笋干 姜、八角 冰糖、生抽、老抽、料酒  流程  笋干浸泡两天，中途多次换水，天热时需放冰箱 五花肉切麻将大小，生姜切片 冷水锅，焯五花肉至水烧开，后捞出冲洗干净、沥干 小火煎五花肉至两面金黄，后男加入八角、冰糖、生抽、老抽和料酒翻炒至肉均匀上色，并国加入笋干 倒入开水，大火烧开，撇去浮沫后，转文火炖煮1小时 大火收汁后加盐盛盘  清蒸鲈鱼 材料  鲈鱼 姜、葱 盐、料酒、蒸鱼鼓油、食用油  流程  姜、葱切丝，鱼洗净片痕 鱼抹盐和料酒去腥，腌20分钟 水开后，将鱼放入蒸8分钟，起锅时将汤汁盛出至小碗 鱼表面淋蒸鱼豉油，热油后淋至鱼身，并将汤汁倒回鱼身  洋葱炒牛肉 材料  牛肉 洋葱 老姜 辣椒酱 淀粉 酱油 料酒 油 芝麻油 白糖 水  流程  牛肉洗净、沥干、切条，姜剁末，洋葱切条 加入淀粉（0.3勺）、酱油（0.3勺）、白糖（0.3勺）和料酒（1勺）拌匀腌制，下锅前拌油（0.5勺） 热锅热油，烧至八成熟后将牛肉和洋葱过油后，捞出沥油 锅中留少量油，大火炒姜末爆香后，转小火下洋葱和牛肉 加入清水（1勺）、辣椒（0.5勺）、酱油（0.5勺）、芝麻油（0.5勺）、盐（0.5勺）和白糖（0.3勺）后转大火翻炒收汁 出锅前加少许料酒  香辣牛腩 材料  牛腩 800g 葱* 1 青蒜* 1 姜* 1 大蒜* 1 香叶* 2 片 大料* 1 辣椒粉* 1 花椒粉* 1 花椒粒* 1&amp;frasl;2 白糖* 1.5 酱油* 10 清水* 2.5cup 料酒* 3 香油* 1&amp;frasl;2 辣椒酱* 2 盐* 1  流程  牛腩浸泡冷水两小时（期间换水），洗净沥干后切块 热锅冷水，加入牛腩、姜、花椒粒后煮开，撇去浮沫后捞起牛腩 加入清水、牛腩、调料后大火烧开，转小火炖煮约两小时  建议  牛腩汁可卤溏心疍、牛腩面汤头  糖醋排骨 材料  肋排* 2 姜 葱 料酒、生抽、糖、醋 老抽  流程  排骨切块、洗净，葱切段，姜切片 排骨冷水入锅，煮沸2分钟后捞出 调糖醋汁，料酒：生抽：糖：醋：水= 1:2:3:4:5 爆香葱、姜后加入排骨，炒至金黄后加入糖醋汁，并补充清水至水没过排骨；大火煮开后转小火煮20分钟 加老抽上色后，大火收汁  白斩鸡 材料  三黄鸡 姜 葱 黄酒 生抽 老抽 糖 麻油  流程  冷水下鸡、姜片、葱结，水没过鸡身，添加黄酒、盐，开大火烧开后转中火煮10分钟 熄火带盖焖25分钟 将鸡捞出过冷水洗净，放入冰水中浸泡5分钟** 调制藮酱：鸡汤：生抽：老抽：糖= 3:2:0.7:0.25，并加入姜末、葱花和麻油调匀  炸酥肉 材料  五花肉* 350g 鸡蛋* 2 花椒 淀粉* 3 面粉* 3 食盐 白糖 料酒 酱油
流程 五花肉去皮洗净，用厨房专用纸巾吸干水分，顶刀切 0.5厘米片
 花椒微烤，压扁后，与肉、盐、糖、料酒和酱油拌匀静置10分钟
 打入鸡蛋搅匀静置10分钟
 淀粉和面粉等比例加入，保证最后能均匀挂在肉片上
 三厘米左右的油，8成熟时放入肉片，搅动直至表皮坚硬后捞起
 沥去残渣后，加油至三厘米，8成熟时将肉倒入复炸至表皮金黄后，捞出控干
  </content>
    </entry>
    
     <entry>
        <title>股权&amp;期权</title>
        <url>http://domain.yqjdcyy.com/post/%E8%82%A1%E6%9D%83%E6%9C%9F%E6%9D%83/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>商业</tag>
        </tags>
        <content type="html">  股权、期权有哪些坑？从技术创业的角度说开去 比例 依赖独特技术  技术* 50% 业务* 40% 管理* 10%  依赖业务领先  技术* 40% 业务* 50% 管理* 10%  注意  一开始就要定位准确！  股权 经营  退出机制  建议股份强制回收 提前写好退出机制和退出价格 退出价格为下列最高值  上一轮融资估值* 50% 上一年财务合同额 公司总资产 真实投资资金年利息* 115%  退出股权优先卖给现有参与经营的股东   注意  股权比例，即合伙人配比  期权 使用  第一期建议 10%  吸引人才，后根据每年需求发放 CEO 出方案定值，后股东投票  一次性强留足 30%  发完回收才会发现这个问题   规则  时间  分3年给，每年落实 1&amp;frasl;3  行权  可象征性出点 在期权池公司落实工商登记股分  价格  同股权一样商量  权益  仅分红，无投票  落实  设置持股公司  期权池公司拷贝母公司 10% 股分 初始期权池公司 CEO 100%的持有 签订员工期权协议，分3年在期权池公司落实工商登记股份 每年变更一次期权池公司名录和股分比例，落实员工利益    注意  作用  对股权结构不合理信息的弥补 对核心员工的奖励  来源  全体股东一起稀释  按比例，不要按数量 后面增发期权，则再创建一持股子公司即可  投资 是否要  要！  需要外部投资人作为第三方的视角审查   时机  产品出来 有真实用户和运营数据 估值清晰 数据客观  创业落脚点 明确越高越难  不违法 不违反道德 创新技术 创新业务 改变人类生活  类型 战略  你的战略是投资人的子战略  天花板就在那 在乎的是投资人自己的梦想，不在乎你的梦想  战略完全一致的是竞争对手 战略投资协议需补签  财务  投资人在乎赚钱、回报 给压力实现盈利、实现价值用户数量 尽量不要签对赌协议  众筹  对象  外面的朋友 顾问   初创  自行掏钱，会更谨慎 找天使投资人，看个人魅力  本质 商业= 生意&#43; 梦想  思考点  细分行业 细分客群 细分产品 细分用户 创造新概念 开拓新产品  图例
 注意  价值主张坚持十年！
 老大从来都是从老大做成老大的，从老二做到老大是很困难的
 列举100 个给你付费的客户的名字，否则就不用创业
  觉悟  找人找钱找方向 你以为的公司问题，其实都是创始人的问题 第一件事情要坚持，第二件事情要不要脸，第三件事情要坚持不要脸  </content>
    </entry>
    
     <entry>
        <title>菜</title>
        <url>http://domain.yqjdcyy.com/post/%E8%8F%9C/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  烫生菜 [3&amp;frasl;5] 材料  生菜 蒜 生抽
工具 流程 生菜洗净焯熟
 蒜末炒香，关火后加生抽搅匀后淋在生菜上
  酸辣土豆丝 [3&amp;frasl;5] 材料  土豆 青辣椒 干红辣椒、大蒜、葱、姜、花椒 醋、盐  流程  土豆切丝，辣椒切段 花椒炸香后捞出，放入葱姜辣椒爆香 倒入土豆丝和醋翻炒一分钟 加入青辣椒、盐、蒜翻炒均匀  西红柿炒鸡蛋 材料  西红柿* 2 鸡蛋* 2
流程 西红柿对划后于开水中煮后去皮、对切去芯、切小块后加少许糖腌制出汁
 鸡蛋打散后，加等比30%凉开水搅拌至起泡
 热锅5汤匙凉油，油微起烟时转小火并倒入蛋液，并用筷子顺时针不停搅拌，在蛋液快凝固时盛出
 放油后加入西红柿、少许水和盐，压碎翻炒，待汤汁足够时倒入炒蛋翻炒收汁即可
注意事项 挑西红柿时挑扁圆、深红，轻按略软者
 顺西红柿底部凹槽切下，避免流汁，切好后去蒂
  青椒茄丝 材料  茄子 青椒 蒜  流程  青椒切丝，蒜切末，茄子切细条（越细越好） 热锅起油，蒜末煸出香气后，放入青椒大火快炒 倒入茄条、生抽翻炒后，扣盖焖两分钟 加入盐、鸡精翻炒 起锅前倒入醋  秋葵 材料  秋葵 葱、小米椒 生抽、油、盐  流程  盐水浸泡5分钟，后反复冲洗，去柄 水滴油、加盐煮开后，煮开后加入秋葵煮3分钟至断生 捞出后放入清水中放凉，后竖切摆上小米椒、葱末、少量生抽 起锅热油后泼到秋葵上即可  红烧茄子 材料  茄子 蒜 老抽、白糖、水  流程  茄子滚刀后，放入盆中加盐（3勺），静置10分钟后1攥出水 蒜切丁，加入老抽、糖、水后待用 热锅热油，倒入茄子炒至金黄 将配料倒入炖煮10分钟  清炒豆芽 材料  豆芽 葱、蒜、辣椒  流程  豆芽去头洗净，葱切段，辣椒切丝，蒜瓣切碎 热锅热油，蒜瓣爆香后倒入豆芽15秒 补葱段、辣椒丝快炒15秒 加盐调味，炒匀出锅即可  大根烧 材料  白萝卜
 蔬菜粉| 味噌| 鸡粉 水
 酱油  流程  白萝卜去皮，切成圆形厚片 水开后放入白萝卜和蔬菜汤包，用中小火煮软 白萝卜捞出沥乾备用 白萝卜两面沾上酱油，用中大火煎至焦香  锅塌豆腐 材料  老豆腐 鸡蛋* 2 淀粉* 2 盐* 1 生抽* 1 蚝油* 1 糖 鸡精 香油 小米椒 大葱 姜  流程  姜切丝、大葱切片、小米椒切段、鸡蛋打散 老豆腐切块后撒盐、干淀粉腌制片刻 热锅温油后，将豆腐裹匀蛋液后置入油中，煎至两面金黄后捞出沥油 留油，加入葱、姜、小米椒和虾皮爆香后，加入生抽、蚝油、水、糖煮开 转小火后摆好豆腐，两面煎制后撒鸡精、淋香油即可  香煎豆腐 材料  豆腐* 1 葱* 1 酱油* 3 蚝油* 1 白砂糖* 0.5 油  流程  豆腐洗净、沥干后切块 热锅少油，中小火将豆腐煎至两面金黄 加入蚝油、酱油、白糖和三分之一碗清水 收汁加葱段即可出锅  手撕包菜 材料  包菜* 0.5 小米椒* 5 五花肉* 250g 蒜 姜 盐* 0.25 蚝油* 1 生抽* 1 花椒油* 0.5  流程  包菜用手撕成小块，洗净沥干 五花肉切片、小米椒切段、蒜姜切粒 热锅冷油，小火干煸五花肉至白色后，加入小米椒、蒜、姜爆香 加入包菜、盐、蚝油、生抽，中火翻炒 炒至白菜变软后，加入 花椒油|香油 即可出锅  西红柿炒蛋 材料  西红柿* 2 鸡蛋* 3  流程  西红柿滚刀块，鸡蛋与白醋、盐打散 热锅冷油，小火将蛋煎定形后打散后盛出 小火翻炒西红柿后，加水煮一分钟，再依次加盐、糖、水淀粉、油即可  炝炒土豆丝 材料  土豆 大蒜 干辣椒、花椒 盐、糖、生抽、醋  流程  土豆切丝后过水洗净淀粉，大蒜切片， 烧开水后加白醋，煮土豆丝至颜色发透 小火爆香大蒜、干辣椒、花椒后加土豆丝炒至断生 出锅前加盐、糖、生抽|醋翻炒均匀  </content>
    </entry>
    
     <entry>
        <title>葛饰北斋</title>
        <url>http://domain.yqjdcyy.com/post/%E8%91%9B%E9%A5%B0%E5%8C%97%E6%96%8B/</url>
        <categories>
          <category>艺术</category>
        </categories>
        <tags>
          <tag>浮世绘</tag>
        </tags>
        <content type="html">  葛饰北斋 简介  葛飾 北斎／かつしか ほくさい Katsushika Hokusai （1760年10月31日－1849年5月10日） 日本江户时代后期的浮世绘师 14岁学雕版印刷，18岁便和另一位浮世绘师胜川春章学画  评价  鲁迅  关于日本的浮世绘师，我年轻时喜欢的是北斋，现在则喜欢广重，其次则为歌麿的人物。”接着他又说，“不过依我看，适合中国人一般眼光的，恐怕还是北斋。   作品  富岳三十六景  表富士（初版） 里富士（追加）   赏析 </content>
    </entry>
    
     <entry>
        <title>语言类型</title>
        <url>http://domain.yqjdcyy.com/post/%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>编程思想</tag>
        </tags>
        <content type="html">  语言类型 参考  编译型语言、解释型语言、静态类型语言、动态类型语言概念与区别 弱类型、强类型、动态类型、静态类型语言的区别是什么？  类型 编译型语言  描述  通过编译器将源代码编译成机器码 通过链接将各模块机器码和依赖库串连运行  优点  预编译时对代码进行优化 执行效率高，可脱离语言环境独立运行  缺点  编译后修改需整个模块重新编译 需根据运行环境编译  代表  C/ C&#43;&#43;/ swift   解释型语言  描述  运行程序时逐行翻译  优点  优秀的平台兼容性（安装解释器|虚拟机）  缺点  每次运行都要解释，效率较低  代表  JavaScript/ Python   混合类型语言  描述  取编译和解释型优点而成 编译成中间码，后通过中间语言运行库运行  如 C# 中会编译成 IL代码，后保存在dll中；首次运行时由 JIT 在编译成机器码缓存在内存中，下次直接执行   代表  C#   动态语言  描述  运行时可改变代码结构  新函数、新对象、引入代码   代表  C#/ JavaScript/ Python   静态语言  描述  运行时结构不可变  代码  Java/ C/ C&#43;&#43;   静态类型语言  描述  编写代码时，需明确变量的数量类型  代表  C/ C&#43;&#43;/ C#/ Java   动态类型语言  描述  运行期间才进行数据类型检查  代表  JavaScript/ Python   强类型语言  描述  变量确定类型后将不可改变  代表  Java/ C#/ Python   弱类型语言  描述  变量可被赋予不同类型值  代表  JavaScript/ C   </content>
    </entry>
    
     <entry>
        <title>销售就是要搞定人</title>
        <url>http://domain.yqjdcyy.com/post/%E9%94%80%E5%94%AE%E5%B0%B1%E6%98%AF%E8%A6%81%E6%90%9E%E5%AE%9A%E4%BA%BA/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>商业</tag>
        </tags>
        <content type="html">  销售就是要搞定人 对自己  提升能力  解决问题  全局前提：了解局部、推荐人、相关影响人、决策人和拍板人 局部前提：搞定局部相关人员 搞定关键人前提：善于答定人&amp;amp; 敏感&amp;amp; 拉近和客户的距离  提高  魄力  胡雪岩穷得叮当响时，居然敢赞助同样落魄的王有龄。后王发迹了，也才有了胡的红顶商人神话  心态 守原则，会变通！ 多看新闻联播和地方新闻，即是方向，也是谈话资本   注意形象  用最少的时间、金钱和精力，树立起一个最为大家所尊重的悦纳的个人形象 身上一定要有抢眼的地方，比如戴表 自信！ 注意事项  绝不可弯腰驼背 绝不可让大公文包遮在身体前面   忌讳交浅言深！  话要说给懂的人听，给需要的人听 时机！  时机未到提前说，叫轻浮 应该说却不说，叫误事  地点  办公室永远要说光明正大的事 私人场所，便不必再说办公室内的套话   明哲保身的前提是了解各种情况，顺势而为，谋定后动 在任何时候都要冷静，不让表面现象牵着鼻子走，一定要看清本质才动手 人与人之间的差距在于理想。 不谋万世者，不足谋一时；不谋全局者，不足谋一域 制定目标，明确实现步骤，完善细节。而若随遇而安，运气等不确定因素来决定你命运的感觉，你愿意？  对下属  团队带领，忠心比能力重要  对同行  敌人也可以是朋友  对目标客户  先做朋友，再做生意 对手拿失败案子说事时也是销售机会，可以偿试简单介绍确有此事，然后重要介绍自己也是受害者 打开客户最有效、省钱的办法就是适宜的赞美  方法论  节奏  三个月订货为例  第一个月两个星期去一次，金钱投入一般即可 第二个月一星期去一次，适当请吃 第三个月需要天天出现   手段  初级  简单局面复杂化 落后时浑水摸鱼，乱中取胜  高级  复杂局面简单化 设置障碍，扼杀竞争对手；关键时机做表现最好的事  例  唐大诗人陈子昂学业有成后前往长安，但得不到名家的赏识。一日遇到一个卖胡琴者，有胡琴索价百万，陈子昂买了这把胡琴，邀众人至家中赏玩，竟当众摔琴。陈对大家说他只是一介书生，不懂琴艺，但会写文章，请大家欣赏他的文章。于是名动京师。   五步推销法  搜寻你的客户  了解哪些人有需求，不在无需求的人身上花费精力  接近你的客户  注意第一印象，使用幽默方式  引起客户的注意 激起客户的欲望 满足和客户的欲望  钩  客户类型  活泼型  喜欢讲 追求瞩目与喝彩，担心失去关注，反感受约束 让其多说，注意聆听，明确支持，多戴高帽  懦弱型  喜欢听 追求平稳和普遍接受，担心突然变化 不急，定目标鼓动，迫使其决定，以谈感情为主  利益型  冷静分析 追求认真准确，做事一丝不苟，担心被批评，反感盲目从事 提供严密技术方案，遵守承诺； 以干练形象示人，遵守规则  权力型  不耐烦听而打断你 追求支配地位和效率，担心被强迫、命令，反感优柔寡断 开门见山，尊重其地位，坚持多沟通多汇报    奇正相和  提炼自己的差异化，阒然于众 例  蔡泽，战国时期燕国人，博学善辩，为纵横家代表人物之一。先前游学过很多大小诸侯国，但未被人发现其才学，所以一直怀才不遇。但后来听说范雎以前推荐的郑安平和王稽都背叛了秦国，郑安平降赵，王稽与魏国私通。蔡泽曾对范雎说：“君子以义死难，视- 死如归；生而辱不如死而荣。士固有杀身以成名，虽义之所在，虽死无所恨。何为不可哉？”所以前往秦国游说范雎让贤于他，因为秦国有一条法律：“凡荐人不效者，与所荐之人同罪。”虽然秦昭王不加怪罪，但范雎心中已有畏惧。从而使蔡泽说服范雎成功而成为丞相。   解决问题首先是战略上的，是对规律的掌握，然后才是技巧上的，最后才是心态、细节上的 试错，总结原因  故事  资本论  如果有百分之二十的利润，资本就会蠢蠢欲动； 如果有百分之五十的利润，资本就会冒险； 如果有百分之一百的利润，资本就敢于冒绞首的危险； 如果有百分之三百的利润，资本就敢于践踏人间一切法律。  同样销售阀门，有的一年销售额达到300万就沾沾自喜，但我知道2007年有个销售高手一个订单是2.3亿  </content>
    </entry>
    
     <entry>
        <title>面</title>
        <url>http://domain.yqjdcyy.com/post/%E9%9D%A2/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  面食 西红柿鸡蛋面 [3&amp;frasl;5] 材料  鸡蛋 西红柿 小葱  流程  鸡蛋炒开 西红柿去皮压碎后与鸡蛋拌炒 4&amp;frasl;5 碗水，大拇指至食指末节数量挂面 焖煮9分钟，加盐、香油等出锅  阳春面 拌面 炒米粉 [3&amp;frasl;5] 材料  米粉 豆芽、青菜丝 肉丝、淀粉 鸡蛋 葱、姜、蒜 盐、生抽、老抽、料酒、香醋、胡椒粉  流程  豆芽去根，青菜切丝，葱切段， 蒜剁碎 米粉过水，待米粉可挑散后 冲凉水两遍，后沥干 瘦肉切丝，加生姜、生抽、老抽、料酒、香醋和淀粉腌制 10分钟 鸡蛋加料酒和盐打散，爆香蒜碎后炒散鸡蛋 后加入肉丝，翻炒至变色后加入米粉 翻炒时加入适量生抽上色 上色均匀后加入豆芽和葱段，并于完成时加入胡椒粉  番茄火腿芝士意面 材料  意面 小番茄* 20 火腿片 洋葱/ 2 橄榄油、盐、糖、芝士、番茄酱* 3勺  流程  小番茄对切，火腿、芝士切块，洋葱切丝 挑锅倒足水，开火煮沸倒入2ML盐后下意面，后转中火保持水沸腾即可，待达到包装建议时间后捞出拌以适量橄榄油 热锅热油，加洋葱丝爆香后加入火腿片、小番茄以中火翻炒至断生 加番茄酱、适量水和意面翻炒 放入芝士片、盐、糖调味后拌匀收汁即可  注意事项  锅与面匹配，尽量让面可上下扑腾 面入水后静待其软化而自动滑入锅中，勿蛮压、搅 严格按照包装袋建议时间，吃软多焖2分钟，若还需于配料中加热，建议提前2分钟  油泼面 材料  面条 辣椒面 蒜、姜、葱 青菜、豆芽 盐、酱油、油、香醋
流程 蒜、姜、葱切末备用
 豆芽焯水至断生后捞出过冷水，控干后铺于碗底；焯青菜
 面条煮软后，控干码于豆芽上，并码盐、蒜、姜、葱末和辣椒面
 热锅热油至七成后，泼至面上，并倒2汤匙醋、些许酱油
 最后码上青菜即可享用
注意事项 油温
 2成热  油变化不大，手置于油锅表面，感觉微热 适合炒料  5成热  开始变化明显，筷子于油中时，有微小气泡 适合滑炒肉片  7成热  筷子上气泡密集，伴有青烟 适合炝锅、爆香料和炒菜  8成热  气泡密集，油烟明显 适合油炸、煎肉、鱼    </content>
    </entry>
    
     <entry>
        <title>饭</title>
        <url>http://domain.yqjdcyy.com/post/%E9%A5%AD/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>饮食</tag>
        </tags>
        <content type="html">  煮干饭 材料  米饭  两人三小碗左右   流程  淘米后加同杯量的水  什蔬咖喱炒饭 材料  米饭 西兰花、胡萝卜、玉米、青豆 圣女果 咖喱块、盐  流程  西兰花切块，胡萝卜切丁，青豆和玉米剥粒，圣女果对切 蔬菜焯水选用 咖喱加油小火炒香后，加入米饭炒匀 加入所有材料炒匀，加盐调味  排骨焖饭 [4.5&amp;frasl;5] 材料  米 肋排 香菇 胡萝卜 葱、姜、蒜 熏制、老抽、耗油、冰糖  过程  排骨切块，香菇、胡萝卜切丁，姜切丝蒜拍扁，葱切段，米洗净 排骨过开水去除血水，捞出后加入料酒、生抽、姜丝腌20分钟 热锅少油煎排骨至两面金黄0 加入姜丝、葱段、蒜、冰糖、生抽，并辅以老抽上色 加入香菇、胡萝卜、耗油和盐（量较炒菜多）翻炒 米加入等量水，加入材料拌匀后开始煮  腊肠菜饭 材料  米 腊肠 胡萝卜、青豆、水发香菇 麻油、盐、鸡精  流程  香菇洗净泡温水半小时，青豆洗净，胡萝卜、腊肠切丁，米饭洗净 热锅麻油，香菇与腊肠干煎2分钟 放入青豆、胡萝卜、盐、鸡精翻炒均匀后，拌入等量的水和米 煮饭完成后，拌匀后再焖5分钟  </content>
    </entry>
    
     <entry>
        <title>香水.推荐</title>
        <url>http://domain.yqjdcyy.com/post/%E9%A6%99%E6%B0%B4.%E6%8E%A8%E8%8D%90/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>香水</tag>
        </tags>
        <content type="html">  男香分享 推荐 Dolce &amp;amp; Gabbana the one 浓香版   [香调]东方辛香调 [前调]罗勒 葡萄柚 胡荽 [中调]小豆蔻 姜 橙花 [后调]烟草调 雪松木 龙涎香 时效性:一整天 推荐季节:秋/冬 推荐场合:商务 非常适合商务人士或成熟男性 ★★★★☆ | ★★★★★  ACQUA DI PARMA Colonia   [香调]柑橘香调 [前调]柠檬 甜橙 佛手柑 [中调]薰衣草 玫瑰 伊兰 [后调]广藿香 香根草 雪松 檀木 时效性:半天 推荐季节:春/夏 推荐场合:休闲 主打年轻与活力 ★★★★☆ | ★★★★☆  Juicy Couture Dirty English   [香调]性感木质调 [前调]胡椒 蓝色丝柏 卡拉布里亚佛手柑 小茴香 小豆蔻 [中调]马郁兰 皮革味 白檀 北非雪松 香根草 [后调]沉香木 黑檀木 黑色苔藓 琥珀 麝香 时效性:一天 推荐季节:春/夏/秋/冬 推荐场合:商务/休闲 香味易接受，季节、场合百搭 ★★★★☆ | ★★★★☆  Tom Ford Tobacco Vanille   [香调]辛辣东方调 [前调]烟草 辛香料 [中调]顿加豆 烟草花 香草 可可果 [后调]干果 木质香 时效性:一天 推荐季节:春/秋/冬 推荐场合:商务/休闲 评价满分 ★★★★★ | ★★★★★  Dsquared2 D2 He Wood   [香调]清新木质琥珀调 [前调]柑橘 佛手柑 [中调]海洋调 香菜 皮革 [后调]桃木 檀香 阿根廷草本植物 琥珀 时效性:半天 推荐季节:春/夏/秋/冬 推荐场合:商务/休闲 ★★★★☆ | ★★★★☆  Acqua di Parma Colonia Oud   [香调]木质调 [前调]柑橘 [中调]沉香 芜荽 海地乌木 [后调]皮革 麝香 时效性:一天 推荐季节:春/秋/冬 推荐场合:商务/休闲 夏天不推荐，年轻人不推荐 ★★★★☆ | ★★★★☆  Hermes Terre d&amp;rsquo;Hermes Eau Tres Fraiche   [香调]清新木质调 [前调]柑橘 橙子 水因子 [中调]老鹤草 [后调]木质元素 广蒮香 雪松 时效性:一天 推荐季节:春/夏/秋 推荐场合:商务/休闲 类比大地，更推荐 ★★★★★ | ★★★★☆  Bvlgari Man in Black   [香调]木质香调 [前调]朗姆酒 [中调]晚香玉 鸢尾纯香 皮革 [后调]安息香 零陵香豆 愈创木 时效性:半天 推荐季节:秋/冬 推荐场合:商务 成熟男人 ★★★★☆ | ★★★★☆  </content>
    </entry>
    
     <entry>
        <title>ActiveMq</title>
        <url>http://domain.yqjdcyy.com/post/activemq/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>ActiveMq</tag>
        </tags>
        <content type="html">  地址  入门：http://www.cnblogs.com/xwdreamer/archive/2012/02/21/2360818.html 下载：http://activemq.apache.org/download-archives.html  运行  解压至 D:\server\activemq\apache-activemq-5.9.1  注：D:\Program Files 等路径上存在空格等的不适合当其路径，会影响项目正常启动  点击 /bin/activemq.bat 启动 ActiveMQ 程序 进入 http://localhost:8161/admin/ ，并输入账号/密码 admin/admin 创建一个名为 FirstQueue 的 Queue 运行代码（如下）  代码 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;activemq-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.5.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 模式 - Queue 发送 public class Sender { private static final int SEND_NUMBER = 5; public static void main(String[] args) { ConnectionFactory connectionFactory; Connection connection = null; Session session; Destination destination; MessageProducer producer; connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, &amp;#34;tcp://localhost:61616&amp;#34;); try { connection = cfile:/D:/WorkSpace/work4IDEA/HelloWorld4Maven/SpringMvc/src/main/java/com/yao/springmvc/activeMq/hello/Receiver.java file:/D:/WorkSpace/work4IDEA/HelloWorld4Maven/SpringMvc/src/main/java/com/yao/springmvc/activeMq/hello/Sender.javaonnectionFactory.createConnection(); connection.start(); session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);queue是一个服务器的queue，须在在ActiveMq的console配置 destination = session.createQueue(&amp;#34;FirstQueue&amp;#34;); producer = session.createProducer(destination); producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); sendMessage(session, producer); session.commit(); } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != connection) connection.close(); } catch (Throwable ignore) { } } } public static void sendMessage(Session session, MessageProducer producer) throws Exception { for (int i = 1; i &amp;lt;= SEND_NUMBER; i&#43;&#43;) { TextMessage message = session .createTextMessage(&amp;#34;ActiveMq 发送的消息&amp;#34; &#43; i); System.out.println(&amp;#34;发送消息：&amp;#34; &#43; &amp;#34;ActiveMq 发送的消息&amp;#34; &#43; i); producer.send(message); } } } 接收 public class Receiver { public static void main(String[] args) { ConnectionFactory connectionFactory; Connection connection = null; Session session; Destination destination; MessageConsumer consumer; connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, &amp;#34;tcp://localhost:61616&amp;#34;); try { connection = connectionFactory.createConnection(); connection.start(); session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE) destination = session.createQueue(&amp;#34;FirstQueue&amp;#34;); consumer = session.createConsumer(destination); while (true) { TextMessage message = (TextMessage) consumer.receive(100000); if (null != message) { System.out.println(&amp;#34;收到消息&amp;#34; &#43; message.getText()); } else { break; } } } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != connection) connection.close(); } catch (Throwable ignore) { } } } } 模式 - Topic 发送 public class Sender { public static void main(String[] args) throws JMSException { ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&amp;#34;tcp://localhost:61616&amp;#34;); Connection connection = factory.createConnection(); connection.start(); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Topic topic = session.createTopic(&amp;#34;myTopic.messages&amp;#34;); MessageProducer producer = session.createProducer(topic); producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); for(int i =0;i&amp;lt;10;i&#43;&#43;){ TextMessage message = session.createTextMessage(); message.setText(&amp;#34;message_&amp;#34; &#43; System.currentTimeMillis()); producer.send(message); System.out.println(&amp;#34;Sent message: &amp;#34; &#43; message.getText()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } producer.close(); connection.close(); } } 接收 public class Receiver { public static void main(String[] args) { ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&amp;#34;tcp://localhost:61616&amp;#34;); try { Connection connection = factory.createConnection(); connection.start(); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Topic topic = session.createTopic(&amp;#34;myTopic.messages&amp;#34;); MessageConsumer consumer = session.createConsumer(topic); consumer.setMessageListener(new MessageListener() { public void onMessage(Message message) { TextMessage tm = (TextMessage) message; try { System.out.println(&amp;#34;Received message: &amp;#34; &#43; tm.getText()); } catch (JMSException e) { e.printStackTrace(); } } }); } catch (JMSException e) { e.printStackTrace(); } } } 处理机制对比 Queue  概要：Point-to-Point 点对点 有无：Queue数据默认会在mq服务器上以文件形式保存，比如Active MQ一般保存在$AMQ_HOME\data\kr-store\data下面。也可以配置成DB存储。 - 故在发送前需要先在 ActiveMq/admin 上进行 Queue 的注册 完整：Queue保证每条数据都能被receiver接收。 丢失：Sender发送消息到目标Queue，receiver可以异步接收这个Queue上的消息。Queue上的消息如果暂时没有receiver来取，也不会丢失。 发收：一对一的消息发布接收策略，一个sender发送的消息，只能有一个receiver接收。receiver接收完后，通知mq服务器已接收，mq服务器对queue里的消息采取删除或其他操作。 效率：无明显变差情况
Topic 概要：Publish Subscribe messaging 发布订阅消息
 有无：topic数据默认不落地，是无状态的。
 完整：并不保证publisher发布的每条数据，Subscriber都能接受到。
 丢失：一般来说publisher发布消息到某一个topic时，只有正在监听该topic地址的sub能够接收到消息；如果没有sub在监听，该topic就丢失了。
 发收：一对多的消息发布接收策略，监听同一个topic地址的多个sub都能收到publisher发送的消息。Sub接收完通知mq服务器。
 效率：随监听客户端的并发增加出现明显下降
  常用模式 同时发送多处 发送 Destination destination = session.createQueue(&amp;#34;test-queue,test-queue-foo,test-queue-bar,topic://test-topic-foo&amp;#34;); 接收 Destination destination = session.createQueue(&amp;#34;test-queue&amp;#34;); Destination destinationFoo = session.createQueue(&amp;#34;test-queue-foo&amp;#34;); Destination destinationBar = session.createQueue(&amp;#34;test-queue-bar&amp;#34;); Destination destinationTopicFoo = session.createTopic(&amp;#34;test-topic-foo&amp;#34;); MessageConsumer consumer = session.createConsumer(destination); MessageConsumer consumerFoo = session.createConsumer(destinationFoo); MessageConsumer consumerBar = session.createConsumer(destinationBar); MessageConsumer consumerTopicFoo = session.createConsumer(destinationTopicFoo); 指定处理指定数量数据 接收 final CountDownLatch latch = new CountDownLatch(1); consumer.setMessageListener(new Subscriber(latch)); latch.await(); @Override public void onMessage(Message message) { try { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); if (&amp;#34;END&amp;#34;.equalsIgnoreCase(text)) { System.out.println(&amp;#34;Received END message!&amp;#34;); countDownLatch.countDown(); } else { System.out.println(&amp;#34;Received message:&amp;#34; &#43;text); } } } catch (JMSException e) { System.out.println(&amp;#34;Got a JMS Exception!&amp;#34;); } } 独占消费 接收 Queue destination = session.createQueue(&amp;#34;test-queue?consumer.exclusive=true&amp;#34;); 特点  当在接收信息的时候有一个或者多个备份接收消息者和一个独占消息者的同时接收时候，无论两者创建先后，在接收的时候，均为独占消息者接收。 当在接收信息的时候，有多个独占消费者的时候，只有一个独占消费者可以接收到消息。 当有多个备份消息者和多个独占消费者的时候，当所有的独占消费者均close的时候，只有一个备份消费者接到到消息。  备注：备份消费者为不带任何参数的消费者。   消息查看 接收 QueueBrowser browser = session.createBrowser(destination); Enumeration enumeration = browser.getEnumeration(); while (enumeration.hasMoreElements()) { TextMessage message = (TextMessage) enumeration.nextElement(); System.out.println(&amp;#34;Browsing: &amp;#34; &#43; message); TimeUnit.MILLISECONDS.sleep(DELAY); } 特点  对于mq队列中的消息，有时候需要做监控或者问题跟踪要看看mq的数据，又要保证看后数据不会删除  消息过滤 发送 TextMessage message = session.createTextMessage(&amp;#34;Message #&amp;#34; &#43; i); if (i % 2 == 0) { message.setStringProperty(&amp;#34;intended&amp;#34;, &amp;#34;me&amp;#34;); } else { message.setStringProperty(&amp;#34;intended&amp;#34;, &amp;#34;you&amp;#34;); } producer.send(message); 接收 MessageConsumer consumer = session.createConsumer(destination, &amp;#34;intended = &amp;#39;me&amp;#39;&amp;#34;); Message message = consumer.receive(TIMEOUT); 消息事务处理 发送 sender.send(senderSession.createTextMessage(&amp;#34;create new message&amp;#34;)); senderSession.commit(); //提交 send 的数据 senderSession.rollback(); //回退本次 send 的数据 通配符接收 接收 String policyType = System.getProperty(&amp;#34;wildcard&amp;#34;, &amp;#34;.*&amp;#34;); String receiverTopicName = senderTopic.getTopicName() &#43; policyType; Topic receiverTopic = receiverSession.createTopic(receiverTopicName); 注 `.` 用于分隔名称中的路径 `*` 用于在路径匹配的名称 `&amp;gt;` 用于递归匹配从这个名字起的任何目的地 临时通道 estination replyDest = session.createTemporaryQueue(); 接收 MessageConsumer replyConsumer = session.createConsumer(replyDest); replyConsumer.setMessageListener(new MessageListener() { @Override public void onMessage(Message message) { System.out.println(&amp;#34;*** REPLY *** &amp;#34;); System.out.println(message.toString()); } }); 发送 TextMessage message = session.createTextMessage(&amp;#34;I need a response for this, please&amp;#34;); message.setJMSReplyTo(replyDest); producer.send(message); 基础概念 工作类  ConnectionFactory ：连接工厂，JMS 用它创建连接 Connection ：JMS 客户端到JMS Provider 的连接 Destination ：消息的目的地 Session： 一个发送或接收消息的线程 MessageConsumer： 由Session 对象创建的用来接收消息的对象
消息格式 StreamMessage &amp;ndash; Java原始值的数据流
 MapMessage&amp;ndash;一套名称-值对
 TextMessage&amp;ndash;一个字符串对象
 ObjectMessage&amp;ndash;一个序列化的 Java对象
 BytesMessage&amp;ndash;一个未解释字节的数据流
消息确认模式 非事务性会话中，应用程序创建的会话有5 种确认模式,而在事务性会话中，确认模式被忽略。 确认模式: ♣ AUTO_ACKNOWLEDGE：自动确认模式。一旦接收方应用程序的方法调用从处理消息处返回，会话对象就会确认消息的接收。
 ♣ CLIENT_ACKNOWLEDGE：客户端确认模式。会话对象依赖于应用程序对被接收的消息调用一个acknowledge()方法。一旦这个方法被调用，会话会确认最后一次确认之后所有接收到的消息。这种模式允许应用程序以一个调用来接收，处理并确认一批消息。注意：在管理控制台中，如果连接工厂的Acknowledge Policy（确认方针）属性被设置为&amp;rdquo;Previous&amp;rdquo;（提前），但是你希望为一个给定的会话确认所有接收到的消息，那么就用最后一条消息来调用acknowledge()方法。
 ♣ DUPS_OK_ACKNOWLEDGE：允许副本的确认模式。一旦接收方应用程序的方法调用从处理消息处返回，会话对象就会确认消息的接收；而且允许重复确认。在需要考虑资源使用时，这种模式非常有效。注意：如果你的应用程序无法处理重复的消息的话，你应该避免使用这种模式。如果发送消息的初始化尝试失败，那么重复的消息可以被重新发送。
 ♣ NO_ACKNOWLEDGE：不确认模式。不确认收到的消息是需要的。消息发送给一个NO_ACKNOWLEDGE 会话后，它们会被WebLogic 服务器立即删除。在这种模式下，将无法重新获得已接收的消息，而且可能导致下面的结果：1. 消息可能丢失；和（或者）另一种情况：2. 如果发送消息的初始化尝试失败，会出现重复消息被发送的情况。
 ♣ MULTICAST_NO_ACKNOWLEDGE：IP组播下的不确认模式，同样无需确认。发送给一个MULTICAST_NO_ACKNOWLEDGE会话的消息， 会共享之前所述的NO_ACKNOWLEDGE 确认模式一样的特征。这种模式支持希望通过IP 组播方式进行消息通信的应用程序，而且无需依赖会话确认提供的服务质量。注意：如果你的应用程序无法处理消息的丢失或者重复，那么你应该避免使用这种模式。如果发送消息的初始化尝试失败的话，重复的消息可能会被再次发送。
  </content>
    </entry>
    
     <entry>
        <title>CSS4.Color</title>
        <url>http://domain.yqjdcyy.com/post/css4.color/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>CSS4</tag>
        </tags>
        <content type="html">  [TOC]
CSS4.Colors Tutorial Color Format  RGB(255, 0, 0) #FF0000 HSL(0, 100%, 50%) RED 140 standard color names http://www.w3schools.com/colors/colors_names.asp HWB(0, 0%, 0%) sugguest in css4 hue&#43; white&#43; black white&#43;black&amp;lt;= 100 CMYK(0%, 100%, 100%, 0%) cyan/ magenta/ yellow/ black suggest in css4, not supported in html R0, 0%, 0% close to HWB natural color(NCol) from W3Schools [R|G|B|Y|C|M][\d]0, white%, black% white&#43; black&amp;lt;= 100  Color type  shades of gray r= g= b | #080808 shades of red r=[0-255], g= b= 0 web safe color = 216  CSS3.Color Color Format  RGBA(255, 0, 0, 0.8) red, green, blue, opacity=[0-1] HSL(0, 100%, 50%) hue&#43; saturation&#43; lightness hue: {0/360= red, 120= green, 240= blue} HSLA(0, 100%, 50%, 1.0) HSL&#43; alpha[0.0-1.0]  </content>
    </entry>
    
     <entry>
        <title>Go.Wukong</title>
        <url>http://domain.yqjdcyy.com/post/go.wukong/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  悟空引擎使用 参考  使用wukong全文搜索引擎 huichen/wukong 悟空：用Go语言编写的全文搜索引擎 huichen/sego boltdb/bolt cznic/kv huichen/murmur  介绍 内部结构  主协程，用于收发用户请求 分词器（segmenter）协程，负责分词 索引器（indexer）协程，负责建立和查找索引表 排序器（ranker）协程，负责对文档评分排序  流程 索引  文档加入索引请求 主协程通过 channel 将分要分词的文本发送给分词协程 该协程将文本分词后通过另一信道发送给索引器协程 索引器协程建立从搜索键到文档的反向索引，并保存在内存中  搜索  主协程获取用户搜索请求，将搜索词分词后通过信道传递给索引器 索引器查找每个搜索键对应文档，并进行逻辑归并求交集后，得到精简文档列表，并通过信道传递给排序器 排序器对文档进行评分、筛选和排序，并通过指定信道返回主协程以返回给用户  结构  core data docs engine example storate testdata types utils  使用  基本
searcher = engine.Engine{} searcher.Init(types.EngineInitOptions{ IndexerInitOptions: &amp;amp;types.IndexerInitOptions{ IndexType: types.DocIdsIndex, }, SegmenterDictionaries: &amp;#34;./dict/dictionary.txt&amp;#34;, StopTokenFile: &amp;#34;./dict/stop_tokens.txt&amp;#34;, }) defer searcher.Close() searcher.IndexDocument(docId, types.DocumentIndexData{Content: text1}, false) searcher.FlushIndex() fmt.Printf(&amp;#34;%#v\n&amp;#34;, searcher.Search(types.SearchRequest{Text: &amp;#34;巴萨 梅西&amp;#34;})) 序列类型
 FrequenciesIndex  保留词频 types.SearchResponse{Tokens:[]string{&amp;quot;巴萨&amp;quot;, &amp;quot;梅西&amp;quot;}, Docs:[]types.ScoredDocument{types.ScoredDocument{DocId:0x1, Scores:[]float32{3.0480049}, TokenSnippetLocations:[]int(nil), TokenLocations:[][]int(nil)}}, Timeout:false, NumDocs:1}  LocationsIndex  保留关键字在文档中出现的位置信息 types.SearchResponse{Tokens:[]string{&amp;quot;巴萨&amp;quot;, &amp;quot;梅西&amp;quot;}, Docs:[]types.ScoredDocument{types.ScoredDocument{DocId:0x1, Scores:[]float32{3.0480049}, TokenSnippetLocations:[]int{37, 76}, TokenLocations:[][]int{[]int{37}, []int{76}}}}, Timeout:false, NumDocs:1}   分词
 中文分词基于 sego 项目实现 分词准确度影响索引建立和关键词搜索，建议定期更新网络库  持久化索引&#43;启动恢复
 文档索引存放在内存中 持久化方式  boltdb  默认 An embedded key/value database for Go.  cznic/kv  Package kv implements a simple and easy to use persistent key/value (KV) store.   示例  searcher.Init(types.EngineInitOptions{ IndexerInitOptions: &amp;amp;types.IndexerInitOptions{ IndexType: types.DocIdsIndex, }, UsePersistentStorage: true, PersistentStorageFolder: &amp;quot;./index&amp;quot;, SegmenterDictionaries: &amp;quot;./dict/dictionary.txt&amp;quot;, StopTokenFile: &amp;quot;./dict/stop_tokens.txt&amp;quot;, }) // ＊ searcher.FlushIndex()   分布式
 按文本内容 hash 值理解试用分至不同服务器索引 请求时分发至所有裂分服务器，后将所有服务器返回结果归并排序后输出 使用 Murmur3 hash 来保证裂分均匀性   局限  作者个人项目，资料少，开发不活跃 缺少开发计划和愿景 查询功能简单，仅支持关键词的 AND 操作 缺少将索引存储于 DB 的操作支持  </content>
    </entry>
    
     <entry>
        <title>Hugo 建站</title>
        <url>http://domain.yqjdcyy.com/post/hugo%E5%BB%BA%E7%AB%99/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag><tag>Hugo</tag>
        </tags>
        <content type="html">  Hugo 建站 参考  使用Hugo搭建个人博客 Hugo Themes Hugo 中文文档 利用Github Pages和基于Go的Hugo搭建个人博客 Host on GitHub 使用hugo搭建个人博客站点 github Pages和Jekyll入门 3.5. 建立主页  安装  下载  gohugoio/hugo  安装  tar xvf hugo_0.15_linux_amd64.tar.gz -C /data/soft/hugo   生成  /data/soft/hugo/hugo new site /data/service/domain  archetypes config.toml  整体配置  content  文章  data layouts static themes  主题    安装主题  仅需将主题下载至 themes 文件下，并更 config.toml 中的 theme 为主题名称  下载  git clone https://github.com/yoshiharuyamashita/blackburn.git /data/service/domain/themes/blackburn hugo-minimalist-theme  更新配置  vim config.toml  theme = &amp;quot;hugo-minimalist-theme&amp;quot;  注：其它相关配置详见各主题项目的 README.md 文件    发布  /data/soft/hugo/hugo  hugo 将配置和文件转换为静态文件发布到本地目录 public 下   启动 Hugo  cd /data/service/domain /data/soft/hugo/hugo server --baseURL=http://www.yqjdcyy.com/ --port=80 --appendPort=false --bind=0.0.0.0  Nginx server { listen 80; server_name 你的域名; index index.html; root /home/www/public; #这里配置指向根目录 } github-page  将打包文件夹提交至 gh-pages 分支，作为项目首页  git subtree push --prefix=public git@github.com:wrrwhn/domain.git gh-pages   域名指向 - `vim CNAME` - `www.yqjdcyy.com` - 域名指向 - 顶级域名 - A.yqjdcyy.com -&amp;gt; 204.232.175.78 - 二级域名 - domain.yqjdcyy.com -&amp;gt; 204.232.175.78 - 配置更新 - baseUrl -&amp;gt; &amp;#34;/&amp;#34;</content>
    </entry>
    
     <entry>
        <title>Java.Log4j</title>
        <url>http://domain.yqjdcyy.com/post/java.log4j/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  文件格式 配置根Logger  log4j.rootLogger = [ level ] , appenderName1 , appenderName2 , …  配置日志信息输出目的地 log4j.appender.appenderName = Appender log4j.appender.appenderName. Threshold= DEBUG ##输出DEBUG级别以上的日志 … log4j.appender.appenderName.optionN = valueN 配置日志信息的格式（布局） log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.ConversionPattern = value1 … log4j.appender.appenderName.layout.optionN = valueN 参数 [ level ] - 日志输出级别  FATAL[0] ERROR[3] WARN[4] INFO[6] DEBUG[7]  Appender - 日志输出目的地  org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）  Layout - 日志输出格式  org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）  ConversionPattern - 打印参数  %m 输出代码中指定的消息 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，亦指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 22 :10:28 ， 921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )  </content>
    </entry>
    
     <entry>
        <title>Java.注意事项</title>
        <url>http://domain.yqjdcyy.com/post/java.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  finally  用于及时释放资源以不影响系统性能，并遵循最晚申请，最早释放原则，就近释放（若在A类一方法中申请到某个资源，应该就在这个方法的末尾将资源释放掉）。  preparedStatement  预编译语句，继承自Statement，用于处理大业务量的数据库操作 正确方法  PreparedStatement ps = con.prepareStatement(&amp;quot;select * from student where stuNo=?&amp;quot;); //!! for(int i=0; i&amp;lt; 1000; i&#43;&#43;){ ps.setString(1, &amp;quot;1000&amp;quot;); ResultSet rs = ps.executeQuery(); rs.close(); } ps.close(); //!! //PreparedStatement效率高，但代价是建立在创建对象时付出较大的成本，但是创建后可以通过传入不同的参数重复高效的使用  注意事项  在高频率反复执行同一类业务量的数据处理任务时使用   连接池  为服务器配置连接池，而在配置文件中指定所要连接的数据库和连接个数，便于服务器启动时，首先连接目标数据库创建指定个数的活动连接，并将其放到连接池中。 优点  不同的访问者共享有限的连接，免去了数据库连结的漫长创建过程  类似使用  在线程管理中，为避免线程资源的浪费和提高效率，也可以采用线程池来进行线程的管理   内存管理 引用类型 弱引用  定义  当被弱引用指向的对象除该弱引用之外不再有其他的引用指向这个对象，这个对象即为“弱引用”  回收标准  检查到该弱引用指向的对象，就会将其回收  支持对象  WeakRefrence：弱引用对象 WeakHashMap：专用于管理弱引用集合，消除由于HashMap不释放导致对象数据长期残留于内存的情况
  事例  Sample sam = new Sample(); WeakReference wr = new WeakReference(sam); //定义弱引用并指向创建的对象 sam = null; //使对象变成了垃圾 ((sam)wr.get()).shout(); //验证对象是否还存在 System.gc(); //执行垃圾收集 try{ Thread.sleep(80); //主线程休眠，垃圾回收器运行 }catch(Exception e){ e.printStackTrace(); }  用途
 用于防止内存泄露
软引用  定义
 当被软引用指向的对象除软引用外部存在其他的引用指向这个对象，这个对象即为“软引用”  回收标准
 在内存即将耗尽的情况下，垃圾收集器在抛出异常之前尝试回收软引用指向对象的内存  支持对象
 SoftRefrence  事例
Sample sam = new Sample(); SoftRefrence sr = new SoftRefrence(sam); //定义弱引用并指向创建的对象 sam = null; //使对象变成了垃圾 ((sam)sr.get()).shout(); //验证对象是否还存在 System.gc(); //执行垃圾收集 try{ Thread.sleep(80); //主线程休眠，垃圾回收器运行 }catch(Exception e){ e.printStackTrace(); } 用途
 作为缓冲区   幻影引用  定义  所指向的对象和一般的垃圾对象一样会被回收，并不能延长存活时间  特点  必须和一个ReferenceQueue类一起使用。当一个被幻影引用指向的对象被垃圾收集器检测到需要回收时，垃圾收集器会将其挂到ReferenceQueue队列中，以起到消息传递的作用，并使对象内存在被回收前执行指定的pre-mortem操作
   小肥猪问题  一般出现在企业级服务器程序中，这些服务程序在起到的时候会创建一些对象，而这些对象在服务器运行中会产生新的对象。这些新产生的子对象如果没有及时在用完之后释放掉，就会衣服在创建它们的对象上，而这些对象便是“小肥猪”  String  对String对象使用&#43;，实质上创建很多无用的中间对象，增加了系统的开销。 推荐方法  StringBuffer.append(&amp;ldquo;..&amp;rdquo;); StringBuilder   </content>
    </entry>
    
     <entry>
        <title>JavaScript.TypeScript</title>
        <url>http://domain.yqjdcyy.com/post/javascript.typescript/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>TypeScript</tag>
        </tags>
        <content type="html">  TypeScript 参考  Wiki - TypeScript TypeScript Handbook（中文版） 官网 Microsoft/TypeScript 5分钟上手TypeScript 深入浅出ES6（八）：Symbols  简介  微软开发、开源的编程语言，为 JavaScript 的严格超集 添加可选的静态类型和基于类的面向对象编程 安德斯·海尔斯伯格参与设计  安装&amp;amp;使用  安装  npm install -g typescript  创建 hello.ts  function hello(user: string){ return &amp;quot;Hello&amp;quot;&#43; user; } var user = &amp;quot;yao&amp;quot; document.body.innerHTML= hello(user)  编译  tsc hello.ts   扩展 基础类型  类型  number bool string Tuple  let x: [string, number]  enum  enum Color {Red, Green, Blue}  any  默认动态类型  void null undefined never  总是抛出异常或根本不会返回值的函数表达式 箭头函数表达式的返回值类型   示例  function Add(left: number, right: number): number { return left &#43; right; }  细节  类型批注被导出到声明文件，便于 javascript 和 TypeScript 脚本中类型信息均可使用 类型断言  清楚确切的类型时，通知编译器进行类型转换，而不进行特殊数据检查和解构 写法  let len: number = (&amp;lt;String&amp;gt;val).length; let len: number = (val as string).length;     类型推断  编译期自动推导出值的数据类型  变量声明  var
function f() { var a = 1; a = 2; var b = g(); a = 3; return b; function g() { return a; } } f(); // returns 2 for (var i = 0; i &amp;lt; 10; i&#43;&#43;) { setTimeout(function() { console.log(i); }, 100 * i); } 10* 10 // 每当g被调用时，它都可以访问到f里的a变量。 let
 块作用域 重定义与屏蔽  const
 与 let 相同的作用域规则 不能重新赋值   接口 - - class class iplements interface - interface interface1 extends interface2 - interface interface extends class
 示例
interface LabelledValue { label: string; age?: number // 可选属性 readonly val: number // 只读属性 (source: string, subString: string): boolean; // 参数名无需匹配，仅要求各位置参数类型匹配 } let myObj = {size: 10, label: &amp;#34;Size 10 Object&amp;#34;};  类  继承 修饰符  public  默认  private  仅在声明类中可用  protected  派生类中仍可使用  readonly static  抽象类  abstract  构造函数  关键词： constructor  class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } }    函数 泛型 function identity&amp;lt;T&amp;gt;(arg: T): T { return arg; } 类型推论  根据最佳通用 根据上下文类型  类型兼容性  条件(A= B)  对象  B 至少含有 A 中所有属性  函数  B 中必需参数类型 A 中均有满足 允许忽略参数  枚举  不同枚举类型之间不兼容  类  仅比较实例成员，静态成员和构造函数不比较 私有成员仅可来源于同类的对象的私有成员  泛型  仅定义结构使用类型参数时相同，都可理解为 any 当定义泛型类型成员时，则会限制    高级类型  交叉类型  function extend( first: T, second: U): T &amp;amp; U { &amp;hellip; }  联合类型-  function padLeft(value: string, padding: string | number) { &amp;hellip; }  类型保护与类型区分  if((pet).swim) typeof x=== &amp;ldquo;number&amp;rdquo; x instanceof number  可辨识联合  联合类型 &#43; 属性可辨识 &#43; 类型保护  function area(s: Shape) { // 类型保护 type Shape = Square | Rectangle | Circle; // 联合类型 interface Square { kind: &amp;quot;square&amp;quot;; size: number;} // 属性可辨识，各类中均有同一属性    Symbols  新原生类型  ECMAScript 2015 版本产生 唯一且不可改变，理解有点像 UUID 用来定义唯一值 创建  Symbol() Symbol.for(string) Symbol.iterator    迭代器和生成器  for (let entry of someArray)  迭代对象键对应值  for (let i in list)  迭代对象的键列表  let list = [4, 5, 6]; for (let i in list) console.log(i); // &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, for (let i of list) console.log(i); // &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;    模块  默认&amp;amp;推荐 for Node.js 应用 导出  export class ZipCodeValidator implements StringValidator export const numberRegexp export { ZipCodeValidator as mainValidator }; export * from &amp;ldquo;./StringValidator&amp;rdquo;; export default $; // 默认导出名称  导入  import { ZipCodeValidator } from &amp;ldquo;./ZipCodeValidator&amp;rdquo;; import { ZipCodeValidator as ZCV } from &amp;ldquo;./ZipCodeValidator&amp;rdquo;; import * as validator from &amp;ldquo;./ZipCodeValidator&amp;rdquo;;   命名空间  定义  位于全局命名空间下的普通带名字的 JavaScript 对象 可在多文件同时使用，通过 --outFile 结合   命名空间和模块 // 不推荐，不应该对模块使用命名空间 export namespace Shapes { export class Triangle { /* ... */ } } import * as shapes from &amp;#34;./shapes&amp;#34;; let t = new `shapes.Shapes`.Triangle(); // 推荐 export class Triangle { /* ... */ } import * as shapes from &amp;#34;./shapes&amp;#34;; let t = new shapes.Triangle(); 模块解析  顺序  优先尝试定位导入模块的文件  Classic 策略 Node 策略  无果时尝试外部模块声明  方式  相对  以 /, ./, ../ 开头 import Entry from &amp;quot;./components/Entry&amp;quot;; import { DefaultHeaders } from &amp;quot;../constants/http&amp;quot;; import &amp;quot;/mod&amp;quot;;  非相对  import * as $ from &amp;quot;jQuery&amp;quot;;   策略  介绍  使用 --moduleResolution 指定策略 使用 --module AMD | System | ES2015 默认为 Classic，其它情况为 Node  分类  Classic  TypeScript 默认解析策略，存在主要为了向后兼容 相对导入  /root/src/folder/A.ts 中使用引用  引用 import { b } from &amp;quot;./moduleB&amp;quot; 查找  /root/src/folder/moduleB.ts /root/src/folder/moduleB.d.ts    非相对  由包含导入文件的目录开始，依次向上级目录遍历 /root/src/folder/A.ts 使用引用  引用 import { b } from &amp;quot;moduleB&amp;quot; 查找  /root/src/folder/moduleB.ts /root/src/folder/moduleB.d.ts /root/src/moduleB.ts /root/src/moduleB.d.ts /root/moduleB.ts /root/moduleB.d.ts /moduleB.ts /moduleB.d.ts     Node  同 Node.js 相对引用  检查 /root/src/moduleB.js 检查 /root/src/moduleB/package.json  如若包含 { &amp;quot;main&amp;quot;: &amp;quot;lib/mainModule.js&amp;quot; } 则使用 /root/src/moduleB/lib/mainModule.js  检查 /root/src/moduleB/index.js ，并隐式当作 main 模块  非相对引用  在特殊目录 node_modules 中查找模块 依次向上寻找目录下 node_modules 中的 moduleB.tx,moduleB.tsx,moduleB.d.ts, moduleB.js, moduleB/package.json, moduleB/index.js      声明合并 JSX 装饰器 Mixins 三斜线指令 补充  静态类型  编译时确认变量类型，编译后类型信息和存储形式确定  安德斯·海尔斯伯格  C#的首席架构师 创始人 Delphi 创始人 Turbo Pascal 创始人  内部模块= 命名空间， 外部模块= 模块  </content>
    </entry>
    
     <entry>
        <title>Linux.Chown</title>
        <url>http://domain.yqjdcyy.com/post/linux.chown/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  chown 格式  chown [option]* [user[:[group]*]] [file|group]*
必要参数 -c
 显示更改的部分的信息  -f
 忽略错误信息  -h
 修复符号链接  -R
 处理指定目录以及其子目录下的所有文件  -v
 显示详细的处理信息  -deference
 作用于符号链接的指向，而不是链接文件本身
选择参数  --reference=&amp;lt;目录或文件&amp;gt;
 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组  --from=&amp;lt;当前用户：当前群组&amp;gt;
 只有当前用户和群组跟指定的用户和群组相同时才进行改变  --help
 显示帮助信息  --version
 显示版本信息
实例  chown -R appuser:appuser yao
 将 root 权限下文件夹分配给 appuser 用户   </content>
    </entry>
    
     <entry>
        <title>Linux.Git</title>
        <url>http://domain.yqjdcyy.com/post/linux.git/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Git</tag>
        </tags>
        <content type="html">  参考  安装 Git 生成 SSH 公钥  流程  INSTALL  yum install git-core  SSH  CHECK  less cd ~/.ssh  CREATE  ssh-keygen    </content>
    </entry>
    
     <entry>
        <title>Linux.Scp</title>
        <url>http://domain.yqjdcyy.com/post/linux.scp/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  SCP 特点  scp 为加密传输 scp 消耗资源少，不会提高多少系统负荷  rsync 快一点，但小文件多时会导致硬盘 I/O 非常高   格式  scp [参数] [原路径] [目标路径]  参数  -1  强制scp命令使用协议ssh1  -2  强制scp命令使用协议ssh2  -4  强制scp命令只使用IPv4寻址  -6  强制scp命令只使用IPv6寻址  -B  使用批处理模式（传输过程中不询问传输口令或短语）  -C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  -p  留原文件的修改时间，访问时间和访问权限。  -q  不显示传输进度条。  -r  递归复制整个目录。  -v  详细方式显示输出。 scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。  -c  cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。  -F  ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。  -i  identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。  -l  limit 限定用户所能使用的带宽，以Kbit/s为单位。  -o  ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，  -P  port 注意是大写的P, port是指定数据传输用到的端口号  -S  program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。   事例  scp -r root@10.6.159.147:/opt/soft/test /opt/soft/ scp /data/jenkins/jobs/basic-portal-jianguo/workspace/code/basic-portal/target/basic-portal.war root@106.14.223.58:/data/service/webapps/ scp -rv /data/service/tomcat root@39.108.103.85:/data/service  后台运行 # 执行任务 scp -rv /data/* appuser@120.25.34.33/data # 暂停任务 ctrl&#43; z &amp;amp;&amp;amp; jobs [1]&#43; Stopped scp -rv /data/* appuser@120.25.34.33/data # 将任务切换至后台 bg %1 &amp;amp;&amp;amp; jobs [1]&#43; Running scp -rv /data/* appuser@120.25.34.33/data # 将该作业忽略 HUP 信号以便不受会话影响 disown -h %1 参考  scp 跨机远程拷贝 Linux scp 设置nohup后台运行  </content>
    </entry>
    
     <entry>
        <title>OpenXml.ShapeDefinition</title>
        <url>http://domain.yqjdcyy.com/post/openxml.shapedefinition/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>OpenXml</tag>
        </tags>
        <content type="html">  Shape Definitions And Attributes The Coordinate Systems The Document Coordinate System  (0,0) in the upper left of the document x&#43;&#43;, move right y&#43;&#43;, move downwards Unit EMUs 1 pixel= 9525 EMUs 1 cm= 360000 EMUs 1 inch = 914400 EMUs
The Shape Coordinate System When get the width and height
 (0,0) in the upper left of the shape
 Unit: EMUs
The Path Coordinate System (0,0) in the upper left of the shape
 Units
 same EMU dimensions
 x
 1= width
 y
 1= height
  Specifying Defining  built using lines, curves and calculations code  &amp;lt;p:sp&amp;gt; &amp;lt;p:spPr&amp;gt; &amp;lt;a:xfrm&amp;gt; &amp;lt;a:off x=&amp;quot;1981200&amp;quot; y=&amp;quot;533400&amp;quot;/&amp;gt; &amp;lt;a:ext cx=&amp;quot;1143000&amp;quot; cy=&amp;quot;1066800&amp;quot;/&amp;gt; &amp;lt;/a:xfrm&amp;gt; **&amp;lt;a:prstGeom prst=&amp;quot;heart&amp;quot;&amp;gt;** &amp;lt;/a:prstGeom&amp;gt; &amp;lt;/p:spPr&amp;gt; &amp;lt;/p:sp&amp;gt;  preset shape redered by the generating application where documented within ST_ShapeTypes
Adjusting code
&amp;lt;p:sp&amp;gt; &amp;lt;p:spPr&amp;gt; &amp;lt;a:xfrm&amp;gt; &amp;lt;a:off x=&amp;#34;3276600&amp;#34; y=&amp;#34;990600&amp;#34;/&amp;gt; &amp;lt;a:ext cx=&amp;#34;978408&amp;#34; cy=&amp;#34;484632&amp;#34;/&amp;gt; &amp;lt;/a:xfrm&amp;gt; &amp;lt;a:prstGeom prst=&amp;#34;rightArrow&amp;#34;&amp;gt; &amp;lt;a:avLst&amp;gt; **&amp;lt;a:gd name=&amp;#34;adj1&amp;#34; fmla=&amp;#34;val 50000&amp;#34;/&amp;gt;** **&amp;lt;a:gd name=&amp;#34;adj2&amp;#34; fmla=&amp;#34;val 50000&amp;#34;/&amp;gt;** &amp;lt;/a:avLst&amp;gt; &amp;lt;/a:prstGeom&amp;gt; &amp;lt;/p:spPr&amp;gt; &amp;lt;/p:sp&amp;gt;  Specifying a Custom Shape Defining  code  &amp;lt;p:sp&amp;gt; &amp;lt;p:spPr&amp;gt; &amp;lt;a:xfrm&amp;gt; &amp;lt;a:off x=&amp;quot;3200400&amp;quot; y=&amp;quot;1600200&amp;quot;/&amp;gt; &amp;lt;a:ext cx=&amp;quot;1200000&amp;quot; cy=&amp;quot;1000000&amp;quot;/&amp;gt; &amp;lt;/a:xfrm&amp;gt; &amp;lt;a:custGeom&amp;gt; &amp;lt;a:pathLst&amp;gt; **&amp;lt;a:path w=&amp;quot;2&amp;quot; h=&amp;quot;2&amp;quot;&amp;gt;** &amp;lt;!-- x= 2= 1200000 EMUs, y= 2= 1000000 EMUs --&amp;gt; &amp;lt;a:moveTo&amp;gt; **&amp;lt;a:pt x=&amp;quot;0&amp;quot; y=&amp;quot;2&amp;quot;/&amp;gt;** &amp;lt;/a:moveTo&amp;gt; &amp;lt;a:lnTo&amp;gt; &amp;lt;a:pt x=&amp;quot;2&amp;quot; y=&amp;quot;2&amp;quot;/&amp;gt; &amp;lt;/a:lnTo&amp;gt; &amp;lt;a:lnTo&amp;gt; &amp;lt;a:pt x=&amp;quot;1&amp;quot; y=&amp;quot;0&amp;quot;/&amp;gt; &amp;lt;/a:lnTo&amp;gt; &amp;lt;a:close/&amp;gt; &amp;lt;/a:path&amp;gt; &amp;lt;/a:pathLst&amp;gt; &amp;lt;/a:custGeom&amp;gt; &amp;lt;/p:spPr&amp;gt; &amp;lt;/p:sp&amp;gt;  shape Adjusting Geometry Guides code
&amp;lt;gdLst&amp;gt; &amp;lt;gd name=&amp;#34;y1&amp;#34; fmla=&amp;#34;*/ h adj1 100&amp;#34;/&amp;gt; &amp;lt;/gdLst&amp;gt; a set number of inputs-&amp;gt; equation-&amp;gt; single output
 */ | h | y1 from the document
Adjust Handles adjust handle is linked to adjust values that are used as input to the equations
 type
 XY adjust handle acts in the horizontal/ vertical direction, (horizontal, vertical)
 polar adjust handle acts in a polar manner, (radial width, radial angle)
 code
&amp;lt;ahXY gdRefX=&amp;#34;adj1&amp;#34; minX=&amp;#34;-2147483647&amp;#34; maxX=&amp;#34;2147483647&amp;#34; gdRefY=&amp;#34;adj2&amp;#34; minY=&amp;#34;-2147483647&amp;#34; maxY=&amp;#34;2147483647&amp;#34;&amp;gt; &amp;lt;pos x=&amp;#34;x1&amp;#34; y=&amp;#34;y1&amp;#34;/&amp;gt; &amp;lt;/ahXY&amp;gt; XY Adjust Handle guide the min/ max value for both x and y coordinates within the shape coordinate system
Additional Properties Connection Sites allows to build a diagram from a set of shapes
 params
 x-coordinate
 y=coordinate
 attachment angle
Text Rectangle define the text rectangle within the shape
 depending on Auto-fit options, the text will flow outside the text rectangle
 Unit: EMUs
 code
&amp;lt;a:rect l=&amp;#34;0&amp;#34; t=&amp;#34;0&amp;#34; r=&amp;#34;1200000&amp;#34; b=&amp;#34;1000000&amp;#34;/&amp;gt;  PresetShapeDefinitions.xml Reference  Ecma Office Open XML Part 1 - Fundamentals And Markup Language Reference.pdf Shape Guide.fmla - P 2896 ST_ShapeType - P 2987  Method avLst  desc: dajust value num/ fomula item gd
gdLst desc: calc val list for pathLst
 param
 item
cxnLst desc: connection point for line and so on, so that when shape move , line is still connected by the shape connected point
   param
 item
rect desc: the rectangle for text
 param
 item
pathLst desc: how to draw the shape
 param
 extrusionOk
 3D extrusion(梯度急冷)是否允许，忽略则为 false
 fill
 type
 darken
 darkenLess
 lighten
 none
 normal(default value)
 stroke
 h
 w
 item
 arcTo(hR, wR, stAng, swAng)
 考虑超始点和是否过 90*n 点
 lnTo(pt)
 moveTo(pt)
 cubicBezTo(pt* 3)
 quadBezTo(pts* 2)
 close
  </content>
    </entry>
    
     <entry>
        <title>Oracle.常见问题</title>
        <url>http://domain.yqjdcyy.com/post/oracle.%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Oracle</tag>
        </tags>
        <content type="html">  ORA-12541:TNS:无监听程序  监听失败，自己遇到的情况是主机设置错误 -进入到下述文件中： D:\oracle\product\10.2.0\db_2\network\ADMIN\listener.ora  (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.101)(PORT = 1521))  更新HOST为本地即 HOST= 127.0.0.1 重启监听服务  ORA-01045 :user system lacks create session privilege; logon denied  由于新建的用户缺少机关的权限信息 用sys登入Oracle DB后,下grant create session to yqj;  ORA-12514问题，即TNS 监听程序不能识别给定的SID  指定的数据库未加入监听 进入到下述文件中： D:\oracle\product\10.2.0\db_2\network\ADMIN\listener.ora 指定位置添加相关文字  SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = PLSExtProc) (ORACLE_HOME = C:\oracle\product\10.2.0\db_1) (PROGRAM = extproc) ) /**NEW (SID_DESC = (GLOBAL_DBANAME = testDB) (ORACLE_HOME = C:\oracle\product\10.2.0\db_1) (SID_NAME = testDB) ) */ ) LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1)) (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) ) )   ORA-12518 TNS:监听程序无法分发客户机连接  shutdown一半强制停止，之后建立对于用户登陆退出的触发器并进行登陆测试发现妕提示 自行解决方法  重启服务  网上提供方法  connect sys/test as sysdba show parameters dispatchers; alter system set dispatchers = &amp;lsquo;(protocol=tcp)(dispatchers=3)(service=oracle10xdb)&amp;rsquo;;   EXP-00026  CMD中执行下式：EXP YQJ/YQJ BUFFER=64000 FILE= D:\YQJ.DMP OWNER= YQJ TABLES=(STUDENT); 参数冲突  ORACLE出现乱码  将语言和地域都先修改为英文之后再行修改回中文  ALTER SESSION SET NLS_LANGUAGE=american; ALTER SESSION SET NLS_LANGUAGE=&amp;lsquo;SIMPLIFIED CHINESE&amp;rsquo;; ALTER SESSION SET NLS_TERRITORY=america; ALTER SESSION SET NLS_TERRITORY=CHINA;   </content>
    </entry>
    
     <entry>
        <title>Redis.使用</title>
        <url>http://domain.yqjdcyy.com/post/redis.%E4%BD%BF%E7%94%A8/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Redis</tag>
        </tags>
        <content type="html">  简介 介绍  支持网络，可基于内存亦可持久化的日志型、Key-Value数据库  安装-WINDOWS  下载 http://www.Juming.com/Csdn/dx/?i=712654422676017&amp;amp;s=a2b84b5fc8f9fa297831deba85c07317 解压至 D:\redis-2.0.2，并更新替换redis.conf cmd执行 D:\redis-2.0.2&amp;gt;redis-server.exe redis.conf 运行服务器 cmd执行 D:\redis-2.0.2&amp;gt;redis-cli.exe -h 192.168.10.59 -p 6379 运行客户端 客户端执行 set name yao设置name=yao，后执行get name获取redis中name的值  安装-LINUX VI环境下输入  下载程序  wget http://download.redis.io/releases/redis-2.8.3.tar.gz  解压  tar xzf redis-2.8.3.tar.gz  跳转至解压目录  cd redis-2.8.3  安装Redis  make PREFIX=/usr/local/redis install  若提示make指定未安装，执行yum -y install gcc automake autoconf libtool make 进行安装   拷贝执行相关  src路径下的redis-server、redis-benchmark、redis-cli，redis-2.8.3目录下redis.conf至服务目录/usr/local/redis mkdir -p /usr/local/redis cp redis-server redis-benchmark redis-cli /usr/local/redis cd /usr/local/redis  启动服务
 ./redis-server redis.conf  若服务未后台启动，修改redis.conf的daemonize no为yes 对外情况下，需将 bind 配置一率关闭，同时将 protected-mode 更新为 no   启动客户端  ./redis-cli  写数据  set name yao  读数据  get name   调用-Jedis 实例 import redis.clients.jedis.Jedis; public class Client { public static void main(String[] args) { Jedis jedis= new Jedis(&amp;#34;localhost&amp;#34;); jedis.set(&amp;#34;age&amp;#34;, &amp;#34;25&amp;#34;); String name= jedis.get(&amp;#34;name&amp;#34;); String age= jedis.get(&amp;#34;age&amp;#34;); System.out.println(&amp;#34;[name: &amp;#34;&#43; name&#43;&amp;#34;, age: &amp;#34;&#43; age&#43;&amp;#34;]&amp;#34;); } } 常用方法  新增覆盖
 jedis.set(&amp;quot;name&amp;quot;, &amp;quot;minxr&amp;quot;);  获取
 jedis.get(&amp;quot;name&amp;quot;);  追加
 jedis.append(&amp;quot;name&amp;quot;, &amp;quot;jintao&amp;quot;);  删除
 jedis.del(&amp;quot;name&amp;quot;);  清空数据
 jedis.flushDB();  校验存在
 jedis.exists(&amp;quot;foo&amp;quot;);  不存在时添加否则不操作  jedis.setnx(&amp;quot;foo&amp;quot;, &amp;quot;foo not exits&amp;quot;);  2秒有效
 jedis.setex(&amp;quot;foo&amp;quot;, 2, &amp;quot;foo not exits&amp;quot;);  截取值
 jedis.getrange(&amp;quot;foo&amp;quot;, 1, 3);  批量赋值
 jedis.mset(&amp;quot;name&amp;quot;, &amp;quot;minxr&amp;quot;, &amp;quot;jarorwar&amp;quot;, &amp;quot;aaa&amp;quot;);  批量获取
 jedis.mget(&amp;quot;mset1&amp;quot;, &amp;quot;mset2&amp;quot;, &amp;quot;mset3&amp;quot;, &amp;quot;mset4&amp;quot;);  批量删除
 jedis.del(new String[] { &amp;quot;foo&amp;quot;, &amp;quot;foo1&amp;quot;, &amp;quot;foo3&amp;quot; });   实例 调用实现 org.springframework.data.redis.core.StringRedisTemplate @Autowired StringRedisTemplate stringRedisTemplate; 数据结构 blog:id:hash id 1 likeCount 12 blog [...] blog:zset 1 10 2 2 4 0 工具类 public class RedisKeyUtils { public static String generate(String key, Long id) { //blog:l:%d:hash 10 -&amp;gt; blog:l:10:hash  return String.format(key, id); } } public class RedisSettings { //Redis相关配置参数对象Bean  private String blogHashKey; private String blogSortedSetKey; } public class ColleagueCircleConfig { //Redis初始化  @Autowired Environment environment; @Bean public RedisSettings microBlogRedisSettings() { RedisSettings microBlogRedisSettings = new RedisSettings(); microBlogRedisSettings.setBlogSortedSetKey(&amp;#34;blog:zset&amp;#34;); microBlogRedisSettings.setBlogHashKey(&amp;#34;blog:%d:hash&amp;#34;); microBlogRedisSettings.setBlogCommentSortedSetKey(&amp;#34;blog:%d:c:zset&amp;#34;); microBlogRedisSettings.setBlogCommentHashSetKey(&amp;#34;blog:c:%d:hash&amp;#34;); } } @Configuration @Import(value = {ColleagueCircleConfig.class}) public class AppConfig extends AbstractAppConfig //于系统启动时进行初始化 业务操作 新增 String likeHashKey = RedisKeyUtils.generate(redisSettings.getBlogLikeHashSetKey(), microBlogLike.getBlogId()); addToLikeHash(likeHashKey, microBlogLike); stringRedisTemplate.opsForHash().put(likeHashKey, microBlogLike.getId().toString(), jsonConverter.toJson(microBlogLike)); stringRedisTemplate.opsForHash().increment(blogKey, MicroBlogServiceRedisImpl.BLOG_HASH_FIELD_LIKE_COUNT, 1); BoundHashOperations boundHashOperations = stringRedisTemplate.boundHashOps(key); Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.put(BLOG_HASH_FIELD_BLOG, jsonConverter.toJson(microBlog)); map.put(BLOG_HASH_FIELD_ATTACHMENTS, jsonConverter.toJson(attachments)); map.put(BLOG_HASH_FIELD_RECEIVERS, jsonConverter.toJson(receivers)); map.put(BLOG_HASH_FIELD_COMMENT_COUNT, &amp;#34;0&amp;#34;); map.put(BLOG_HASH_FIELD_LIKE_COUNT, &amp;#34;0&amp;#34;); boundHashOperations.putAll(map); 删除 String key = RedisKeyUtils.generate(redisSettings.getBlogLikeHashSetKey(), blogId); stringRedisTemplate.opsForHash().delete(key, microBlogLikeId.toString()); 查询 String hashKey = RedisKeyUtils.generate(redisSettings.getBlogLikeHashSetKey(), blogId); HashOperations&amp;lt;String, String, String&amp;gt; hashOperations = stringRedisTemplate.opsForHash(); List&amp;lt;String&amp;gt; jsonList = hashOperations.multiGet(hashKey, microBlogLikeIdSet); stringRedisTemplate.opsForZSet().reverseRange(sortedSetKey, 0, pageCount - 1); 调用-SpringDataRedis Key  redisTemplate.hasKey(key) redisTemplate.delete(key);
String List Set Sorted Set redisTemplate.boundZSetOps(key).add(baseQaAnswer.getId(), 0);
 redisTemplate.boundZSetOps(QaRedisConfig.QUESTION_ZSET_KEY_DAY).incrementScore(baseQaAnswer.getQuestionId(), hotCnt);
 redisTemplate.boundZSetOps(QaRedisConfig.QUESTION_ZSET_KEY).remove(id);
 redisTemplate.opsForZSet().reverseRange(key, startIndex, endIndex);
Hash BoundHashOperations boundHashOperations = redisTemplate.boundHashOps(key);
 boundHashOperations.putAll(map); boundHashOperations.expire(QaRedisConfig.QA_EXPIRE_HOURS, TimeUnit.HOURS); boundHashOperations.increment(userId.toString(), 1);  redisTemplate.opsForHash().multiGet(key, HASH_FIELDS_ANSWER);
  参考  官网 文档 命令 Linux下安装 Jedis使用示例 配置redis外网可访问 Linux下redis安装和部署  </content>
    </entry>
    
     <entry>
        <title>项目发布总结</title>
        <url>http://domain.yqjdcyy.com/post/%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E6%80%BB%E7%BB%93/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>工作</tag>
        </tags>
        <content type="html">  域名相关 购买：  购买网站  万网 www.net.cn  示例：
 fzsfxd.com 有限时间三年，金额为149元
服务器备案  若使用国内服务器，且要使用购买的域名，均需要进行备案，周期大概要半个月（个人，较快）
 介绍
 http://beian.aliyun.com  流程
 网站信息、相关企业个人身份证等相关资质填写。 申报人拍照，不允许 PS，其中背景需要为指定幕布（可免费向阿里申请） 网络管理局审批，较慢。   服务器相关 购买  购买网站：阿里云 http://www.aliyun.com/ 配置
  环境配置  使用镜像市场中 【Java 多版本环境】 -&amp;gt; 有坑！！！ 每种东西都留有坑，自己在使用过程中，除了 java 没动，其它 tomcat / mysql/ nginx 都重新安装配置过，囧。后面看它描述，帮忙发布调优啥的都要收费！！
  项目发布和域名解析  域名解析：进入域名解析界面，配置服务器 IP 地址，如 115.28.146.6 项目发布：Tomcat环境发布，本次将服务名称调整为 Root，以便输入 IP 端口后直接访问 Nginx：配置域名和指定服务的绑定，配置如下（安装使用 yum 安装）    注  其中 mysql/ tomcat/nginx 使用时都要注意端口是否有开放   项目收费  个人与企业进行交易，对方可能会要求你提供发票，甚至于企业开具的网站开发的增值税（或非增值）发票。  解决方法  找公司代开，如琴峰，但可能遇到情况是像琴峰他们公司，该操作会影响财务税点啥的，是不愿意操作。 找记账公司代开，但税点要求6，且无若金额太小别人是不鸟的。（此次金额5K）  最好的办法  事先讲好，个人性质，将不提供发票来着。    </content>
    </entry>
    
     <entry>
        <title>如何炼成商业分析能力</title>
        <url>http://domain.yqjdcyy.com/post/%E5%A6%82%E4%BD%95%E7%82%BC%E6%88%90%E5%95%86%E4%B8%9A%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>商业</tag>
        </tags>
        <content type="html">  如何炼成商业分析能力 参考  商业分析能力是怎样炼成的？  前言  幸存者偏差
 任何商业活动最终的成败，都是由一系列完整的环节相互作用所决定的 成功的商业决策者和普通消费者之间的区别  前者对于同样的现象，更能从本质上细致而深刻地理解成因，并知道如何采取相对应的措施去改变现象（即使这种判断不是100%精确的）。  唯有在不断的学习和实践中不断提升自身的商业能力，才有可能在残酷的商业世界的“存活者偏差”现象中成为“幸运”的存活者  学习内容
 会计和金融 战略和市场 营运和管理  迷男方法
 从决策者的决策过程来分析问题的全新维度 一切商业活动的本质都是对于目标客户消费决策的理解和引导，而所有的消费活动都遵循一个相似的过程。   TTPPRC 趋势 - Trend  顺势而为是从事一切商业活动的首要因素。在趋势（Trend）的面前，个人能力终归都是渺小的。 当你的洞察力没高到惊人的程度之前，如果发现了一个很明显的市场空白，那这个市场最大的可能就是——根本不存在。 与其费尽心思解读为什么会有这样的趋势，不如时刻留心趋势的变化，紧随时代的潮流的。 绝大多数商业项目在这一环的关键原则，是不犯大错误  流量 - Traffic  基础
 无论你想卖什么东西，先得让人知道你在卖呀。 让目标客户了解到他们有这么一个消费选择  定位目标客户 目标客户是企业而非大众消费者的（B2B和C2B），决定流量的是销售团队的力量。  不同的商业项目对流量（Traffic）的具体需求大不相同，一般而言，越是标准化高可替代性高的业态，流量这个环节在整个生意上就越重要，  提升
 强势品牌可以自发的导入流量 品牌的第一个作用就是导入流量。 一个商人商业能力的高低的首要标准，就是看他能为自己的生意导入多少流量  效率
 全网流量  微博和微信公众号 知乎和豆瓣  本地 O2O 流量  大众点评和美团 微博和微信    包装 - Package  基础
 在目标客户得知了他们有了这样一个消费选择之后，你的生意是以怎样的面貌呈现在消费者面前的。 包装很大程度上是整个生意成败的决定性因素，而不是产品本身！ 组成  高超的管理统筹能力 领先的战略眼光 一流的综合执行力  一切在消费者买单之前对于你的产品产生的印象，都是由包装的质量决定  越是产品没有核心技术的行业，越是企业包装能力的终极比拼   提升
 一个消费者决定是否对你的产品进行消费，不并是基于产品的实际体验如何（因为他还没用上嘛），而是基于他头脑中对于该次消费的预期体验是否超过了所需要付出的货币价值。 消费决策主要是由短期吸引决定 包装影响消费决策，产品影响二次消费 一个商人对商业的理解程度是否算的上入门，最基本的划分就在于能否意识到：包装才真正决定了消费者是否会对你的产品进行消费！  目标
 包装最终成就一个品牌，而品牌就是终极的包装 能把排队玩明白的企业家都是顶级的包装高手 包装要和流量衔接好  推荐
 邓德隆的《2小时品牌素养》 Sally Hogshead的《迷恋》 Martin Lindstrom的《品牌洗脑》   产品 - Product  基础
 产品的概念也不只是物件本身，包含了服务，保养，售后等等一系列消费行为发生之后，消费者所得到的完整体验 产品本身决定的是是否有重复性消费和新流量的导入-口碑 作为一个优秀的商人，强大的商业素养主要体现在可以把自己能力范围内提供的最好的产品和其他环节相互结合起来 提供技术上绝对领先的产品，超出了一个“商人”的能力范围  作用
 产品的主要作用是促进二次消费和导入新的流量，而非促成消费决策。 正常的商业活动追求想长期发展，需要的是已经有过消费的消费者的重复消费和新的顾客来进行新的消费行为，而这两件事情就得靠产品本身决定了。 在互联网时代到来之前，消费者在进行消费选择时，面临着高度的信息不对称问题。 优秀的产品体验，促成了二次消费，导入了新的流量，而且自带和“排队”同样重量级的包装——“熟人推荐|口碑” 一个优秀的产品的威力之大，可以瞬间打通TTPPRC中的四个要素（产品，流量，包装，重复性消费），这是其他任何一个环节做得再好也无法做到的。  组成
 具有一样鲜明的特色 其他环节没有硬伤  注意
 为什么必须病态地痴迷细节？  因为广大消费者的思维能力虽然比较迟钝，但直觉却是敏锐的。    重复性消费 - Revisit  基础
 判断商业项目是否具备让消费者有重复性消费的能力，是众多创业者和投资人最常见的盲点  婚庆礼仪，高考培训，旅游景区门票  大多数人一生只消费一次的商业项目 优秀产品主要用于赢取口碑，导入新流量，并增强包装  根据项目的天然属性  极其难以预测和分析的   重复性消费弱的项目往往短期之内流量和包装更强  提升
 由人们长期的行为习惯和一些历史传统所决定的 创业者对于该项目的设计。  Draw Something  作为一款手游，它在流量最高的时候竟然没有一套系统的积分，升级，获得道具，解锁新任务等最基本的成瘾体系     相应成本 - Cost  基础
 任何商业活动的本质，都是为了盈利而服务的，任何项目利润的来源都是建立在所提供的**服务价值能够超越自身成本的基础上 互联网时代的生意似乎越来越多已经转向了融资上市套现的获利方式  提升
 成本（Cost）和趋势（Trend），流量（Traffic），包装（Package）产品（Product）重复性消费（Revisit）的关系不是顺序的，而是包含在每一个环节之中，毫无疑问，每个环节都必然受到成本的制约。   案例 不出二品  趋势（Trend）  把握趋势  快 加盟   流量（Traffic）
 成本主要是由店铺的租金而定 目标客户为年轻消费者，选址在大连高新区 辅助团购导流  包装（Package）
 成本主要在于品牌的选择和店铺的装修设计  产品（Product）
 成本主要来自原料的选择 在保证同样的服务效果的同时，精简员工的数量而提供超过平均水平的薪水，而不是多招几个人而提供市场上平均待遇。  重复性消费（Revisit）
 扩张产品线和积分促销 积分方式是购买满5个蛋糕送一个小礼品，之前是杯子，现在是刀叉 集满10个蛋糕门槛太高起不到相应的刺激  成本
 对于成本的分析是渗透在TTPPR的每一个环节中的，而且必然是一个不断妥协不断优化的过程，不把成本作为基本的分析因素的TTPPR是毫无意义的
  总结
 不以赚钱为目的的生意不是骗子就是耍流氓。 当你从无序中看到有序，在混沌中找到规律，自然会开始相信实力而不是运气   流量获取 人都爱100000&#43;战术 - 新媒体总监 - 模仿 - 调研近期朋友圈的热门文章的共同属性（文章结构，叙述方式，情感诉求） - 将公司的产品服务撰写成相似题材的故事（励志，治愈，搞笑） - 找到优秀的渠道（微博大号，相关领域KOL，微信）分发 - 核算传播效果和后台增长。 创始人耍猴战术 - 创始人 - 钻研受众用户喜欢的公众人物的**调性**和他们常见的**曝光方式** 钻研媒体偏好战术 - 创始人&#43;新媒体总监 - **抓住媒体的偏好** - 比如36氪，虎嗅，创业邦最近都在疯传《O2O死亡名单》，那我得赶紧给他们一篇解决方案 - 《我们这一代人的困惑》一天收到那么多转发申请，是不是可以把产品融合到类似的文章中去。 线下导流战术 - 销售总监&#43;技术总监 - 技术团队把**产品的优势**和销售团队阐明，销售总监率领着BD**一家一家谈** 电梯广告战术 - 市场总监&#43;设计总监 - 投放 - 市场总监调研目标客户的主要活动地点，统计人流量和相应指标，挑选出最适合的写字间 - 找到相应的电梯广告供应商，定下套餐和价格 - 在把设计总监制作出的具有传播力的内容 - 根据产品的开发状态选择适合的时间投放。</content>
    </entry>
    
     <entry>
        <title>Tomcat.Service</title>
        <url>http://domain.yqjdcyy.com/post/tomcat.service/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Tomcat</tag>
        </tags>
        <content type="html">  参考  tomcat中server.xml配置详解 Tomcat server.xml配置示例 service.xml  软件  java tomcat  scp -rv /data/service/tomcat root@39.108.103.85:/data/service/tomcat   目录结构  data  service  bin  运行脚本  wechat-forum-dev-start.sh wechat-forum-dev-stop.sh deploy-instance.sh   logs  wechat-forum-dev  catalina.2017-08-15.log catalina.2017-08-15.out host-manager.2017-08-15.log localhost_access_log.2017-08-15.txt manager.2017-08-15.log  wechat-forum-dev_gc.log  run  wechat-forum-dev.pid  9015   tomcat  bin  启动、运行的相关二进制启动脚本 startup.sh shutup.sh version.sh  CATALINA_BASE  实例运行目录  CATALINA_HOME  安装目录  CATALINA_TMPDIR JRE_HOME CLASSPATH   conf  catalina.policy  安全策略  catalina.properties logging.properties server.xml  主配置文件  context.xml  特殊配置全局选项  tomcat-users.xml  授权访问用户配置  tomcat-users.xsd  授权用户名、密码格式限制  web.xml  web 应用全局配置描述   lib  启动的所需 Jar-file  logs webapps work temp  webapps  wechat-forum-dev  conf logs temp webapps work      备注 辅助脚本  scp -r /data/service/bin/deploy-instance.sh* root@39.108.103.85:/data/service/bin scp -r /data/service/webapps/basic-portal/conf root@39.108.103.85:/data/service/webapps/wechat-forum-dev  </content>
    </entry>
    
     <entry>
        <title>如何轻松聊天</title>
        <url>http://domain.yqjdcyy.com/post/%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E8%81%8A%E5%A4%A9/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>社交</tag>
        </tags>
        <content type="html">  如何轻松聊天 参考  不懂跟异性轻松聊天，你如何get到这个技能  因素 心态  影响
 自信心 个人价值  提升
 提升个人价值  提高立身处世能力 收拾外表、整洁干净  与价值相当的人交往 丰富阅历   策略  了解对方需求，针对性满足 言语关怀，行动辅助  口才  避免由表面印象决定交流方式  轻率定高，无法不卑不亢聊天 定低则所决定的聊天方式、内容，容易让对方认定自己的低价值形式 采用*态度大方*表达句式  表达大方自然，干净利落 面对拒绝不强求，有意识不卑不亢   有效幽默  针对 聊天冷场 技能  方式  懂得利用话题 懂得如何问答 懂得发表意见  总结  就是利用对方感兴趣的话题作为切入点 然后在和对方问与答的互动之中 发表对事情的看法和见解  注意  注意节奏，交流而非审问   策略  向上归类  话题延伸至总结、深度  向下归类  概率具体伦  横向归类  扩展至同类、相似元素   补充  适当沉默 懂得倾听
  </content>
    </entry>
    
     <entry>
        <title>浮世绘</title>
        <url>http://domain.yqjdcyy.com/post/%E6%B5%AE%E4%B8%96%E7%BB%98/</url>
        <categories>
          <category>艺术</category>
        </categories>
        <tags>
          <tag>浮世绘</tag>
        </tags>
        <content type="html">  浮世绘 简介  常指彩色印刷的木版画 “浮世”是指当时人们所处的现世，即现代、当代、尘世之类的意思 浮世绘画师以狩野派、土佐派出身者居多，这是因为当时这些画派非常显赫，而被这些画派所驱逐、排斥的画师很多都转向浮世绘发展所致。  制作  绘制原图 雕刻墨板 选定色彩 雕刻色板 刷版（10-20次）  代表画师  铃木春信 东洲斋写乐 歌川广重 葛饰北斋 喜多川歌麿 菱川师宣 溪斋英泉 歌川国芳 月冈芳年  补充  代代相傳的浮世繪技術——訪Adachi版畫研究所 浮世繪——江戶世風民情的寫照  </content>
    </entry>
    
     <entry>
        <title>美式足球</title>
        <url>http://domain.yqjdcyy.com/post/%E7%BE%8E%E5%BC%8F%E8%B6%B3%E7%90%83/</url>
        <categories>
          <category>乐趣</category>
        </categories>
        <tags>
          <tag>运动</tag>
        </tags>
        <content type="html">  美式足球 参考  美式足球 美式橄榄球基本规则 国家橄榄球联盟 NFL 有哪些现役球星值得关注？  规则 场地  100码* 53码  时间  4节* 15分 12分中场休息 每档组织进攻时间 40秒 暂停  传球失败 持球出界 裁判判罚   规则  开球  防守方于本方30码处开球  进攻方回攻手持球尽量向前推进，后续于被阻截处开始进攻 回攻手膝盖触地，表示贪玩，于进攻方20码处开始进攻   进攻  四档进攻，累计进攻10码 弃踢  回攻  争取更多码数开始进攻，甚至于达阵  放弃  单脚着地后，从本方20码开始    发球  由中锋将球传给四分卫  进攻  跑球  [四分卫|跑卫]接球后，摆脱防守后向前突破  传球  由[四分卫|任意发球线后人员]传出，由[外接手|近端锋]接住即可   失败  擒抱 拦截  防守人员将持球人员摔倒在地 进攻球员[单|双]膝触地  出界  丧失球权  丢球 抄截   分数  达阵 - 6分  附加分  射门 - 1分 2码再次冲阵 - 2分   点球 - 3分  未能达阵，第四档尝试  安防 - 2分  进攻队员被防守队员拦截于进攻方端区内   位置  进攻组  时机  已方获得球权  组成  四分卫 跑卫 中锋&#43; 护锋&#43; 截锋&#43; 近端锋 外接手   防守组  时机  对方获得进攻权  组成  线卫 防守前锋&#43; 端锋&#43; 截锋 角卫&#43; 中卫   特勤组  时机  弃踢、点球、开球  组成  弃踢员&#43; 踢球员&#43; 长开球手 扶球员 回攻手 阻跑员    战术  假跑真传 假传真跑的延迟交递 佯传实跑 防护短传 四分卫短传跑锋  联赛  国家美式足球联盟 - NFL 超级碗  国家美式足球联盟年度冠军赛  欧洲美式足球联盟 - NFL Europa  明星  Thomas Edward Brady  汤姆-布雷迪 新英格兰爱国者 四分卫 4次赢得超级碗 &amp;amp; 老婆为巴西超模吉赛尔-邦辰  Rob Gronkowski  罗布·格隆科夫斯基 新英格兰爱国者 近端锋 联盟最强近端锋   Cam Newton  坎姆-牛顿 卡罗来纳黑豹队 四分卫 上赛季的常规赛MVP，绰号“超人”  Justin James Watt  贾斯汀·詹姆斯·瓦特 休斯顿德州人队 防守端锋 三届NFL最佳防守球员 &amp;amp; NFL历史上首位生涯有两个赛季擒杀数超过20次的球员  Aaron Rodgers  阿隆·罗杰斯 绿湾包装工队 四分卫 第四十五届超级杯冠军 &amp;amp; 第四十五届超级碗最有价值球员 &amp;amp; 2011年美联社年度最佳男运动员  Odell Beckham Jr  奥戴尔-贝克汉姆 纽约巨人队 外接手 对阵达拉斯牛仔的单手接球   </content>
    </entry>
    
     <entry>
        <title>中国-桂林</title>
        <url>http://domain.yqjdcyy.com/post/%E4%B8%AD%E5%9B%BD-%E6%A1%82%E6%9E%97/</url>
        <categories>
          <category>旅游</category>
        </categories>
        <tags>
          <tag>中国</tag><tag>桂林</tag>
        </tags>
        <content type="html">  桂林 参考  桂林攻略 桂林旅游攻略 漓江经典五大玩法全攻略 谢大姐啤酒鱼 椿记烧鹅 崇善米粉(总店) 老油条甲天下桂林米粉 大师傅金奖啤酒鱼  推荐 时间  9-11月 2-4天  桂林市区 泛舟漓江，夜游阳朔 逆漓江至杨堤，后返桂林 龙脊梯田   饮食  桂林米粉  先拌匀干吃，再盛骨头汤饮用  漓江啤酒鱼  江鲤用桂北生茶油烹炸，后以啤酒红焖  马蹄糕  特产  地点  桂林市  微笑堂 人人乐 南城  阳朔西街  商品  阳朔画扇 豆腐乳 三花酒   景点  桂林-象山公园  门票  70  评价  去了后悔一会儿，不去后悔一辈子  景点  象鼻山 水月洞   桂林-两江四湖 桂林-靖江王城
 门票  120  评价  我感觉这是整个桂林最坑的景区，没有之一   漓江-画中游
 游船漓江全景游 兴坪-九马画山-兴坪 空中游览漓江 顶峰俯瞰漓江  漓江-遇龙河
 阳朔-西街
 阳朔-漓江
 阳朔-漓江漂流-杨堤至兴坪段
 阳朔-十里画廊
 阳朔-黄布倒影
 龙胜-龙脊梯田
  饭店  椿记烧鹅
 得分 - 地址  桂林市象山区中山中路2号中山大酒店  餐品  烧鹅 榴莲酥 流沙包 潮式卤鹅掌   崇善米粉
 得分  4.0  地址  桂林市秀峰区依仁路5号  餐品  米粉  注意  极辣！需注意   老油条甲天下桂林米粉
 得分  3.9  地址  桂林市阳朔县滨江路37—8号 五悦酒店一层  餐品  米粉 油条   大师傅金奖啤酒鱼
 得分  3.9  地址  阳朔县阳朔西街111号(没有饭店楼下)  餐品  啤酒鱼 田螺酿 芋头 扣肉 漓江虾  注意  推荐团购128元    收费  景点
 漓江 象鼻山 龙脊梯田 遇龙河  餐饮
 桂林米粉，最低五元  住宿
 青旅均价为80元 三星酒店均为价为180元 四星级酒店均价为280元  交通
 轮渡  桂林-阳朔  200&#43;     计划  11.2
 象鼻山 椿记烧鹅 两江四湖&#43; 东西巷 崇善米粉  11.3
 龙脊梯田  商务车&#43; 单索   11.4-.5
 漓江  竹筏  西街 热气球 老油条甲天下桂林米粉 大师傅金奖啤酒鱼   机票  11.1  高崎-两江 20:05-21:55  270* 2   11.6  两江-高崎 22:40-00:20  270* 2    </content>
    </entry>
    
     <entry>
        <title>Tomcat.AccessLog</title>
        <url>http://domain.yqjdcyy.com/post/tomcat.-accesslog/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Tomcat</tag>
        </tags>
        <content type="html">  Tomcat. AccessLog 参考  Tomcat Access Log配置 Class AccessLogValve  作用  设置请求日志中的日志输出格式  详解 位置  conf.server.xml  value.className= *.AccessLogValve   参数  className  执行类  org.apache.catalina.valves.AccessLogValve  默认  org.apache.catalina.valves.FastCommonAccessLogValve  仅支持 common 和 combined patterns
    directory
 产生文件所存放目录的[绝对|相对]路径  相对于 $CATALINA_HOME 默认为 logs   pattern
 %a - 远程IP地址 %A - 本地IP地址 %b - 发送的字节数(Bytes sent), 不包括HTTP headers的字节，如果为0则展示&#39;-&#39; %B - 发送的字节数(Bytes sent), 不包括HTTP headers的字节 %h - 远程主机名称(如果resolveHosts为false则展示IP) %H - 请求协议 %l - 远程用户名，始终为&#39;-&#39;(Remote logical username from identd) %m - 请求的方法(GET, POST等) %p - 接受请求的本地端口 %q - 查询字符串，如果存在，有一个前置的&#39;?&#39; %r - 请求的第一行(包括请求方法和请求的URI) %s - response的HTTP状态码(200,404等) %S - 用户的session ID %t - 日期和时间，Common Log Format格式 %u - 被认证的远程用户, 不存在则展示&#39;-&#39; %U - 请求URL路径 %v - 本地服务名 %D - 处理请求的时间，单位为毫秒 %T - 处理请求的时间，单位为秒 %I - 当前请求的线程名(can compare later with stacktraces)  prefix
 指定每个 AccessLog 的文件名前缀 默认为「access_log」  resolveHosts
 是否通过 DNS lkkiup 将远程主机 IP 转换为对应主机 默认为 false  suffix
 指定每个 AccessLog 的文件名后缀 默认为空  rotatable
 决定是否需要切换日志文件 默认为 true 为 false 时，即所有文件打到同一个日志文件中，并且 fileDateFormat 参数也会被忽略  fileDateFormat
 用于指定文件名中的日期格式，也决定了切换日志文件的策略 如按小时生成日志文件，可设置为 yyyy-MM-dd.HH  condition
 设置是否打开条件日志 如设置 condition=skip，当 ServletRequest.getAttribute(&amp;quot;skip&amp;quot;)== null 时，该请求会被记录 可配合 filter 设置   Cookie| Header| Session| ServletRequest  %{xxx}i 请求headers的信息 %{xxx}o 响应headers的信息 %{xxx}c 请求cookie的信息 %{xxx}r xxx是ServletRequest的一个属性 %{xxx}s xxx是HttpSession的一个属性  示例  默认  &amp;lt;Valve className=&amp;quot;org.apache.catalina.valves.AccessLogValve&amp;quot; directory=&amp;quot;logs&amp;quot; prefix=&amp;quot;access.&amp;quot; suffix=&amp;quot;.log&amp;quot; pattern=&amp;quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b &amp;quot;%{Referer}i&amp;quot; &amp;quot;%{User-Agent}i&amp;quot; %{X-Forwarded-For}i &amp;quot;%Dms&amp;quot;&amp;quot; resolveHosts=&amp;quot;false&amp;quot;/&amp;gt;  服务器配置  &amp;lt;Valve className=&amp;quot;org.apache.catalina.valves.AccessLogValve&amp;quot; directory=&amp;quot;/data/service/logs/${tomcat.instance.name}-test&amp;quot; prefix=&amp;quot;localhost_access_log&amp;quot; suffix=&amp;quot;.txt&amp;quot; pattern=&amp;quot;%h %{x-forwarded-for}i %l %u %t &amp;amp;quot;%r&amp;amp;quot; %s %b %D&amp;quot; /&amp;gt;   </content>
    </entry>
    
     <entry>
        <title>Hello.Spark</title>
        <url>http://domain.yqjdcyy.com/post/spark/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Spark</tag>
        </tags>
        <content type="html">  Spark 启动  Spark  method  setUp  threadPool ipAddress port secure  start  init stop webSocket  other  (String path, Route route)  get post put patch delete head trace connect options before after  (String path, String acceptType, Route route) webSocket(String path, Class&amp;lt;?&amp;gt; handler)   class  SingletonHolder  static final SparkInstance INSTANCE = new SparkInstance();  SparkInstance  parameter  port ipAddress max|min Threads webSocketHandlers SparkServer SimpleRouteMatcher CountDownLatch  method  init()  this.routeMatcher = RouteMatcherFactory.get(); (new Thread(run&amp;lt;invokedynamic&amp;gt;(this))).start();  getter/ setter webSocket(String path, Class&amp;lt;?&amp;gt; handler) addRoute(String httpMethod, RouteImpl route) addFilter(String httpMethod, FilterImpl filter)  extends  Runnable  used  HaltException JettySparkServer  parameter  Handler Server  method  ignite(String host, int port, SslStores sslStores, String staticFilesFolder, String externalFilesFolder, CountDownLatch latch, int maxThreads, int minThreads, int threadIdleTimeoutMillis, Map&amp;gt; webSocketHandlers, Optional webSocketIdleTimeoutMillis)  impl  SparkServer  ignite  init  Ignites the spark server, listening on the specified port, running SSL secured with the specified keystore and truststore JettyServerFactory.createServer(maxThreads, minThreads, threadIdleTimeoutMillis); SocketConnectorFactory.createSocketConnector(server, host, port); WebSocketServletContextHandlerFactory.create(webSocketHandlers, webSocketIdleTimeoutMillis); server.setHandler(handlers);  start  server.start(); latch.countDown();  CountDownLatch latch = new CountDownLatch(1);  server.join();   stop  server.stop();    uesd  Handler  impl  AbstractHandler  impl  impl  HandlerWrapper  method  void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)  super.handle(target, baseRequest, request, response); cehck resource exists/ endsWith    check last_modified/ etag/ mime              Server  parameter  SessionIdManager List ThreadPool AttributesMap RequestLog  method  doStart()  ShutdownMonitor.getInstance().start(); doStop() List&amp;gt; futures  futures.add(((Graceful)graceful).shutdown());  添加各连接、子处理器的关闭进程结果  future.isDone()  检查是否均已关闭成功  connector.stop();   handle(HttpChannel connection)  !HttpMethod.OPTIONS.is(request.getMethod())  response.sendError(HttpStatus.BAD_REQUEST_400);  handler.handle(target,baseRequest, request, response);   used  HttpField  parameter  HttpHeader name value hash  method  getter/ setter  used  HttpHeader  enum 请求头各项    ShutdownMonitor  parameter  host port key  stop.key  ServerSocket Thread  method  start()  new Thread(new ShutdownMonitorRunnable()).start() stopLifeCycles (boolean destroy)  void stopOutput (Socket socket) void stopInput (Socket socket)  used  ShutdownMonitorRunnable  method  ShutdownMonitorRunnable()  startListenSocket()  run()  serverSocket.accept().getInputStream() &amp;ldquo;stop&amp;rdquo;.equalsIgnoreCase(cmd)  _lifeCycles.stop() _lifeCycles.destroy()   stopInput (Socket socket)  close(serverSocket);  stopOutput (Socket socket)  socket.shutdownOutput(); close(socket);  startListenSocket()  serverSocket = new ServerSocket(); serverSocket.bind(new InetSocketAddress(InetAddress.getByName(host), port), 1);  InetAddress.getByName(host)     key = Long.toString((long)(Long.MAX_VALUE * Math.random() &#43; this.hashCode() &#43; System.currentTimeMillis()),36);    LifeCycle  method  server  start() stop()  status  isRunning() isStarted() isStarting() isStopping() isStopped() isFailed()    ServerSocket  parameter  bCreated bBound bClosed bOldImpl closeLock SocketImpl   SocketImpl  impl  AbstractPlainSocketImpl  method  create connect bind listen accept  impl  TwoStacksPlainSocketImpl    DualStackPlainSocketImpl PlainSocketImpl           extends  HandlerWrapper     SimpleRouteMatcher  parameter  List routes  method  addRoute(HttpMethod method, String url, String acceptedType, Object target)  List  removeRoute(String path, String httpMethod) findTargetsForRequestedRoute(HttpMethod httpMethod, String path)   RouteEntry  parameter  httpMethod path acceptedType target  method  boolean matchPath(String path) boolean matches(HttpMethod httpMethod, String path)  used  HttpMethod  Enum  get post put patch delete head trace connect options before after   parameter  target matchUri requestURI acceptType        理解  服务启动 端口监听 handler 构造   渲染  Configurable  parameter  setUp  locale *Format timeZone encode autoFlush variables  utils  objectMapper templateExceptionHandler TemplateClassResolver   extends  Template  parameter  macros imports TemplateElement lines name/ encoding/ defaultNS - namespace  method  process(Object rootMap, Writer out, ObjectWrapper wrapper, TemplateNodeModel rootNode)  createProcessingEnvironment(rootMap, out, wrapper)  Environment createProcessingEnvironment(Object rootMap, Writer out, ObjectWrapper wrapper)  convert map to Enviroment   class  LineTableBuilder  处理行信息中回车、TAB   Used  FMParser TemplateElement  树形结构  TemplateCache  parameter  delay CacheStorage localizedLookup Configuration  method  removeTemplate(String name, Locale locale, String encoding, boolean parse)  storage.remove(tk);  getTemplate(String name, Locale locale, String encoding, boolean parse)  storage.get(tk)   class  CachedTemplate  parameter  templateOrException source lastChecked lastModified   TemplateKey  parameter  name locale encoding parse     CacheStorage  method  get put remove clear       TemplateEngine  parameter  Configuration  method  String render(ModelAndView modelAndView)  this.configuration.getTemplate(modelAndView.getViewName()); template.process(modelAndView.getModel(), e);   extends  FreeMarkerEngine   理解  初始化解析器  资源加载 格式转换  模板存取 模板的应用、语法解析 国际化、语种等相关通用设置   </content>
    </entry>
    
     <entry>
        <title>Linux.XArgs</title>
        <url>http://domain.yqjdcyy.com/post/linux.xargs/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  作用  将参数列表转换成小块分段传递给其他命令，以避免参数列表过长 以空白字符或换行作为分隔，将标准输入切割为多字符串并作为指定指令执行时的参数  INPUT  xargs cat arg1 arg2 arg3  EXECUTE  cat arg1 arg2 arg3    参数  -d .*  指定输入的分隔符 -d\n  -n \d&#43;  指定每次执行时所用参数上限值 echo a b c d e f | xargs -n 3  echo a b c echo d e f   -p  每条分割语句执行前需经确认 echo 1 2 3 | xargs -p  echo 1 2 3 ?...  y    -r  避免以空字符串作为参数 echo | xargs -p -r  -t  显示执行的指令 echo 1 2 3 | xargs -t  echo 1 2 3 1 2 3   -I
 指定替换字符
cat list | grep -v -f listed | xargs -I {} convert -resize &amp;#34;1024x768&amp;#34; -strip -quality 75% {} {}   示例  删除当前目录下，指定格式的重复图片  find . -name &amp;quot;*).png&amp;quot; | xargs -p rm -f   参考  Linux 系統 xargs 指令範例與教學 Wiki-xargs []()  </content>
    </entry>
    
     <entry>
        <title>Redis.Keys-Del</title>
        <url>http://domain.yqjdcyy.com/post/redis.keys-del/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Redis</tag>
        </tags>
        <content type="html">  参考  Linux 系統 xargs 指令範例與教學 获取Redis所有Key / 删除指定前缀的Key 批量删除Redis数据库中的Key  明细  Login  /opt/redis/redis-cli -p &amp;lt;port&amp;gt; -a &amp;lt;password&amp;gt;  Search-Delete  /opt/redis/redis-cli keys &amp;quot;*&amp;quot; | xargs /opt/redis/redis-cli del   示例 删除指定练习相关缓存  导出以指定键开头的缓存  /usr/local/bin/redis-cli -p 37652 -a 5c\!1@a7z#5623qb2eee98e12b16d301466yunkai1024 keys &amp;quot;exercises:10203*&amp;quot; &amp;gt; /data/op-script/redis/exercises:10203  列举所有以指定键开头的缓存  /usr/local/bin/redis-cli -p 37652 -a 5c\!1@a7z#5623qb2eee98e12b16d301466yunkai1024 keys &amp;quot;exercises:10203*&amp;quot;  删除所有以指定键开头的缓存  /usr/local/bin/redis-cli -p 37652 -a 5c\!1@a7z#5623qb2eee98e12b16d301466yunkai1024 keys &amp;quot;exercises:10203*&amp;quot; | xargs /usr/local/bin/redis-cli -p 37652 -a 5c\!1@a7z#5623qb2eee98e12b16d301466yunkai1024 del   </content>
    </entry>
    
     <entry>
        <title>Linux.Nginx</title>
        <url>http://domain.yqjdcyy.com/post/linux.nginx/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Nginx</tag>
        </tags>
        <content type="html">  Linux.Nginx 参考  反向代理 Nginx 配置简述 nginx服务器安装及配置文件详解 nginx服务器详细安装过程 Centos下 Nginx安装与配置 nginx 官网 nginx配置location总结及rewrite规则写法 nginx配置url重写  概念 反向代理  概念  用代理服务器来接受internet上的连接请求，然后将请求「转发」给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端   用途  将防火墙后面的服务器提供给 Internet 用户访问  负载均衡 缓冲    安装  yum install nginx  默认安装许多模块，影响以后安装第三方模块   指令  nginx -s [start|reload|stop]  通过 signal 向 nginx发送指令  nginx -t  查看 nginx 配置文件位置   基本配置 明细配置项 main Common  全局配置，与具体业务无关 woker_processes 2  工作进程的个数  默认设置为 CPU 的核数  grep ^processor /proc/cpuinfo | wc -l  cpu* (ssl|gzip? [1|2]: 1)  可以减少I/O操作    worker_cpu_affinity 0001 0010 0100 1000  设置cpu粘性来降低由于高并发情况下多CPU核切换造成的寄存器等现场重建带来的性能损耗 示例为四核情况下配置  worker_connections 2048  每一个worker进程能并发 [处理|发起] 的最大连接数，包括与客户端、后端代理之间的所有连接 记录于 events 中 最大连接数计算  反向代理  worker_processes * worker_connections/4  http 服务  worker_processes * worker_connections/2  不能超过 worker_rlimit_nofile   worker_rlimit_nofile 10240  无默认值 上限为操作系统最大的限制 65535  use epoll  记录于 events 中 Linux 下使用 epoll OpenBSD|FreeBSD 系统中使用类 epoll 的事件模型 kqueue 不支持这些高效模型情况下，才使用 select   Http  Http 服务相关配置 sendfile on  开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换 进行「下载」等应用磁盘IO重负载应用，可设置为「off」  keepalive_timeout 65  长连接超时时间，单位是秒 过长容易占用资源，过小则影响大文件上传等服务请求  send_timeout  指定响应客户端的超时时间  client_max_body_size 10m  允许客户端请求的最大单文件字节数  client_body_buffer_size 128k  缓冲区代理缓冲用户端请求的最大字节数   Http-Proxy  反向代理与缓存实现 proxy_connect_timeout 60  nginx跟后端服务器连接超时时间  proxy_read_timeout 60  连接成功后，与后端服务器两个成功的响应操作之间超时时间  proxy_buffer_size 4k  从后端realserver读取并保存用户头信息的缓冲区大小 默认与proxy_buffers大小相同  proxy_buffers 4 32k  对单个连接缓存来自后端的响应，网页平均在32k以下  proxy_busy_buffers_size 64k  高负荷下缓冲大小 proxy_buffers*2  proxy_max_temp_file_size  响应内容超出 proxy_buffers 时，将部分内容更新至硬盘临时文件中 设置最大临时文件大小 默认1024M，设置为0时表示禁用  proxy_temp_file_write_size 64k  限制每次写临时文件的大小  proxy_temp_path  编译时指定，设置缓存临时文件路径   Http-GZip  gzip on  开启gzip压缩输出，减少网络传输  gzip_min_length 1k  设置允许压缩的页面最小字节数 页面字节数从header头得content-length中获取 默认20，建议1K&#43;，避免越压越大  gzip_buffers 4 16k  设置系统获取「几个单位」的缓存用于存储gzip的压缩结果数据流 4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存  gzip_http_version 1.0  识别 http 协议的版本 支持早期的浏览器  gzip_comp_level 6  gzip压缩比 1压缩比最小处理速度最快 9压缩比最大但处理速度最慢  gzip_types  匹配mime类型进行压缩 无论是否指定,”text/html”类型总是会被压缩的  gzip_proxied any  Nginx作为反向代理的时候启用 决定开启或者关闭后端服务器「返回的结果是否压缩」 前提是后端服务器必须要返回包含”Via”的 header头  gzip_vary on  在响应头加个 Vary: Accept-Encoding 让前端的缓存服务器缓存经过gzip压缩的页面   Server  指定虚拟主机域名、IP 和端口 listen  默认80，小于1024的要以root启动 listen *:80 listen 127.0.0.1:80 等形式  server_name  如 localhost www.example.com或正则匹配  rewrite  rewrite &amp;lt;rules&amp;gt; &amp;lt;pathes&amp;gt; &amp;lt;types&amp;gt;;  rules  字符串 | 正则表达式  pathes  指定匹配路径要更新的地址 建议使用正则，使用捕获分组功能  types  last  表示完成rewrite，无特殊含义 浏览器地址栏URL地址不变  break  本条规则匹配完成后，终止匹配 浏览器地址栏URL地址不变  redirect  返回302临时重定向，浏览器地址会显示跳转后的URL地址  permanent  返回301永久重定向，浏览器地址栏会显示跳转后的URL地址      Global-Args  $args  变量等于请求行中的参数，同$query_string  $content_length  请求头中的Content-length字段。  $content_type  请求头中的Content-Type字段。  $document_root  当前请求在root指令中指定的值。  $host  请求主机头字段，否则为服务器名称。  $http_user_agent  客户端agent信息  $http_cookie  客户端cookie信息  $limit_rate  这个变量可以限制连接速率。  $request_method  客户端请求的动作，通常为GET或POST。  $remote_addr  客户端的IP地址。  $remote_port  客户端的端口。  $remote_user  已经经过Auth Basic Module验证的用户名。  $request_filename  当前请求的文件路径，由root或alias指令与URI请求生成。  $scheme  HTTP方法（如http，https）。  $server_protocol  请求使用的协议，通常是HTTP/1.0或HTTP/1.1。  $server_addr  服务器地址，在完成一次系统调用后可以确定这个值。  $server_name  服务器名称。  $server_port  请求到达服务器的端口号。  $request_uri  包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。  $uri  不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。  $document_uri  与$uri相同。   Upstream  针对特定 URL 对应的系列配置项 root /var/www/html  定义服务器的默认网站根目录位置 于 server 或 / 下生效  index index.jsp index.html index.htm  定义路径下默认访问的文件名 root 搭配使用  proxy_pass http:/backend  请求转向 backend 对应的服务器列表  反向代理 对应 upstream 负载均衡器  proxy_pass http://ip:port  proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  Location  匹配网页位置 ~  执行一个正则匹配，区分大小写  ~*  执行一个正则匹配，不区分大小写  ^~  普通字符匹配，如果该选项匹配则结束 一般用于匹配目录  =  普通字符精确匹配   Alias &amp;amp; Root  Alias
location /c/ { # 末尾必须加 / # http://localhost/c= /a/ 目录 alias /a/; } Root
location /c/ { # http://localshot/c= /a/c 目录 root /a/; }  示例 默认配置 user www www; worker_processes 2; error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; pid logs/nginx.pid; events { use epoll; worker_connections 2048; } http { include mime.types; default_type application/octet-stream; #log_format main &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39; # &amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39; # &amp;#39;&amp;#34;$http_user_agent&amp;#34; &amp;#34;$http_x_forwarded_for&amp;#34;&amp;#39;; #access_log logs/access.log main; sendfile on; # tcp_nopush on; keepalive_timeout 65; # gzip压缩功能设置 gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 6; gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; gzip_vary on; # http_proxy 设置 client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 75; proxy_send_timeout 75; proxy_read_timeout 75; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_temp_path /usr/local/nginx/proxy_temp 1 2; # 设定负载均衡后台服务器列表 upstream backend { #ip_hash; server 192.168.10.100:8080 max_fails=2 fail_timeout=30s ; server 192.168.10.101:8080 max_fails=2 fail_timeout=30s ; } # 很重要的虚拟主机配置 server { listen 80; server_name itoatest.example.com; root /apps/oaapp; charset utf-8; access_log logs/host.access.log main; #对 / 所有做负载均衡&#43;反向代理 location / { root /apps/oaapp; index index.jsp index.html index.htm; proxy_pass http://backend; proxy_redirect off; # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; } #静态文件，nginx自己处理，不去backend请求tomcat location ~* /download/ { root /apps/oa/fs; } location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ { root /apps/oaapp; expires 7d; } location /nginx_status { stub_status on; access_log off; allow 192.168.10.0/24; deny all; } location ~ ^/(WEB-INF)/ { deny all; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } ## 其它虚拟主机，server 指令开始 } 匹配任何以 /images/ 开始的请求，并停止匹配 其它location location ^~ /images/ {...} 负载均衡 upstream myserver; { # 指明按照用户 IP 进行分配 # 可选类型为轮询、指定权重轮询、fair、url_hash 等 ip_hash; server 172.16.1.1:8001; server 172.16.1.2:8002; server 172.16.1.3; server 172.16.1.4; } location / { proxy_pass http://myserver; } 域名跳转  针对非 ROOT 项目
server { listen 80; server_name www.weixinqdh.com weixinqdh.com; access_log /data/service/logs/nginx/weixinqdh.access.log main; error_log /data/service/logs/nginx/weixinqdh.error.log; location / { rewrite ^ /wechat-forum-dev redirect; } location /wechat-forum-dev/ { expires -1; proxy_set_header Host $http_host; proxy_pass http://localhost:9015/wechat-forum-dev/; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } }  停止后重启，找不到nginx.pid /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 资源转跳 location ~ ^/upload/(.*)\.(jpg|jpeg|png|gif)$ { root /data/service/tomcat/webapps; access_log off; expires 7d; } location ~ ^/wechat-forum-dev/upload/(.*)\.(jpg|jpeg|png|gif)$ { rewrite /wechat-forum-dev/(.*) /$1 last; } FFMPEG 推流报 499 proxy_http_version 1.1; proxy_request_buffering off; proxy_ignore_client_abort on; 进程被杀，无法正常启动  Error  nginx: [alert] kill(189, 1) failed (3: No such process)  Solution  /usr/sbin/nginx -c /etc/nginx/nginx.conf   </content>
    </entry>
    
     <entry>
        <title>Linux.Grep</title>
        <url>http://domain.yqjdcyy.com/post/linux.grep/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Grep 参考  grep命令 每天一个linux命令（39）：grep 命令 linux grep命令 man-grep  格式  grep [OPTIONS] PATTERN [FILE...] grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]  参数 匹配器选择  -E, --extended-regexp  扩展正则表达式 由 POSIX 指定  -F, --fixed-strings, --fixed-regexp  模式解析为固定字符串列表，以换行符分隔，任一匹配 弃用别名  -G, --basic-regexp  解析为基本正则表达式 默认配置  -P, --perl-regexp  模式解析为 Perl 正则表达式 开发阶段，会提示未实现的特性   匹配控制  -e PATTERN, --regexp=PATTERN  文本正则  -f FILE, --file=FILE  正则条件文本文件，以换行符分隔 空文件则匹配不到任何东西  -i, --ignore-case  忽略正则表达式和内容的字符大小写匹配限制  -v, --invert-match  反向匹配 输出正则匹配到的元素之外的信息  -w, --word-regexp  全字匹配  -x, --line-regexp  全行匹配  -y  -i 的弃用同义词   控制输出  -c, --count  输出匹配的各文件中的行数  --color[=WHEN], --colour[=WHEN]  在终端以颜色区分匹配字符串，以转义字符显示包围的相关分隔符等信息 默认根据系统参数 GREP_COLORS 显示，但目前已弃用，优先级降低  -L, --files-without-match  打印出每个输入文件名称 终止于第一条匹配数据  -l, --files-with-matches  同 -L 由 POSIX 指定  -m NUM, --max-count=NUM  最多输出 NUM 个匹配项  -o, --only-matching  仅打印匹配行，以换行符分隔  -q, --quiet, --silent  不打印标准输出 成功时以 0 状态退出，失败时以 非0 值退出  -s, --no-messages  不打印异常消息   输出前缀控制  -b, --byte-offset  每行输出，0字节偏移  -H, --with-filename  打印每个匹配的文件名  -h, --no-filename  输出时忽略文件前缀 默认  --label=LABEL  以实际标准输入作为  文件的输入 gzip -cd foo.gz | grep --label=foo -H  -n, --line-number  显示行号  -T, --initial-tab  缩进对齐  -u, --unix-byte-offsets  以 Unix 风格的字节偏移  -Z, --null  以0字节分隔文件名和匹配项   上下文控制  -A NUM, --after-context=NUM  显示匹配行后指定数量行数额外信息  -B NUM, --before-context=NUM  显示匹配行前指定数量行数额外信息  -C NUM, -NUM, --context=NUM  输出匹配行前后指定数量行额外信息，各匹配行之间以空行间隔  --group-separator=SEP  使用指定符号作为组分隔符 默认为 --  -no-group-separator  使用空字符串作为组分隔符   文件目录选项  -a, --text  执行文本类型的二进制文件 等价于 --binary-files=text  --binary-files=TYPE  指定文件类型匹配 默认为 binary  -D ACTION, --devices=ACTION  当输入为文件为设备、FIFO 或流时，使用指定动作处理 默认为 read，可选项为 skip  -d ACTION, --directories=ACTION  当输入文件为文档时，使用指定处理 默认为 read，可选项为 recurse  recurse  递归读取每个目录，其中符号连接符仅在命令行中指定时查询 等价于 -r    --exclude=GLOB  忽略文件名匹配的文件 可使用 * ? . 作为通配符  --exclude-from=FILE  忽略文件名匹配中任一规则的文件  --exclude-dir=DIR  递归搜索中，排除匹配正则的目录  -I  处理二进制文件，如同未包含匹配数据 等价于 --binary-files=without-match  --include=GLOB  仅搜索文件名匹配的文件  -r, --recursive  递归搜索所有目录 符号链接仅于命令行中指定时生效 -d   其它选项  --line-buffered  在输出使用行缓冲，会导致性能损失  -U, --binary  将文件当成二进制文件 MS-DOS 和 MS-WINDOWS 下，会自动抓取前 32KB 内容以判断文件类型  -z, --null-data  将输入视为一组行，每行以0字节代替换行符作为分隔符   示例  grep &amp;quot;match_pattern&amp;quot; file_name --color=auto  标记匹配颜色  echo this is a test line. | egrep -o &amp;quot;[a-z]&#43;\.&amp;quot;  仅输出匹配内容  grep &amp;quot;text&amp;quot; . -r -n  递归当前目录进行搜索  echo this is a text line | grep -e &amp;quot;is&amp;quot; -e &amp;quot;line&amp;quot; -o  多匹配条件  grep &amp;quot;main()&amp;quot; . -r --include *.{php,html}  递归并指定 .php 和 .html 文件进行搜索  grep -q &amp;quot;test&amp;quot; filename  静默执行，仅返回执行状态  0 为成功 其它为失败   seq 10 | grep &amp;quot;5&amp;quot; -A 3 -B 2  显示匹配记录后三行和前两行记录  seq 10 | grep &amp;quot;5&amp;quot; -C 1  显示匹配记录的前后各一行记录   </content>
    </entry>
    
     <entry>
        <title>Go.并行&amp;并发</title>
        <url>http://domain.yqjdcyy.com/post/go.goruntime/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag><tag>GoRuntime</tag>
        </tags>
        <content type="html">  参考  Go语言并发与并行学习笔记 What exactly does runtime.Gosched do? 关于GoRoutine的一个运行问题  概念 默认设置  所有 goruutime 均在单原生线程中运行，仅占用单 CPU 当前 goruutime 不阻塞则不会让出 CPU 时间给其它同线程的 goruutime 当 goruutime 阻塞时， Go 将自动将此线程的其它 goruutime 转换到其它运行中的系统线程  并行&amp;amp; 并发   并行  多套环境 配套任务队列和消息处理  并发  一套环境 多任务队列和单一消息处理   重点  显式多核  runtime.GOMAXPROCS  手动显式调用  runtime.Gosched   示例  单线程多任务串行
 并发，逐一执行 ``` var quit chan int = make(chan int)  func loop() { for i := 0; i &amp;lt; 10; i&#43;&#43; { fmt.Printf(&amp;ldquo;%d &amp;ldquo;, i) } quit &amp;lt;- 0 }
func main() { go loop() * 2
for i := 0; i &amp;lt; 2; i&#43;&#43; { &amp;lt;- quit } } ```
 单线程多任务并发
 并发，多任务阻塞后切换执行 ``` var quit chan int  func foo(id int) { fmt.Println(id) time.Sleep(time.Second) quit &amp;lt;- 0 }
func main() { count := 1000 quit = make(chan int, count)
for i := 0; i &amp;lt; count; i&#43;&#43; { go foo(i) } for i :=0 ; i &amp;lt; count; i&#43;&#43; { &amp;lt;- quit } } ```
 多线程并行
 两个线程任务同时进行 ``` var quit chan int = make(chan int)  func loop() { for i := 0; i &amp;lt; 100; i&#43;&#43; { fmt.Printf(&amp;ldquo;%d &amp;ldquo;, i) } quit &amp;lt;- 0 }
func main() { runtime.GOMAXPROCS(2) go loop()* 2 for i := 0; i &amp;lt; 2; i&#43;&#43; { &amp;lt;- quit } } ```
 单线程并发
 多线程多任务显式切换  func loop() { for i := 0; i &amp;lt; 10; i&#43;&#43; { runtime.Gosched() fmt.Printf(&amp;quot;%d &amp;quot;, i) } quit &amp;lt;- 0 }    </content>
    </entry>
    
     <entry>
        <title>Wechat.Export</title>
        <url>http://domain.yqjdcyy.com/post/wechat.export/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Wechat</tag>
        </tags>
        <content type="html">  微信语音导出 参考 -如何导出微信【收藏】中的语音文件？ -Windows下批量转换Silk v3音频文件为MP3格式 -silk2mp3.zip - 3&amp;frasl;3 -ONLINE AUDIO CONVERTER - 0/ 1 -kn007/silk-v3-decoder
流程  将语音收藏 在手机完整收听 使用目录管理搜索提取  ./sdcard/tecent/MicroMsg/ 搜索 .silk 文件  拷贝至电脑 使用 silk2mp3 工具将音频*转换*为 mp3 格式文件  注意  SILK v3  为 skype 向第三方开发人员或硬件制造商提供的免版税谁的 Silk 宽音频编码器 文件更为精简  xxx.silk 18KB xxx.mp3 189KB    </content>
    </entry>
    
     <entry>
        <title>Error.MYSQL</title>
        <url>http://domain.yqjdcyy.com/post/error.mysql/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Error</tag><tag>MYSQL</tag>
        </tags>
        <content type="html">  1175  Description  You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&amp;gt; SQL Editor and reconnect.  Answer  SET SQL_SAFE_UPDATES = 0;   </content>
    </entry>
    
     <entry>
        <title>Windows.右键菜单绑定</title>
        <url>http://domain.yqjdcyy.com/post/windows.right-click.menu/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Windows</tag><tag>Register</tag>
        </tags>
        <content type="html">  右键菜单绑定 参考  Windows右键菜单设置与应用技巧 命令提示符中同时运行多命令  右键上传  修改注册表  结构  HKEY_CLASSES_ROOT  *  shell  （╯‵□′）╯︵┴─┴  新增「项」，其中名称为右键菜单要展示的名称 command  新增「项」，对应点击后执行的内容  默认  cmd.exe /k upload.exe -path=%1 &amp;amp;&amp;amp; exit  cmd.exe /k XXXXX  在 cmd 中执行 XXXXX 指令 &amp;amp;&amp;amp; 于前一条指令执行完成后执行           示例       </content>
    </entry>
    
     <entry>
        <title>Go.Upload.Qiniu</title>
        <url>http://domain.yqjdcyy.com/post/go.upload.qiniu/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag><tag>Product</tag>
        </tags>
        <content type="html">  描述  将指定 [文件|文件夹|当前文件夹] 的内容上传至 七牛云 上传完毕后将链接转换为 Markdown 格式文本 将结果数据更新至剪贴板  参考  Go SDK qiniu/api.v7 package context tjgq/clipboard package clipboard  需求  将链接中的图片等本地保存后，再重新上传生成链接 命令行可全局快速调用，考虑结合 wox 等工具 快速选择多个文件等 文件夹仅操作当层  测试  单文件 ``` go run main.go -path=C:\Users\Yao\Desktop\76aaa869ly1fi6n1duxn5j21dw0kak5a.jpg  ![76aaa869ly1fi6n1duxn5j21dw0kak5a.jpg][http://doc.yqjdcyy.com/04cf05bd-ba52-4dee-8fa9-095555f5c7ec.jpg]
- 文件夹 go run main.go -path=D:\data\soft\OneDrive\Documents\Write\work\云开
[人员列表.xls][http://doc.yqjdcyy.com/a.xls] [六步搞定实地辅导-20170822.md][http://doc.yqjdcyy.com/b.md] [人员列表.txt][http://doc.yqjdcyy.com/c.txt]
- Exe 方式调用[**异常**] go run upload.go -path=C:\Users\Yao\Desktop\76aaa869ly1fi6n1duxn5j21dw0kak5a.jpg
[新建 Microsoft PowerPoint 演示文稿.pptx][http://doc.yqjdcyy.com/19118280-cacb-43f3-98b6-32600ef459b9.pptx] uplaod.exe%!(EXTRA string=http://doc.yqjdcyy.com/a932af7f-837a-4df6-92dd-e80b29c25ab6.exe) ```
补充  path
 cd D:\work\git\yao\go\Utils_Go\src\upload\qiniu d:  config
 set gopath=D:\server\go\lib;D:\work\git\yao\go\Hello_Go;D:\work\git\yk\go\pptconverter-gateway\code;D:\work\git\yao\go\Utils_Go;D:\work\git\401\go\Go_WuKong;D:\work\git\yao\go\Utils_Go\src\upload\qiniu set path=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\WIDCOMM\Bluetooth Software\;C:\Program Files\WIDCOMM\Bluetooth Software\syswow64;D:\server\java\jdk1.8.0_65\bin;D:\server\java\jdk1.8.0_65\jre\bin;D:\server\maven\apache-maven-3.5.0\bin;C:\Program Files\Git\cmd;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;D:\Program Files\nodejs\;D:\server\go\1.8\bin;D:\server\python\python36;D:\server\python\python36\Scripts;C:\Program Files (x86)\Microsoft Visual Studio\Shared\14.0\VC\bin\amd64;C:\Program Files\dotnet\;D:\server\MinGW\mingw-w64\x86_64-7.1.0-posix-seh-rt_v5-rev2\mingw64\bin;D:\server\bin;C:\Users\Yao\AppData\Local\Microsoft\WindowsApps;C:\Users\Yao\AppData\Roaming\npm;C:\Program Files (x86)\Microsoft VS Code\bin;C:\Users\Yao\AppData\Local\Programs\Fiddler;D:\server\bin set QINIU_ACCESS_KEY=DraImie8qSbwoPoyrHV38lfTnVr9aj8S487egGsC set QINIU_SECRET_KEY=62PYqPKVBwFIHvObxdrzeRcqB7Ep_ufpqTXLZ_8b  args
 -ak=DraImie8qSbwoPoyrHV38lfTnVr9aj8S487egGsC -sk=62PYqPKVBwFIHvObxdrzeRcqB7Ep_ufpqTXLZ_8b -domain=http://doc.yqjdcyy.com -bucket=document -path=C:\Users\Yao\Desktop\76aaa869ly1fi6n1duxn5j21dw0kak5a.jpg   </content>
    </entry>
    
     <entry>
        <title>Herman Miller</title>
        <url>http://domain.yqjdcyy.com/post/herman-miller/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>品牌</tag>
        </tags>
        <content type="html">  Herman Miller 参考  Herman Miller 官网  里程碑  60s  行动式办公室  Action Office Robert Propst 开放式办公屏风系统   1976  Ergon  1984  Equa  1994  Aeron 网椅  近期  Embody   推荐 Aeron  价位  天猫 Herman Miller 新款 Aeron【高端配置】 天猫 Herman Miller Aeron 座椅 标准配置（骶骨承托） 京东 Herman Miller 新款 Aeron【高端配置】-14天内发货 抛光底座/碳灰织物 大号 京东 Herman Miller Aeron 座椅 标准配置（骶骨承托） 碳黑色 中号  参考  Aeron座椅  欣赏        Embody  价位  天猫 Herman Miller Embody 座椅 标准配置【Rhythm织物】 京东 Herman Miller Embody 座椅 【Rhythm织物】 Rhythm织物\纯黑色 钛合金底座/白框  参考  Embody座椅  欣赏        T2  价位  [暂无]()  参考  T2  欣赏        Envelop办公桌  价位  天猫 Herman Miller Envelop 书桌【脚垫\部分现货】  参考  Envelop办公桌  欣赏       产品线 座椅  参考  座椅  系列  工作椅 主管椅 多用途/客椅 堆叠座椅 高脚凳 休闲座椅 公共座椅 长凳 户外座椅   工作空间  参考  工作空间  系列  个人工作站 私人办公室 办公桌 协作式家具 分隔屏风   桌子  参考  桌子  系列  会议桌 高度可调桌子 餐桌 多功能桌 户外桌子   储物  参考  储物  系列  配件  参考  配件  系列  人体工程学配件 照明 办公桌配件 装饰品   经典系列  参考  HermanMiller Collection    </content>
    </entry>
    
     <entry>
        <title>Go.交叉编译</title>
        <url>http://domain.yqjdcyy.com/post/go.%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  Go.交叉编译 参考  交叉编译 Golang 交叉编译 go tool cgo Golang 在 Mac、Linux、Windows 下交叉编译  作用  Go作为编译型语言，在不同平台上需要编译生成不同格式的二进制包  参数  GOOS  程序构建目标环境的操作系统  GOARCH  程序构建目标环境的计算机架构  CGO_ENABLED  当值为 0 时表示设置 CGO 不可用   示例 Linux 64bit  GOOS=linux GOARCH=amd64 go build -o app.linux  -o 用于指定二进制文件名   Linux 32bit  GOOS=linux GOARCH=386 go build  windows 64bit  GOOS=windows GOARCH=amd64 go build  windows 32bit  GOOS=windows GOARCH=386 go build  Mac OS 64bit  GOOS=darwin GOARCH=amd64 go build  备注  CGO  GO 语言自带工具，用于支持调用 C 语言代码的 GO 语言源码文件  1.5 以前版本需提交配置交叉编译环境  CGO_ENABLED=0 GOOS=linux GOARCH=amd64 ./make.bash   </content>
    </entry>
    
     <entry>
        <title>Linux.Run</title>
        <url>http://domain.yqjdcyy.com/post/linux.run/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  命令后台运行 参考  Linux 技巧：让进程在后台可靠运行的几种方法 linux命令后台运行 nohup命令 fg命令  类型  后台运行，终端关闭时停止 后台运行，终端关掉后仍继续运行  方法 前后台切换  流程  执行复杂语句 使用 Ctrl&#43; Z 挂起复杂程序  [1]&#43; Stopped /data/service/webapps/engine-dev/main  使用 jobs 查询后台工作情况  [1]&#43; Stopped /data/service/webapps/engine-dev/main  输入 fg 1 继续执行复杂语句 输入 bg 1 在后台继续执行语句  [1]&#43; /data/service/webapps/engine-dev/main jobs  [1]&#43; Running /data/service/webapps/engine-dev/main     后台执行  &amp;amp;  后台运行，终端关闭时停止  当前终端 shell 进程退出，会发送 hangup 信号给所有子进程 子进程收到 hangup 后退出  日志仍会打印到前台 示例  /data/service/webapps/engine-dev/main &amp;amp; /data/service/webapps/engine-dev/main &amp;gt; out.file 2&amp;gt;&amp;amp;1 &amp;amp;  2&amp;gt;&amp;amp;1  将所有标准输出和错误输出重定向到 out.file     nohup  后台运行，终端关掉后  不受当前 shell 退出影响 no hang up    </content>
    </entry>
    
     <entry>
        <title>Linux.目录与权限</title>
        <url>http://domain.yqjdcyy.com/post/linux%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%9D%83%E9%99%90/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Linux 的目录与权限 参考  Linux 的文件权限与目录配置 理解inode Linux下 通过删除inode来删除文件  使用者与群组  文件拥有者 群组  当前拥有者所在群组其它成员权限  其它人  非当前拥有者所在群组成员的权限   文件权限 文件属性  示例  drwxr-xr-x 2 root root 4096 Aug 24 09:17 wechat-forum-dev  解析  (d)(rwx)(r-x)(r-x)  档案类型、权限 (1)  文件类型  d  目录  -  文件  l  link file  b  装置文件中可供存储的接口设备  c  装置文件中的串行端口设备，如键盘、鼠标    (2)  文件拥有者权限 三位固定代表是否可以读、写、执行 其中指定位上若无权限，则以-表示  (3)  同群组用户权限  (4)  非本群组用户权限   2  连结数 硬连接到此 inode 文件的数量  root  档案拥有者  root  档案所属群组  4096  档案大小，单位为字节  Aug 24 09:17  最后修改时间  wechat-forum-dev  档案名称    补充 inode  概念  inode  存储文件元信息  文件字节数 拥有者用户 ID 文件的组 ID 读、写、执行权限 时间戳  ctime  inode 上次变动时间  mtime  文件内容上次变动时间  atime  上次打开时间   链接数  多少个文件名指向这个 inode block 位置    Block  8* Sector  Sector  扇区 文件在硬盘中的最小存储单元 512 B   查看  stat file  查看文件的 inode 信息  ls -il  查看 inode 号码   补充  移动、重命名，更新文件名，不影响 inode  ls -i find ./ -inum &amp;lt;inode&amp;gt; -exec rm -i {} \;  文件名包含特殊字符，无法删除，但删除 inode 节点仍起到删除作用   硬链接  概念  多个文件名指向同一 inode 更新文件的连结数  指令  ln 已存在文件 硬链接文件   软链接  概念  A/B 文件的 inode 不一致，但读 A 时自动导向到 B 删除 B 后，访问 A 时会报错 不更新链接数  指令  ln -s 已存在文件或目录 软链接文件或目录   </content>
    </entry>
    
     <entry>
        <title>IDEA.MyBatisCodeHelper</title>
        <url>http://domain.yqjdcyy.com/post/idea.mybatiscodehelper/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>IDEA</tag>
        </tags>
        <content type="html">  IDEA.MyBatisCodeHelper 参考  MyBatisCodeHelper MyBatisCodeHelper 1.2 发布，极大提升效率  描述  根据 JavaBean 生成 MyBatis 和 SQL.Create 更新方法名生成表单操作  使用  详见参考二中动态图  </content>
    </entry>
    
     <entry>
        <title>Linux.Maven</title>
        <url>http://domain.yqjdcyy.com/post/linux.maven/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Maven</tag>
        </tags>
        <content type="html">  参考  Installing Apache Maven Maven - 环境配置 apache-maven-3.5.0-bin.zip apache-maven-3.5.0-bin.tar.gz  流程 Java.config  check $JAVA_HOME  Maven.config  UNZIP  /data/soft/apache-maven-3.5.0  EXPORT.ADD  /etc/profile  export M2_HOME=/data/soft/apache-maven-3.5.0 export M2=$M2_HOME/bin export MAVEN_OPTS=&#39;-Xms256m -Xmx512m&#39; export PATH=${PATH}:${M2}   EXPORT.SAVE  source /etc/profile  CHECK  mvn -v  MAVEN.CONFIG  /data/soft/apache-maven-3.5.0/conf/settings.xml  &amp;lt;localRepository&amp;gt;/data/soft/apache-maven-3.5.0/repo&amp;lt;/localRepository&amp;gt;    常用指令  clean install -Dmaven.test.skip=true -Dmaven.repo.local=/data/.m2 -X  显示 Debbug 信息   </content>
    </entry>
    
     <entry>
        <title>Linux.Tomcat</title>
        <url>http://domain.yqjdcyy.com/post/linux.tomcat/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Tomcat</tag>
        </tags>
        <content type="html">  参考  tomcat中server.xml配置详解 Tomcat server.xml配置示例 service.xml  软件  java tomcat  scp -rv /data/service/tomcat root@39.108.103.85:/data/service/tomcat   目录结构  data  service  bin  运行脚本  wechat-forum-dev-start.sh wechat-forum-dev-stop.sh deploy-instance.sh   logs  wechat-forum-dev  catalina.2017-08-15.log catalina.2017-08-15.out host-manager.2017-08-15.log localhost_access_log.2017-08-15.txt manager.2017-08-15.log  wechat-forum-dev_gc.log  run  wechat-forum-dev.pid  9015   tomcat  bin  启动、运行的相关二进制启动脚本 startup.sh shutup.sh version.sh  CATALINA_BASE  实例运行目录  CATALINA_HOME  安装目录  CATALINA_TMPDIR JRE_HOME CLASSPATH   conf  catalina.policy  安全策略  catalina.properties logging.properties server.xml  主配置文件  context.xml  特殊配置全局选项  tomcat-users.xml  授权访问用户配置  tomcat-users.xsd  授权用户名、密码格式限制  web.xml  web 应用全局配置描述   lib  启动的所需 Jar-file  logs webapps work temp  webapps  wechat-forum-dev  conf logs temp webapps work      备注 辅助脚本  scp -r /data/service/bin/deploy-instance.sh* root@39.108.103.85:/data/service/bin scp -r /data/service/webapps/basic-portal/conf root@39.108.103.85:/data/service/webapps/wechat-forum-dev  </content>
    </entry>
    
     <entry>
        <title>Mysql.SELECT-INTO</title>
        <url>http://domain.yqjdcyy.com/post/mysql.select-into/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Mysql</tag>
        </tags>
        <content type="html">  参考  SELECT &amp;hellip; INTO Syntax MySQL下SELECT…INTO OUTFILE导出文本文件命令 mysql导入数据load data infile用法 SELECT INTO OUTFILE  命令  SELECT ... INTO
 VAR_LIST  将栏目值存储至变量 栏目值需与变量名数据一致 仅返回一条记录  无数据返回，则报 Error（1329） 多行记录返回，则报 Error（1172） 建议使用 LIMIT 1   OUTFILE  将选择栏目值存储至文件 存储于服务器，需持有文件权限 文件路径不能为已存在文件  客户端执行 mysql -e &amp;quot;SELECT ...&amp;quot; &amp;gt; file_name 导出文件  文件格式使用情况  .txt  数据会以 TAB 间隔  csv  csv格式，但数据均存储至同一单元格内    DUMPFILE  将单行数据以任意形式文件导出   OUTPUT FORMAT
 FIELDS  TERMINATED BY &amp;lsquo;分隔符，默认 \t&amp;lsquo; ENCLOSED BY &amp;lsquo;字段括起字段，默认 \&amp;lsquo; ESCAPED BY &amp;lsquo;转义字符&amp;rsquo;  OPTIONALLY  ENCLOSED BY &amp;ldquo;  LINES  TERMINATED BY &amp;lsquo;默认 \n&amp;lsquo;    实例  VAR_LIST
SELECT id, data INTO @x, @y FROM test.t1 LIMIT 1; OUTFILE
 查看权限目录
mysql&amp;gt; show variables like &amp;#39;datadir&amp;#39;; &#43;---------------&#43;-------------------&#43; | Variable_name | Value | &#43;---------------&#43;-------------------&#43; | datadir | /data/mysql/data/ | &#43;---------------&#43;-------------------&#43; 导出数据
select e.id, e.name, q.id, q.content, o.content, o.true_flag, u.user_name, if(a.option_id is not null, if(a.option_id= o.id, o.content, &amp;#39;&amp;#39;), a.reply) as reply INTO OUTFILE &amp;#39;/data/mysql/tmp/2758.txt&amp;#39; from question_options o inner join question q on o.question_id= q.id and q.deleted= 0 inner join exercises e on q.exercises_id= e.id and e.rel_id= 906 and e.rel_type = 2 and e.type = 0 and e.used= 1 left join question_answer a on q.id= a.question_id left join user u on a.user_id = u.id order by e.id, q.id, a.user_id; 格式化导出数据
select e.id, q.id, u.user_name, if(a.option_id is not null, o.content , a.reply) as reply INTO OUTFILE &amp;#39;/data/mysql/data/2758.txt&amp;#39; COLUMNS ENCLOSED BY &amp;#39;|&amp;#39; LINES STARTING BY &amp;#39;|&amp;#39; TERMINATED BY &amp;#39;|\n&amp;#39; from question_answer a inner join user u on a.user_id = u.id left join question_options o on a.option_id= o.id and o.deleted= 0 inner join question q on a.question_id= q.id and q.deleted= 0 inner join exercises e on q.exercises_id= e.id and e.deleted= 0 and e.id in (12506,12507,12508,12509,12525,12523) order by e.id, q.id, a.user_id;   补充 导入数据  语句
load data infile &amp;#39;/tmp/t0.txt&amp;#39; ignore into table t0 character set gbk fields terminated by &amp;#39;,&amp;#39; enclosed by &amp;#39;&amp;#34;&amp;#39; lines terminated by &amp;#39;\n&amp;#39; (`name`,`age`,`description`); 指令
 character set gbk  必输，避免乱码  ignore into table  比如 name 列加了唯一索引，可避免重复插入报错    </content>
    </entry>
    
     <entry>
        <title>Linux.Firewalld</title>
        <url>http://domain.yqjdcyy.com/post/linux.firewalld/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  firewalld 参考  CentOS 7 为firewalld添加开放端口及相关资料 使用FirewallD替代Iptables的一些配置  指令 常见  添加端口  firewall-cmd --permanent --zone=public --add-port=3306/tcp  重启  firewall-cmd --reload  添加服务  firewall-cmd --permanent --add-service=mysql   所有  通用
 firewall-cmd [--zone=&amp;lt;zone&amp;gt;] --add-port=&amp;lt;port&amp;gt;[-&amp;lt;port&amp;gt;]/&amp;lt;protocol&amp;gt; [--timeout=&amp;lt;seconds&amp;gt;]  运行
 查看运行状态  systemctl status firewalld.service  开关  systemctl [stop|start] firewalld firewall-cmd --reload  服务相关  firewall-cmd --list-services firewall-cmd --[add|remove]-service=mysql firewall-cmd --permanent --[add|remove]-service=mysql  端口相关  firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --zone=public --list-ports firewall-cmd --zone=public --query-port=3306/tcp   开机启动
 设置开机启动  systemctl enable firewalld.service  检查是否开机启动  systemctl is-enabled firewalld.service   相关配置
 /etc/firewalld/firewalld.conf  DefaultZone  drop block public external dmz work home internal trusted   /etc/firewalld/zones/public.xml   </content>
    </entry>
    
     <entry>
        <title>Linux.Mysql</title>
        <url>http://domain.yqjdcyy.com/post/linux.mysql/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Mysql</tag>
        </tags>
        <content type="html">  参考  centos7 mysql数据库安装和配置 CentOS 7 安装 MySQL Linux下安装MySQL centos7 mysql数据库安装和配置  环境  Linux  LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 7.3.1611 (Core) Release: 7.3.1611 Codename: Core   安装 默认  yum install mysql yum install mysql-server yum install mysql-devel ### wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql-community-server mysql_upgrade  初始化 Mysql 初始化  mysql_secure_installation  直接设置密码  set password for &#39;root&#39;@&#39;localhost&#39; =password(&#39;root.password&#39;);  启动 服务启动  systemctl  systemctl start mysqld systemctl status mysqld systemctl stop mysqld  service  service mysqld start service mysqld stop service mysqld status service mysqld restart   开机启动  systemctl enabled mysql systemctl is-enabled mysql  防火墙  firewalld  firewall-cmd --permanent --zone=public --add-port=3306/tcp firewall-cmd --permanent --zone=public --add-port=3306/udp firewall-cmd --reload   环境准备 创建数据库  mysql -uroot -p  root.password  create database wechat_forum; create database wechat_forum_dev;  创建账号&amp;amp; 分配权限  grant all privileges on *.* to root@&#39;%&#39;identified by &#39;root.password&#39;;
 CREATE USER &#39;appuser&#39;@&#39;%&#39; IDENTIFIED BY &#39;appuser.password&#39;;
 GRANT ALL ON wechat_forum_dev.* TO &#39;appuser&#39;@&#39;%&#39;;
 GRANT ALL ON wechat_forum.* TO &#39;appuser&#39;@&#39;%&#39;;
 flush privileges;
 mysql -uappuser -p
 appuser.password   异常排查 set password 失败  提示  ERROR 1558 (HY000): Column count of mysql.user is wrong. Expected 43, found 42. Created with MySQL 50552, now running 50637. Please use mysql_upgrade to fix this error.  解决  mysql_upgrade   3306 无法对外开放  which mysqld  /usr/sbin/mysqld  /usr/sbin/mysqld --verbose --help | grep -A 1 &#39;Default options&#39;  Default options are read from the following files in the given order: /etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf  netstat -ntlp  Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2129/sshd tcp6 0 0 :::3306 :::* LISTEN 9414/mysqld  阿里云 ECS 需要对外开放端口！  备注 查看 Linux 版本  lsb_release -a  查看 Mysql 版本  mysql -V  </content>
    </entry>
    
     <entry>
        <title>Hello.Binary.Tree</title>
        <url>http://domain.yqjdcyy.com/post/hello.binary.tree/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Algorithm</tag>
        </tags>
        <content type="html">  类型 二叉树  定义  每个结点最多有两个子树的树结构  图示    遍历  DLR LDR LRD  存储  顺序存储  left: 2* n&#43; 1 right: 2* n&#43; 2 parent: (n-1)/ 2  链表存储   二叉排序树  性质  左子树所有结点均小于其根结点的值 右子树所有结点均大于其根结点的值 左右子树亦为二叉排序树 无键值相等的节点  图示     AVL树  定义  自平衡二叉排序树  性质  每个结点的左右子树调度之差的绝对值最多为1  图示      红黑树  定义  自平衡二叉排序树  性质  节点是红色或黑色 根节点是黑色 叶节点是黑色 红色节点的子节点均为黑色 从任一节点到其各叶子节点的所有路径，都包含相同数目的黑色节点  注意  插入元素均为红色，然后再通过变色、旋转进行调整  图示  详见整理   参考 参考  二叉树 二叉排序树 AVL树 红黑树 红黑树  整理  红黑树.xmind  </content>
    </entry>
    
     <entry>
        <title>Dump.Analyze</title>
        <url>http://domain.yqjdcyy.com/post/dump.analyze/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Dump</tag>
        </tags>
        <content type="html">  使用  安装 Dump 包分析软件 安装完成后进行初始化设置  设置【File/ Symbol file path】的属性值为【D:\MyCodesSymbols;SRV*c:\symbols*http://symbols.mozilla.org/firefox; SRV*D:\MyLocalSymbols*http://msdl.microsoft.com/download/symbols;C:Windowssymbols】  编辑 vbs 文件，调整 windbg 执行目录 双击执行，并输入任务管理器中的指定监控软件的 PID 值 操作软件，并至崩溃状态（崩溃后会自动启动 windbg 进行 Dump 包存储） 开启 windbg x86 程序，并打开该 Dump 包（File/ Open Crash Dump） 待加载完成后输入【~* kp】显示异常堆栈 输入【!analyze -v -f】分析具体异常  资源  X86 Debuggers And Tools-x86_en-us.msi crashdump.vbs 命令集合.xlsx  </content>
    </entry>
    
     <entry>
        <title>Git.Install</title>
        <url>http://domain.yqjdcyy.com/post/git.install/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Git</tag>
        </tags>
        <content type="html">  Git 安装 参考  GotGitHub git - 简易指南 GitHub Help Git教程  安装 Windows  git config --global user.name wrrwhn git config --global user.email yqjdcyy@gmail.com git config --global alias.gcf git config ssh-keygen  创建公钥/私钥对（id_rsa.pub/id_rsa） - 注意，不要有空格！！！  ssh-keygen -C &amp;quot;yqjdcyy@gmail.com&amp;quot; -f ~/.ssh/yqjdcyy  创建gotgithub公私钥对   Linux  yum install git git-svn git-email git-gui gitk git --version git config --global user.name &amp;quot;wrrwhn&amp;quot; git config --global user.email yaoqingju@gmail.com cat ~/.gitconfig  注  git 2.0 版本安装后生成 ssh-key 的方式建议使用 ssh-keygen -t rsa -C &amp;ldquo;humingx@yeah.net&amp;rdquo;，然后三个回车搞定。  </content>
    </entry>
    
     <entry>
        <title>Java.Basic</title>
        <url>http://domain.yqjdcyy.com/post/java.basic/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  参考  使用 JDK 5 后的线程并发，Callable, Future, ExecutorServie Lock(重入锁，读写锁)及Condition示例 Java中的锁  功能 获取路径 分类  绝对路径  主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 例  C:xyz est.txt  代表了test.txt文件的绝对路径    相对路径  相对与某个基准目录（一般对照WEB）的路径。 示例  &amp;quot;/&amp;quot;代表Web应用的跟目录 &amp;quot;./&amp;quot; 代表当前目录 &amp;quot;../&amp;quot;代表上级目录   注  JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的   获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&amp;quot;？&amp;quot;) --&amp;gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&amp;quot;\&amp;quot;) //站点绝对路径 application.getRealPath(&amp;quot;&amp;quot;) //JSP界面使用 ServletContext().getRealPath(&amp;quot;&amp;quot;)  返回字串  C:\Apache\Tomcat\webapps\local&#43; （\ \. 空格 \web.xml）   工程Classes下路径（SRC/CLASS）  使用环境  SERVLET/JSP/JAVA（即任意CLASS）  使用语句  this.getClass()/JdomParse.class .getClassLoader().getResource(&amp;quot;&amp;quot;).getPath();
 因为三者均为JAVA程序，都为CLASS，故为三者通用方法  this.getClass()JdomParse.class .getResource(&amp;quot;&amp;quot;).getPath().toString();  可用于不同WEB环境来确认路径  Thread.currentThread().getContextClassLoader().getResource(&amp;quot;&amp;quot;).getPath()  返回字串  /D:/workspace/strutsTest/WebRoot/WEB-INF/classes/ /D:/workspace/strutsTest/WebRoot/WEB-INF/classes/bl/ /E:/order/002_ext/WebRoot/WEB-INF/classes/   系统路径  使用环境  APPLICATION/SERVLET/JSP  使用语句  System.getProperty(&amp;quot;user.dir&amp;quot;)  相对项目（JAVA为项目，WEB依工具而定）路径  ServletContext servletContext = config.getServletContext(); String rootPath = servletContext.getRealPath(&amp;quot;/&amp;quot;); application.getRealPath(&amp;quot;&amp;quot;)  返回字串  WEB根上下文环境（即相对路径）  使用环境  于SERVLET的INIT中 于httpServletRequest中  使用语句  request.getContextPath()getRealPath(&amp;quot;/&amp;quot;); request.getSession().getServletContext().getRealPath(&amp;quot;/&amp;quot;);  返回字串  D:\工具\Tomcat-6.0\webapps\002_ext\ （其中002_ext为项目名称） request.getContextPath() -&amp;gt; web项目名   站点虚拟路径  使用环境 使用语句  getContextPath():  返回字串  类加载器路径  使用环境 使用语句  class.getClassLoader.getPath()；  InputStream is=TestAction.class.getClassLoader().getResourceAsStream(&amp;quot;test.txt&amp;quot;); InputStream is=Test1.class.getResourceAsStream(&amp;quot;/test.txt&amp;quot;);   返回字串  均返回指定路径文件（\src\test.txt）的装载项目  注意  不论是一般的java项目还是web项目,先定位到能看到包路径的第一级目录（TestAction在其中）   泛型 介绍  重复代码重构，于编译时检测类型安全，保存所有强制类型均为自动或隐式，提高代码重用率
规则 明细
 泛型参数允许多个，且仅能为类类型，不能为简单类型 泛型参数支持extends(有办类型)或通配符类型 支持类型有泛型类、接口和方法  实例
 泛型
class Gen&amp;lt;T&amp;gt; { private T ob; //定义泛型成员变量 public Gen(T ob) { this.ob = ob; } public T getOb() { return ob; } public void setOb(T ob) { this.ob = ob; } public void showType() { System.out.println(&amp;#34;T的实际类型是: &amp;#34; &#43; ob.getClass().getName()); } } public class GenDemo { public static void main(String[] args){ //定义泛型类Gen的一个Integer版本 Gen&amp;lt;Integer&amp;gt; intOb=new Gen&amp;lt;Integer&amp;gt;(88); intOb.showType(); int i= intOb.getOb(); System.out.println(&amp;#34;value= &amp;#34; &#43; i); //定义泛型类Gen的一个String版本 Gen&amp;lt;String&amp;gt; strOb=new Gen&amp;lt;String&amp;gt;(&amp;#34;Hello Gen!&amp;#34;); strOb.showType(); String s=strOb.getOb(); System.out.println(&amp;#34;value= &amp;#34; &#43; s); } } 泛型方法
public static &amp;lt;T&amp;gt; T display(T t) { return t; }   JMX 参考  介绍 Tomcat配置 入门示例 官方事例 官方教程 Using JConsole  组成  Instrumentation  使用MBean在遵循JMX规范中定义的设计模式和接口的基础上，确保提供标准化管理资源的仪表。 MXBean为在MBean的基础上预定义了一组数据类型。  JMX agent  直接操作资源并使之于远程应用上生效，其核心部件为MBean server。  Remote management  通过协议适配器和连接器支持JVM提供外部JMX agent   监控管理 平台MXBeans和平台MBean Server  平台MXBeans  用监视和管理JVM及运行时环境的的组件，功能包括类加载系统，即时编译系统和垃圾回收等平台。并保证不同环境下的JVM使用统一规范。  平台MBean Server  用于注册管理平台MXBeans或自行创建的MBeans。   JConsole  介绍  java自带(JAVA_HOME/bin/jconsole.exe)可视化监控管理工具，可查看Java平台上运行的程序的性能和资源消耗的信息。 监控本地和远程JVM、java应用程序的可视化监督工具，使用JMX技术实现。  推荐  使用指导  参见参考中的「Using JConsole」   异常  描述  jConsole的MXBean树显示不合理  事例  MXBean列表 com.sun.example:type=Triangle,side=isosceles,name=1 com.sun.example:type=Triangle,name=2,side=isosceles com.sun.example:type=Triangle,side=isosceles,name=3 树形结构 |-com.sum.example |-Triangle |-isosceles |-1 |-3 |-2 |-isosceles  解决  补充-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=type,side,name，指定关键字的顺序    MBeans介绍  概念  类似于JavaBean，并可管理所有需要管理的应用、资源和设备。  组成  一系列可读可写属性 一系列可调用方法 自行描述  分类  Standard MBeans Dynamic MBeans Open MBeans Model MBeans MXBeans  实例
 标准MBean= todoMBean接口（定义所有方法属性）&#43; todo实现
public interface HelloMBean { // todoMBean接口 // 规范要求接口必须以 dosome&#43; MBean为名称 public String getName(); //只读 public int getCacheSize(); //可读可写 public void setCacheSize(int size); } public class Hello implements HelloMBean { //todo实现 private final String name = &amp;#34;Reginald&amp;#34;; private int cacheSize = DEFAULT_CACHE_SIZE; private static final int DEFAULT_CACHE_SIZE = 200; public String getName() { return this.name; } public int getCacheSize() { return this.cacheSize; } public synchronized void setCacheSize(int size) { this.cacheSize = size; System.out.println(&amp;#34;Cache size now &amp;#34; &#43; this.cacheSize); } } MXBean= 可支持任意客户端（包括远程）。
 命名不一定要为todoMXBean，可使用@MXBean注解
public interface QueueSamplerMXBean { //MXBean接口 public QueueSample getQueueSample(); public void clearQueue(); } public class QueueSampler implements QueueSamplerMXBean { //定义QueueSamplerMXBean实现 private Queue&amp;lt;String&amp;gt; queue; public QueueSampler (Queue&amp;lt;String&amp;gt; queue) { this.queue = queue; } public QueueSample getQueueSample() { //自定义返回类型 synchronized (queue) { return new QueueSample(new Date(), queue.size(), queue.peek()); } } public void clearQueue() { synchronized (queue) { queue.clear(); } } }  通知
 用于反馈状态改变、事件或问题异常 必须实现 NotificationEmitter 或继承 NotificationBroadcasterSupport 实现 Notification 或子类如 AttributeChangedNotification
public class Hello extends NotificationBroadcasterSupport implements HelloMBean { public synchronized void setCacheSize(int size) { Notification n = new AttributeChangeNotification(this, sequenceNumber&#43;&#43;, System.currentTimeMillis(), &amp;#34;CacheSize changed&amp;#34;, &amp;#34;CacheSize&amp;#34;, &amp;#34;int&amp;#34;, oldSize, this.cacheSize); sendNotification(n); } @Override public MBeanNotificationInfo[] getNotificationInfo() { String[] types = new String[]{ AttributeChangeNotification.ATTRIBUTE_CHANGE }; String name = AttributeChangeNotification.class.getName(); String description = &amp;#34;An attribute of this MBean has changed&amp;#34;; MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description); return new MBeanNotificationInfo[]{info}; } }    远程管理  概念  JMX API 允许通过JMX连接器（服务端和客户端组成）远程管理个人资源，并定义了远程方法调用（RMI）基础上标准连接协议。 需要应用配置以正常的参数，具体可参见【Tomcat本地JMX监控】或如下例  指令调用  javac com/example/*.java //编译java文件 java -Dcom.sun.management.jmxremote.port = 9999  -Dcom.sun.management.jmxremote.authenticate = false  -Dcom.sun.management.jmxremote.ssl = false  com.example.Main //启动时配置调用端口等信息
   启动要求  java1.5  命令行指定JMX才会启动。  java1.6  默认启动JMX。  注  jConsole可通过pid（进程ID）进行JMX管理，其中内部将pid转换为JMX URL。   调用  //RMI&#43; 连接&#43; MBeanServer获取 JMXServiceURL url =new JMXServiceURL(&amp;quot;service:jmx:rmi:///jndi/rmi://:9999/jmxrmi&amp;quot;); JMXConnector jmxc = JMXConnectorFactory.connect(url, null); MBeanServerConnection mbsc = jmxc; //明确的MBean或MXBean - 代理调用 ObjectName mbeanName = new ObjectName(&amp;quot;com.example:type=Hello&amp;quot;); HelloMBean mbeanProxy = JMX.newMBeanProxy(mbsc, mbeanName, HelloMBean.class, true); 或 OperatingSystemMXBean osBean= ManagementFactory.newPlatformMXBeanProxy(mbsc, ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME, OperatingSystemMXBean.class); mbeanProxy.getCacheSize(); //调用方法和属性 //未明确MBean或MXBean情况 ObjectName objectName= new ObjectName(appName&#43; &amp;quot;:name=MuleContext&amp;quot;); //获取属性 String status= mbsc.getAttribute(objectName, &amp;quot;Stopped&amp;quot;).toString(); mbsc.invoke(object, action, param, signature); //调用方法  连接方式整理  MBeanServerFactory.createMBeanServer();  //ManagementFactory.getPlatformMBeanServer()第一次调用时会默认调用上述方法 ObjectName name = new ObjectName(&amp;quot;book.liuyang:service=Counter&amp;quot;); server.registerMBean(new Counter(), name); // 可见Domain为JMImplementation  getMBeanServerConnection()  JMXConnectorFactory.connect( new JMXServiceURL(&amp;quot;service:jmx:rmi:///jndi/rmi://:9999/jmxrmi&amp;quot;), null ).getMBeanServerConnection();   可见Domain为 JMImplementation,com.sun.management,Catalina,java.nio,org.apache.commons.pool2,java.lang,java.util.logging    JVM运行情况 - JMX  监控双方于同一JVM  MBeanServer server = ManagementFactory.getPlatformMBeanServer(); RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(server, &amp;quot;java.lang:type=Runtime&amp;quot;, RuntimeMXBean.class);  监控双方位于不同JVM  被监控JVM补充JVM代码启动参数  -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=127.0.0.1:8000 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false  连接代理  JMXServiceURL url = new JMXServiceURL(&amp;quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:8000/jmxrmi&amp;quot;); JMXConnector connector = JMXConnectorFactory.connect(url); RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(connector.getMBeanServerConnection(),&amp;quot;java.lang:type=Runtime&amp;quot;, RuntimeMXBean.class);   监控双方位于不同JVM，但处于同一物理主机(Java Instrutment&amp;amp; Attach API)
 通过Attach到被监控的JVM进程，并在被监控的JVM中启动一个JMX代理，然后使用该代理通过2的方式连接到被监控的JVM的JMX上。
//Attach 到5656的JVM进程上，后续Attach API再讲解 VirtualMachine virtualmachine = VirtualMachine.attach(&amp;#34;5656&amp;#34;); //让JVM加载jmx Agent，后续讲到Java Instrutment再讲解 String javaHome = virtualmachine.getSystemProperties().getProperty(&amp;#34;java.home&amp;#34;); String jmxAgent = javaHome &#43; File.separator &#43; &amp;#34;lib&amp;#34; &#43; File.separator &#43; &amp;#34;management-agent.jar&amp;#34;; virtualmachine.loadAgent(jmxAgent, &amp;#34;com.sun.management.jmxremote&amp;#34;); //获得连接地址 Properties properties = virtualmachine.getAgentProperties(); String address = (String)properties.get(&amp;#34;com.sun.management.jmxremote.localConnectorAddress&amp;#34;); //Detach virtualmachine.detach(); JMXServiceURL url = new JMXServiceURL(address); JMXConnector connector = JMXConnectorFactory.connect(url); RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(connector.getMBeanServerConnection(), &amp;#34;java.lang:type=Runtime&amp;#34;,RuntimeMXBean.class);    TOMCAT本地JMX监控  参考  http://sharpspeed.iteye.com/blog/2009770  windows  系统配置  windows7 64位 java 1.7.0_55 tomcat 7.0.54  配置修改  D:\Program Files\Apache\Tomcat\apache-tomcat-7.0.54\bin\catalina.bat 于:doRun节点下补充  set JMX_REMOTE_CONFIG=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=true -Dcom.sun.management.jmxremote.port=9999 - -Dcom.sun.management.jmxremote.ssl=false-Dcom.sun.management.jmxremote.authenticate=false set CATALINA_OPTS=%CATALINA_OPTS% %JMX_REMOTE_CONFIG%  其中port为代码连接端口，与jConsole中列举的端口不一致 若需要鉴权，则请将authenticate设置为true，并调整鉴权相同配置，具体可见参考内容  连接测试  String rmi= &amp;quot;service:jmx:rmi:///jndi/rmi://localhost:9999/jmxrmi&amp;quot;; JMXServiceURL serviceURL = new JMXServiceURL(rmi); conn = JMXConnectorFactory.connect(serviceURL); conn.getMBeanServerConnection();   Linux  系统配置  CentOS 6.5 java 1.6.0_33 tomcat 7.0.54Z  配置修改（含tomcat安装）  cd /data/test/download/targz rz #上传apache-tomcat-7.0.54.tar.gz tar -xzf apache-tomcat-7.0.54.tar.gz cd apache-tomcat-7.0.54/bin vi catalina.sh /Execute The Requested Command 于当行后补充 CATALINA_OPTS=&amp;quot;$CATALINA_OPTS -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&amp;quot;  且注意上例代码不能折行！！  ESC :wq ./startup.sh rz #上传测试执行文件jmx.jar  连接测试  java -jar /data/test/download/targz/apache-tomcat-7.0.54/bin/jmx.jar    多线程 创建方法  继续Thread  public class ExtendThread extends Thread { public void run(){System.out.println(this.getName());} } new ExtendThread().start();  实现Runnable  public class ImpleRunnable implements Runnable { public void run(){System.out.println(this.getName());} } new Thread(new ImpleRunnable(),&amp;quot;Thread&amp;quot;).start();  注意  Runable非常适合多个相同线程来处理同一份资源的情况   生命周期  New新建  当线程被创建时，该线程处于新建状态，此时它和其他java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量的值。（此时的线程没有表现出任何表现出任何线程的动态特征，程序也不会执行线程的线程执行体） new Thread（）||new Thread（Runnable target，String name）。  Runnable就绪  就绪也就是说启动线程，调用start方法来启动线程，系统会将该run方法当成线程执行体来处理。如果直接调用线程对象的run方法。则run方法会立即执行，且在这个run方法的执行体未执行结束前其他线程无法并发执行（即系统会将run方法当做一个普通对- 象的普通方法，而不是线程执行体对待）  如果有一个主线程，一个子线程。当根据逻辑代码该调用子线程时不一定会立即调用，为了想在子线程start（）后立即调用子线程，可以考虑使用Thread.sleep（1），这样会让当前线程（主线程）睡眠1毫秒，因为cpu在这1毫秒中是不会休息的，- 这样就会去执行一条处于就绪状态的线程。 不能对已经处于就绪状态的线程，再次使用start（）   Running 运行  当处于就绪状态时，该线程获得cpu，执行体开始运行，就处于运行状态了  Blocked 阻塞  线程不可能一直处于运行状态（线程执行体足够短，瞬间就可以完成的线程排除），线程会在运行过程中需要被中断，因为是并发，目的是会让其他线程获得执行的机会，线程的调度细节取决于OS采用的策略。 （抢占式调度xp win7 linux - unix..）。 如果是一些特殊的小型设备可能采用协作式调度（只有线程自己调用它的sleep（）或yield（）才会放弃所占用的资源）。  Dead死亡  测试某条线程是否已经死亡，可以调用线程对象的isAlive（）方法，当线程处于就绪，运行，阻塞时，返回true。线程处于新建，死亡时返回false。 不能对已经死亡的线程调用start（）方法使它重新启动，死亡就是死亡，是不能再次作为线程执行的。  当主线程结束时候，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受到主线程的影响。  线程控制 JOIN  等待该线程结束后再往下执行 方法  Join（）  等待被join的线程执行完成  Join（long millis）  等待join线程的时间最长为millis毫秒，如果在这个时间内，被join的线程还没有执行结束则不再等待）  Join（long millis，int nanos）  千分之一毫秒（不用）   实例  JoinThread joinThread= new JoinThread(); new Thread(joinThread).start(); for(int i=0; i&amp;lt; 4; i&#43;&#43;) { Thread thread = new Thread(joinThread); thread.start(); thread.join(); //若只针对最后一个调用，则最后一个调用完成，可能其它线程还未完成也会继续往下执行而导致数据未完全 } for(int i=0; i&amp;lt; 3; i&#43;&#43;){ System.out.println(Thread.currentThread().getName() &#43; &amp;quot;\t&amp;quot; &#43; i); }  返回结果  Thread-0 0 Thread-1 0 Thread-0 1 Thread-1 1 Thread-1 2 Thread-0 2 Thread-2 0 Thread-2 1 Thread-2 2 Thread-3 0 Thread-3 1 Thread-3 2 main 0 main 1 main 2   后台进程  示例
JoinThread joinThread= new JoinThread(); Thread thread= new Thread(joinThread); thread.setDaemon(true); //必须于执行前设置。前台线程结束后，会再执行一段时间后台线程。 thread.start(); for(int i=0; i&amp;lt; 10; i&#43;&#43;){ System.out.println(Thread.currentThread().getName() &#43; &amp;#34;\t&amp;#34; &#43; i); } 返回结果
main 0 main 1 main 2 main 3 Thread-0 0 main 4 Thread-0 1 main 5 Thread-0 2 main 6 Thread-0 3 main 7 Thread-0 4 main 8 Thread-0 5 main 9 Thread-0 6 Thread-0 7 Thread-0 8 Thread-0 9 Thread-0 10 Thread-0 11 Thread-0 12  SLEEP  休眠，状态转阻塞  YIELD  线程让步，状态转就绪，让步于优先级相同或更高的线程  多线程同步 同步代码块 Synchronized(obj){ //...同步代码块 }  同步方法 public synchronized void draw(){ ...} 锁定释放时机  调用执行结束 break或return 代码中出现Error或Exception 代码中执行监视器对象的wait进行当前线程的暂停释放  不释放情况  调用Thread.sleep/yield 其它线程调用该线程的suspend将之挂起（不推荐使用）  同步锁LOCK private final ReentrantLock relock=new ReentrantLock(); //声明锁对象 public void run(){ relock.lock(); //加锁 try{ ... //同步执行代码 }finally{ //释放锁 relock.unlock(); } } 死锁  当两个线程相互等待对方释放同步监视器的时候就会发生死锁，一旦出现死锁，整个程序既不会发生任何异常，也不会有任何提示，只是所有线程处于阻塞状态，无法继续。  线程通信  线程协调运行  Object: wait()| notify()|| notifyAll()  使用条件变量来控制协调  Condition  await()|| signal()|| signalAll()  private final Lock lock=new ReentrantLock(); private final Condition cond=lock.newCondition();    管道流通信
 创建管道输入输出流  PipedWriter pw = new PipedWriter(); PipedReader pr = new PipedReader();  管道连接  pr.connect(pw);  将管理分别传入处理线程并调用实现  new Thread(new ReaderThread(pr),&amp;quot;读取管道线程&amp;quot;).start();  pw.write(str)  new Thread(new WriterThread(pw),&amp;quot;写入管道线程&amp;quot;).start();  while ((buffer = br.readLine()) != null)    线程组
 介绍  对线程组的控制相当于同时控制这批线程。 用户创建默认属于默认线程组，如子线程和创建它的主线程同处同一线程组。 一旦加入指定线程组，中途不允许调整。 Thread th=new Thread(new ThreadGroup(&amp;quot;私人&amp;quot;), new GroupThread(), &amp;quot;线程1&amp;quot;);    反射  机制  在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制  用途  在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法；  实例  主要针对框架开发，如jsp的javabean,spring的自动注入，hibernate及struts  代码
public class ReflectionTest { //测试变更属性，其中为了直观调用属性属性设置为public类型  public double field; public static void main(String[] args) { List2Obj(); } /*** * 构造函数（无参-默认&amp;amp; 带参） */ public ReflectionTest() {} public ReflectionTest(Double field) { this.field = field; } /** * 动态获取数据对象，可将多维数组的部分结构拼成对象来调用 */ public static void List2Obj(){ int dims[] = new int[]{5, 10, 15}; Object arr = Array.newInstance(Integer.TYPE, dims); Object arrobj = Array.get(arr, 3); Class cls = arrobj.getClass().getComponentType(); System.out.println(cls.getSimpleName()); arrobj = Array.get(arrobj, 5); Array.setInt(arrobj, 10, 37); int arrcast[][][] = (int[][][]) arr; System.out.println(arrcast[3][5][10]); } /*** * 调用参数的方法进行属性更新 */ public static void callFieldChange(){ Class c = null; try { c = Class.forName(&amp;#34;com.yao.controller.reflection.ReflectionTest&amp;#34;); Field field= c.getField(&amp;#34;field&amp;#34;); ReflectionTest reflect= new ReflectionTest(12.34D); System.out.println(reflect.field); field.setDouble(reflect, 43.21); System.out.println(reflect.field); }catch (Exception e){ e.printStackTrace(); } } /*** * 专门用于提供反射调用 * @param a 加数1 * @param b 加数2 * @return a&#43;b的结果 */ public int add(int a, int b){ return a&#43; b; } /*** * 调用本方法内的ADD方法 * Constructor方式与之相似 */ public static void callClassMethod(){ Class c = null; try { c = Class.forName(&amp;#34;com.yao.controller.reflection.ReflectionTest&amp;#34;); //指定方法和参数类型以获取类中对应的方法  Class types[]= new Class[2]; types[0]= Integer.TYPE; types[1]= Integer.TYPE; Method method= c.getMethod(&amp;#34;add&amp;#34;, types); //针对各参数位填充以实际数值  Object args[]= new Object[2]; args[0]= new Integer(1); args[1]= new Integer(2); Integer retVal= (Integer)method.invoke(c.newInstance(), args); System.out.print(retVal); }catch (Exception e){ e.printStackTrace(); } } /*** * 输出String类大致文档结构 */ public static void printClssInfo(){ Class c = null; try { c = Class.forName(&amp;#34;java.lang.String&amp;#34;); System.out.println(&amp;#34;package &amp;#34; &#43; c.getPackage().getName() &#43; &amp;#34;;&amp;#34;); System.out.print(Modifier.toString(c.getModifiers()) &#43; &amp;#34; &amp;#34;); System.out.print(&amp;#34;class &amp;#34; &#43; c.getSimpleName() &#43; &amp;#34; &amp;#34;); if (c.getSuperclass() != Object.class) { System.out.print(&amp;#34;extends &amp;#34; &#43; c.getSuperclass().getSimpleName()); } Class[] inters = c.getInterfaces(); if (inters.length &amp;gt; 0) { System.out.print(&amp;#34;implements &amp;#34;); for (int i = 0; i &amp;lt; inters.length; i&#43;&#43;) { System.out.print(inters[i].getSimpleName()); if (i &amp;lt; inters.length - 1) { System.out.print(&amp;#34;,&amp;#34;); } } } System.out.println(&amp;#34;{&amp;#34;); printFields(c); printMethods(c); System.out.println(&amp;#34;}&amp;#34;); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /*** * 打印类的所有参数 * @param c */ public static void printFields(Class c) { Field[] field = c.getDeclaredFields(); if (field.length &amp;gt; 0) { for (int i = 0; i &amp;lt; field.length; i&#43;&#43;) { System.out.println(Modifier.toString(field[i].getModifiers()) &#43; &amp;#34; &amp;#34; &#43; field[i].getType().getSimpleName() &#43; &amp;#34; &amp;#34; &#43; field[i].getName() &#43; &amp;#34;;&amp;#34;); } } } /*** * 打印类的所有方法 * @param c */ public static void printMethods(Class c) { Method[] method = c.getDeclaredMethods(); if (method.length &amp;gt; 0) { for (int i = 0; i &amp;lt; method.length; i&#43;&#43;) { Class[] parameter = method[i].getParameterTypes(); System.out.print(Modifier.toString(method[i].getModifiers()) &#43; &amp;#34; &amp;#34; &#43; method[i].getReturnType().getSimpleName() &#43; &amp;#34; &amp;#34; &#43; method[i].getName() &#43; &amp;#34;(&amp;#34;); for (int j = 0; j &amp;lt; parameter.length; j&#43;&#43;) { System.out.print(parameter[j].getSimpleName() &#43; &amp;#34; args&amp;#34;); if (j != parameter.length - 1) { System.out.print(&amp;#34;,&amp;#34;); } } System.out.print(&amp;#34;) &amp;#34;); Class exception[] = method[i].getExceptionTypes(); if (exception.length &amp;gt; 0) { System.out.print(&amp;#34;throws &amp;#34;); for (int j = 0; j &amp;lt; exception.length; j&#43;&#43;) { System.out.print(exception[j].getSimpleName()); } } System.out.println(&amp;#34;{&amp;#34;); System.out.println(&amp;#34;\t... ...&amp;#34;); System.out.println(&amp;#34;}&amp;#34;); } } } }  注解 自定义注解  代码格式
@Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface LoginRequired { } 框架详解
 Target  指定该注解使用的位置，可选情况如下  public enum ElementType { TYPE, // 指定适用点为 class, interface, enum FIELD, // 指定适用点为 field METHOD, // 指定适用点为 method PARAMETER, // 指定适用点为 method 的 parameter CONSTRUCTOR, // 指定适用点为 constructor LOCAL_VARIABLE, // 指定使用点为 局部变量 ANNOTATION_TYPE, //指定适用点为 annotation 类型 PACKAGE // 指定适用点为 package }   @Retention  指定编译器处理的方式，可选情况如下  public enum RetentionPolicy { SOURCE, // 编译器处理完Annotation后不存储在class中，仅存在于源文件中 CLASS, // 编译器把Annotation存储在class中，但不能被VM读取，这是默认值 RUNTIME // 编译器把Annotation存储在class中，可以由虚拟机读取,反射需要 }   @Documented
 指定允许写入javadoc  @Inherited  允许子类继承时同时继承该注解  public @interface LoginRequired { String value() default &amp;quot;login&amp;quot;; }   @Constraint(指定用哪个类进行相关校验)  @Constraint(validatedBy = {SafeStringValidator.class, SafeStringListValidator.class}) //注解类 public class SafeStringValidator implements ConstraintValidator{ //校验实现类   JAVA内置
 Override只用于方法,它指明注释的方法重写父类的方法,如果不是,则编译器报错. Deprecated指明该方法不建议使用 SuppressWarnings告诉编译器:我知道我的代码没问题   执行jar包  需求  提供DES加密包，支持命令行调用输出  解决方式  独立的Maven项目实现，并创建Main方法进行密码和密钥的输入，本地固定值测试OK后调整取args输入 将该项目install为jar包，并使用WinRAR工具在MANIFEST.MF中添加main方法入口（Main-Class: test.someClassName - 含main方法的类的项目内完整路径及名称） 控制台输入 java -jar c:/Encrypt.jar &amp;ldquo;password&amp;rdquo; &amp;ldquo;secret key&amp;rdquo;得到相应的加密后结果   </content>
    </entry>
    
     <entry>
        <title>Java.Command</title>
        <url>http://domain.yqjdcyy.com/post/java.command/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  Javac  作用  将 *.java 源代码转换为 *.class 格式文件  参考  Javac编译原理  事例  目录  D:\workspace\Knowledge_Structure\jni\JNIProxy.java  执行语句  D:\workspace\Knowledge_Structure\jni&amp;gt; javac JNIProxy.java    Javah  作用  生成类中所需的 JNI 头文件  参考  用javah 导出类的头文件， 常见的错误及正确的使用方法  事例  目录  D:\workspace\work4Git\Knowledge_Structure\00.语言\Java\代码\java-study\src\main\java\ com\yao\study\java\jni\JNIProxy.java  类定义  package com.yao.study.java.jni; public class JNIProxy{&amp;hellip;}  执行语句  D:\workspace\work4Git\Knowledge_Structure\00.语言\Java\代码\java-study\src\main\java&amp;gt; javah -o jni_msg.h com.yao.study.java.jni.JNIProxy    </content>
    </entry>
    
     <entry>
        <title>Java.Detail</title>
        <url>http://domain.yqjdcyy.com/post/java.detail/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  finally  用于及时释放资源以不影响系统性能 遵循最晚申请，最早释放原则，就近释放  若在A类一方法中申请到某个资源，应该就在这个方法的末尾将资源释放掉   preparedStatement  预编译语句，继承自Statement，用于处理大业务量的数据库操作 效率高，但代价是建立在创建对象时付出较大的成本，但是创建后可以通过传入不同的参数重复高效的使用 示例  PreparedStatement ps = con.prepareStatement(&amp;quot;select * from student where stuNo=?&amp;quot;); //!! for(int i=0; i&amp;lt; 1000; i&#43;&#43;){ ps.setString(1, &amp;quot;1000&amp;quot;); ResultSet rs = ps.executeQuery(); rs.close(); } ps.close(); //!!  注  在高频率反复执行同一类业务量的数据处理任务时使用   连接池  为服务器配置连接池，而在配置文件中指定所要连接的数据库和连接个数 便于服务器启动时，首先连接目标数据库创建指定个数的活动连接，并将其放到连接池中 优点  不同的访问者共享有限的连接，免去了数据库连结的漫长创建过程  类似使用  在线程管理中，为避免线程资源的浪费和提高效率，也可以采用线程池来进行线程的管理   内存管理 引用类型 弱引用  当被弱引用指向的对象除该弱引用之外不再有其他的引用指向这个对象，这个对象即为“弱引用” 回收标准  检查到该弱引用指向的对象，就会将其回收  支持对象  WeakRefrence：弱引用对象 WeakHashMap：专用于管理弱引用集合，消除由于HashMap不释放导致对象数据长期残留于内存的情况
  事例  Sample sam = new Sample(); WeakReference wr = new WeakReference(sam); // 定义弱引用并指向创建的对象 sam = null; // 使对象变成了垃圾 ((sam)wr.get()).shout(); // 验证对象是否还存在 System.gc(); // 执行垃圾收集 try{ Thread.sleep(80); // 主线程休眠，垃圾回收器运行 }catch(Exception e){ e.printStackTrace(); }  用途  用于防止内存泄露   软引用  当被软引用指向的对象除软引用外部存在其他的引用指向这个对象，这个对象即为“软引用” 回收标准  在内存即将耗尽的情况下，垃圾收集器在抛出异常之前尝试回收软引用指向对象的内存  支持对象  SoftRefrence  事例  Sample sam = new Sample(); SoftRefrence sr = new SoftRefrence(sam); // 定义弱引用并指向创建的对象 sam = null; // 使对象变成了垃圾 ((sam)sr.get()).shout(); // 验证对象是否还存在 System.gc(); // 执行垃圾收集 try{ Thread.sleep(80); // 主线程休眠，垃圾回收器运行 }catch(Exception e){ e.printStackTrace(); }  用途  作为缓冲区
   幻影引用  所指向的对象和一般的垃圾对象一样会被回收，并不能延长存活时间 特点  必须和一个ReferenceQueue类一起使用。 当一个被幻影引用指向的对象被垃圾收集器检测到需要回收时，垃圾收集器会将其挂到ReferenceQueue队列中，以起到消息传递的作用，并使对象内存在被回收前执行指定的pre-mortem操作
   小肥猪问题  一般出现在企业级服务器程序中，这些服务程序在起到的时候会创建一些对象，而这些对象在服务器运行中会产生新的对象。 这些新产生的子对象如果没有及时在用完之后释放掉，就会衣服在创建它们的对象上，而这些对象便是“小肥猪”  String  对String对象使用&#43;，实质上创建很多无用的中间对象，增加了系统的开销。 推荐方法  StringBuffer.append(&amp;ldquo;..&amp;rdquo;); StringBuilder   </content>
    </entry>
    
     <entry>
        <title>Linux.Vim</title>
        <url>http://domain.yqjdcyy.com/post/linux.vim/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  简明 VIM 练级攻略 阶段  存活 感觉良好 觉得更好，更强，更快 使用VIM的超能力  存活  i  Insert 模式  ESC  返回 Normal 模式  x  删除当前光标所有的一个字符  dd  剪切当前行  p  粘贴  hjkl  对应左下右上  :q&amp;lt;enter&amp;gt;  不保存退出   感觉良好 插入  i  在光标前插入  a  在光标后插入  O  在当前行前插入新行  o  在当前行后插入新行  cw  替换从光标所在位置后到一个单词结尾的字符   移动  0  行头  $  行尾  ^  到本行第一个 非blank 字符位置 blank= 空格| tab| 换行| 回车  g_  到本行最后一个非blank字符位置  /pattern  搜索 pattern 字符串   拷贝/ 粘贴  p  粘贴  yy  复制   Undo/ Redo  u  撤消   文件操作  :e  打开文件  :w  保存  ：saveas &amp;lt;path&amp;gt;  将文件另存至   :q!  强制退出不保存  :bn | :bp  多文件切换   更好，更强，更快 指令重复  .  重复上次命令 示例  2dd  删除2行  3.  删除6行    \d &amp;lt;command&amp;gt;  重复执行  \d次 示例  100iinput [ESC]  重复 100次 输入 input     光标移动  \dgG  跳到第\d行  gg  跳到首行  G  跳到末行  e  到下一单词的开头  w  到下一单词的结尾  %  匹配的括号（(, {, [）移动 光标移动至括号上后操作  * #  匹配当前所在单词，并向下或向上匹配  v  可视化选择 示例  按 v 后移动光标，可视文本被选择情况 后输入d、y、gU、gu进行删除、复制或变大小写    vim 超能力 光标移动  fa  到下一个 a 的字符处  t,  到下一个字符前 示例  dt,  删除所有，直到遇到 ,    F|T  反向搜索   区域选择  在 visual 模式下使用 &amp;lt;action&amp;gt;[a|i]&amp;lt;object&amp;gt;  属性  &amp;lt;action&amp;gt; = [d|y|v] &amp;lt;object&amp;gt; = [w|W|s|p|\)|\}|\]]  示例  (map (&#43;) (&amp;ldquo;foo&amp;rdquo;)) 且光标在第一个 o 处 vi&amp;quot;  foo  va&amp;quot;  &amp;ldquo;foo&amp;rdquo;  vi)  &amp;ldquo;foo&amp;rdquo;  va)  (&amp;ldquo;foo&amp;rdquo;)  v2i)  map (&#43;) (&amp;ldquo;foo&amp;rdquo;)  v2a)  (map (&#43;) (&amp;ldquo;foo&amp;rdquo;))
     块操作  比如给代码添加注释  0 &amp;lt;C-v&amp;gt; &amp;lt;C-d&amp;gt; I-- [ESC]  移动至行首 &amp;lt;C-v&amp;gt;开始进行块操作 &amp;lt;C-d&amp;gt;移动选择 I-- [ESC] 插入 --  类型 Sublime 的多行操作   自动补齐  &amp;lt;C-p&amp;gt;  可视化选择  J  把所有的行连成一行  [&amp;lt;| &amp;gt;]  [左| 右]缩进  =  自动缩进   </content>
    </entry>
    
     <entry>
        <title>Go.VSCode</title>
        <url>http://domain.yqjdcyy.com/post/go.vscode/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  VS-Code Go 开发 参考  VS Code 搭建 Go 开发IDE Running VS Code on Windows  安装  安装 vs-code 「Ctrl&#43; Shift&#43; P」后输入 「install Extensions」「Go」 安装「lukehoban - Go」 版本  调试  切换到「调试」界面，并点击「打开 launch.json」打开配置 调整指定配置项  &amp;lt;!-- 当前项目于 GOPATH 中的路径 --&amp;gt; &amp;quot;program&amp;quot;: &amp;quot;${workspaceRoot}\\Utils_Go\\src\\md5&amp;quot;, &amp;lt;!--设置当前环境变量 --&amp;gt; &amp;quot;env&amp;quot;: { &amp;quot;GOPATH&amp;quot;: &amp;quot;D:\\server\\go\\lib;D:\\work\\git\\yao\\go\\Hello_Go;D:\\work\\git\\yk\\go\\pptconverter-gateway\\code;${workspaceRoot}\\Utils_Go&amp;quot; }, &amp;lt;!--设置启动参数 --&amp;gt; &amp;quot;args&amp;quot;: [ &amp;quot;-c=1&amp;quot;, &amp;quot;-p=D:\\work\\git\\yao\\go\\Utils_Go\\template\\dest.mp4&amp;quot; ],  设置断点、进行调试  注  安装「lukehoban - Go」时，部分「go get」部分来源需要翻墙 调试相关快捷键同 visual stuio  </content>
    </entry>
    
     <entry>
        <title>Go.Nsq</title>
        <url>http://domain.yqjdcyy.com/post/go.nsq/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  [NSQ] 参考  An Example of Using NSQ From Go NSQ 官网 NSQ Github NSQ 指南  介绍 NSQ  实时的分页式消息处理平台 支持无 SPOF 的分布式拓扑 默认消息不持久化  可通过设置 --mem-queue-size 参数为 0 变更  接收到的消息无序  组成  nsqlookupd  作用  管理拓扑结构信息的守护进程 客户端查询以发现 nsqd 生产者的指定 topic nsqd节点广播 topic 和 channel 信息 接口提供  TCP：供 nsqd广播操作 HTTP：供客户端发现、管理性动作   参数  -broadcast-address  lookupd 节点地址 默认为 PROSNAKES.local  -config  config 文件路径  -tcp-address  TCP 客户端请求地址、端口 默认为 0.0.0.0:4160  -http-address  HTTP 客户端请求地址、端口 默认为 0.0.0.0:4161    nsqd
 作用
 接口、队列存储和发送客户端消息的守护进程 接口提供  TCP HTTP  stats    参数
 -config  config 文件路径  -broadcast-address  lookupd 节点地址 默认为 PROSNAKES.local  -data-path  存储磁盘备份信息的地址  -http-address  HTTP 客户端请求地址、端口 默认为 0.0.0.0:4151  -http-client-connect-timeout  HTTP 连接超时时间 默认为 2s  -http-client-request-timeout  HTTP 请求超时时间 默认为 5s  -https-address  HTTPS 客户端请求地址、端口 默认为 0.0.0.0:4152  -max-body-size  单指令体大小限制 默认为 5242880字节  -max-bytes-per-file  回滚前每个硬盘文件字段大小 默认为 104857600字节  -max-heartbeat-interval  客户端心跳配置最大间隔 默认为 1m0s  max-msg-size  单消息最大字节 默认为 1048576  -max-msg-timeout  消息超时的最大间隔 默认为 15m0s  -max-req-timeout  消息最大重新入队超时时间 默认为 1h0m0s  -statsd-address  推送统计信息的守护进程 UDP 地址  -tcp-address  TCP 客户端临时地址、端口 默认为 0.0.0.0:4150    nsqadmin
 作用  Web UI 实时查看聚合群组状态 执行多种管理任务    设计  nsqlookupd 提供目录服务，实现 nsqd 生产者和实际消费者的解耦 nsqlookupd 通过 TCP 连接获取 nsqd 的状态、地址，并通过 HTTP 连接用于轮询 nsqadmin 用于聚合查询、监测和管理集群 配置管理  单 nsqd 可同时处理多个数据流 每个通道接收话题中的所有信息拷贝 话题和通道的所有缓冲数据相互独立 一个通道有多个客户端连接，则消息会传送到随机一个客户端   消除SPOF（单点故障）    消息传递担保  客户端准备好 NSQ 发送消息，并将数据暂存在本地(re-queue/ timeout) 客户端回复 FIN 或 REQ 表示成功或失败重排。  若未回复，则将于设定时间超时后，自动重排回队列   限定内存占用 | 持久化  --mem-queue-size配置队列在内存中的消息数量  超过阈值时，消息将透明地写入磁盘 消息可能会被传递两次    使用  nsqlookupd nsqd --lookupd-tcp-address=127.0.0.1:4160 nsqadmin --lookupd-http-address=127.0.0.1:4161 nsq_to_file --topic=test --output-dir=/tmp --lookupd-http-address=127.0.0.1:4161 curl -d &#39;hello world 1&#39; &#39;http://127.0.0.1:4151/put?topic=test&#39;  注意  内存使用率  2.4/ 2.4/ 9.7M  性能  默认配置启动，3节点运行 nsqd  197mb/s 带宽    打包 准备  golang 1.6&#43; gpm  运行  gpm install go build  </content>
    </entry>
    
     <entry>
        <title>Linux.Make</title>
        <url>http://domain.yqjdcyy.com/post/linux.make/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  Make 参考  例解 Linux 下 Make 命令  作用  编译和安装开源工具 管理大型复杂项目的编译  原理  配合 Makefile 文件进行文件与相应目标的对应操作 扫描 Makefile 找到目标及其依赖，并递归建立扫描、编译，后编译主目标 再次执行时，仅编译相关目标文件  参数  -B  让所有目标总是重新建立  -d  打印调试信息  -C  切换到指定目录执行  -f  指定 Makefile 配置文件名   示例  配置文件
all: test test: test.o anotherTest.o gcc -Wall test.o anotherTest.o -o test test.o: test.c gcc -c -Wall test.c anotherTest.o: anotherTest.c gcc -c -Wall anotherTest.c clean: rm -rf *.o test make
gcc -c -Wall test.c gcc -c -Wall anotherTest.c gcc -Wall test.o anotherTest.o -o test make clean
rm -rf *.o test  </content>
    </entry>
    
     <entry>
        <title>Go.GPM</title>
        <url>http://domain.yqjdcyy.com/post/go.gpm/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  [TOC]
参考  gpm - Go Package Manager 跟我一起写Makefile Creating a personal access token  介绍 GPM  通过名为 Godeps 的 manifest 文件来管理、获取引用的指定版本依赖 Godeps文件置于 go 应用程序的根目录  使用 安装  wget https://raw.githubusercontent.com/pote/gpm/v1.4.0/bin/gpm &amp;ndash;no-check-certificate &amp;amp;&amp;amp; chmod &#43;x gpm &amp;amp;&amp;amp; sudo mv gpm /usr/local/bin  设置  更新到指定版本  github.com/nu7hatch/gotrail v0.0.2  注释  #右侧的均被注释掉  扩展  #[gpm-track] xxxx  总是更新为最新版本  GPM 核心忽略行，但会影响插件行为  私有资源库访问  创建 github 访问 token 添加下行至 ~/.netrc  machine github.com login &amp;lt;token&amp;gt;    指令  gpm [install]  解析Godeps文件，获取依赖并设置至合适版本，然后安装  gpm get  解析Godeps文件，获取依赖并设置至合适版本，但不安装  gpm version gpm help  插件  gpm-bootstrap  Creates an initial Godeps file
 official  gpm-git  Git management helpers
 third party  gpm-link  Dependency vendoring
 third party  gpm-local  Usage of local paths for packages third party  gpm-prebuild  Improves building performance third party  gpm-all  Installs multiple sets of deps
 official  gpm-lock  Lock down dependency versions third party   </content>
    </entry>
    
     <entry>
        <title>Go.Reflect</title>
        <url>http://domain.yqjdcyy.com/post/go.reflect/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  [TOC]
Go.Reflect 参考  Package reflect [](http://www.golang.ltd/forum.php?mod=viewthread&amp;amp;tid=6017)  类型和接口 Go 为静态类型语言，变量有且只有一个静态类型，于编译时已确认 var r io.Reader r = os.Stdin r = bufio.NewReader(r) r = new(bytes.Buffer) // r 不管指向什么，类型永远是 io.Reader interface{}  任何具体值均有 0&#43;个方法，因此 interface{} 变量能存储任何值 Interface 变量存储值，赋给该变量的值 &amp;amp; 值类型的描述符  定律  反射可以将“接口类型变量”转换为“反射类型对象” 反射可以将“反射类型对象”转换为“接口类型变量” 如果要修改“反射类型对象”，其值必须是“可写的”（settable）  方法  reflect.Type  Kind() NumMethod() | Method(int) NumField() | Field(i int) | Elem()  返回类型的元素类型 非[Array| Chan| Map| Ptr| Slice]时 panic   reflect.Value  ValueOf(i interface{}) CanSet() Elem() NumField() | Field(idx) | FieldByName(name) Kind() NumMethod() | Method(idx) | MethodByName(name) SetFloat(val) | SetInt(val) | SetString(val)   </content>
    </entry>
    
     <entry>
        <title>Windows.Service</title>
        <url>http://domain.yqjdcyy.com/post/windows.service/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Windows</tag><tag>Service</tag>
        </tags>
        <content type="html">  Windows 程序服务化 参考  SC NSSM windows service startup timeout reset service timeout 服务安装启动报错误1053  SC - Service Controller 语法  sc [ServerName] [command] [Optionname= Optionvalues]  常用参数  config  更新服务配置 sc config nsqd start= auto  control  发送控制指令 sc [&amp;lt;ServerName&amp;gt;] control [&amp;lt;ServiceName&amp;gt;] [{paramchange | netbindadd | netbindremove | netbindenable | netbinddisable | &amp;lt;UserDefinedControlB&amp;gt;}]  create | delete  创建|删除服务 sc create nsqd binPath= .\nsqd.exe start= auto  start | stop  启动|停止服务 sc start nsqd   示例 @echo off sc create nsqd binPath= .\nsqd.exe start= auto sc start nsqd echo DONE! pause 注意事项  等号应与后面值间隔以空格 删除服务前，应先停止服务 可键入sc -help 或具体指令 sc start 查看帮助文档  异常  异常排查  查看系统日志，来源为 「Service Control Manager」  1053:服务没有及时响应启动或控制请求  C# 服务，可能因为 .Net Framework 版本不一致 可查度参考文献中的方法，进行注册表中的「ServicesPipeTimeout 」值的修复   NSSM - the Non-Sucking Service Manager 常用语法  nssm install &amp;lt;server-name&amp;gt; D:\server\go\nsq\0.3.8\bin\nsqd.exe nssm remove &amp;lt;server-name&amp;gt;  缺点  部分软件无法正常运行！  </content>
    </entry>
    
     <entry>
        <title>Chrome.Plugin</title>
        <url>http://domain.yqjdcyy.com/post/chrome.plugin/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Chrome</tag><tag>Plugin</tag>
        </tags>
        <content type="html">  参考  Getting Started: Building a Chrome Extension Overview Developer&amp;rsquo;s Guide Sample Extensions  示例解析  目录结构
html setting.html // 弹出界面 images icon.png // banner 上小图标，推荐使用 19*19 的半透明 png 图片，同时提供 38*38 的半透明 png 图片作为大图标 js setting.js // 弹出界面所引用 js 文件，__要求 js 和 html 分开存放__ manifest.json // 插件配置文件 manifest.json
{ &amp;#34;manifest_version&amp;#34;: 2, // 配置文件版本 &amp;#34;name&amp;#34;: &amp;#34;插件名称&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;插件功能描述&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.1&amp;#34;, // 插件当前开发版本 // 通用型 &amp;#34;browser_action&amp;#34;: { // 浏览器级动作 &amp;#34;default_icon&amp;#34;: &amp;#34;/images/icon.png&amp;#34;, // 默认 banner 上显示图标 &amp;#34;default_popup&amp;#34;: &amp;#34;/html/setting.html&amp;#34; // 默认点击小图标后弹出界面 }, &amp;#34;permissions&amp;#34;: [ // 指定权限，如实现功能，可访问站点等 &amp;#34;activeTab&amp;#34; ], // 页面型 &amp;#34;background&amp;#34;: { // 插件主程序 &amp;#34;scripts&amp;#34;: [&amp;#34;background.js&amp;#34;] }, &amp;#34;page_action&amp;#34;: { // 界面级动作，限定 permissions= tabs &amp;#34;default_icon&amp;#34;: { &amp;#34;19&amp;#34;: &amp;#34;cnblogs_19.png&amp;#34;, &amp;#34;38&amp;#34;: &amp;#34;cnblogs_38.png&amp;#34; }, &amp;#34;default_title&amp;#34;: &amp;#34;cnblogs.com article information&amp;#34; }, &amp;#34;permissions&amp;#34;: [ &amp;#34;tabs&amp;#34; ], &amp;#34;offline_enabled&amp;#34;: false }  </content>
    </entry>
    
     <entry>
        <title>Go.安装配置</title>
        <url>http://domain.yqjdcyy.com/post/go.%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  配置  GOROOT  配置 GO 的可执行文件路径 D:\server\go\1.8  PATH  将 Go 相关可执行文件列表入搜索路径中 %GOROOT%\bin  GOPATH  目录列表，类似于maven中的repository目录，引用库 其中第一个地址将作为 go get 的下载目录 D:\server\go\lib D:\work\git\yao\go\Hello_Go   </content>
    </entry>
    
     <entry>
        <title>Java.Filter-Lisenter-Inteceptor-AOP</title>
        <url>http://domain.yqjdcyy.com/post/java.filter-lisenter-inteceptor-aop/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  Compare     名称 机制 适用范围 生命周期 对象调用权限 优点/场景     Filter 过滤器 函数回调 Servlet 于 Servlet 前后作用 仅于 Servlet 初始化时调用 Request/ Response 不依赖框架，便于移植 字符编码设置、过滤敏感词、URL权限   Listener 监听器 事件回调 Servlet/ Application/ Swing 初始化时调用 与事件相关 不依赖框架，便于移植统计在线人数、清理过期 Session   Interceptor 拦截器 反射机制 Servlet 于 Service.execute 前后 多次调用 Request/ Response/ HandlerMethod 不依赖框架，便于移植效率检测、日志输出、安全检测、用户拦截   AOP 面向切面 反射机制 Servlet/ Application/ Swing可深入至方法、异常抛出的前后，推荐 多次调用 Method.Name 框架支持，灵活实现    Other Order  Filter.before Interceptor.before AOP.before Request  Error  AOP.after ControllerAdvice.handleError Interceptor.after Filter.after  Example Filter  init ``` public class TimeFilter implements Filter {
@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { long start = new Date().getTime(); chain.doFilter(request, response); System.out.println(&amp;ldquo;time filter 耗时:&amp;ldquo;&#43; (new Date().getTime() - start)); }
  }
- config @Configuration public class WebConfig extends WebMvcConfigurerAdapter {
@Bean public FilterRegistrationBean timeFilter() { FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new TimeFilter()); List&amp;lt;String&amp;gt; urls = new ArrayList&amp;lt;&amp;gt;(); urls.add(&amp;#34;/*&amp;#34;); registrationBean.setUrlPatterns(urls); return registrationBean; } }
## Listener - init @WebListener public class MyServetContextListener implements ServletContextListener{
@Override public void contextInitialized(ServletContextEvent event) { ServletContext application = event.getServletContext(); String userName = application.getInitParameter(&amp;#34;userName&amp;#34;); System.out.println(&amp;#34;启动web应用的用户名字为：&amp;#34;&#43;userName); } }
## Inteceptor - init @Component public class TimeInterceptor implements HandlerInterceptor {
@Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(((HandlerMethod)handler).getBean().getClass().getName()); request.setAttribute(&amp;#34;startTime&amp;#34;, new Date().getTime()); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&amp;#34;time interceptor 耗时:&amp;#34;&#43; (new Date().getTime() - (Long) request.getAttribute(&amp;#34;startTime&amp;#34;))); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&amp;#34;time interceptor 耗时:&amp;#34;&#43; (new Date().getTime() - (Long) request.getAttribute(&amp;#34;startTime&amp;#34;))); System.out.println(&amp;#34;ex is &amp;#34;&#43;ex); } }
## AOP - init @Aspect @Component public class TimeAspect {
@Before() @Around(&amp;#34;execution(* com.imooc.web.controller.UserController.*(..))&amp;#34;) public Object handleControllerMethod(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (Object arg : args) { System.out.println(&amp;#34;arg is &amp;#34;&#43;arg); } long start = new Date().getTime(); Object object = pjp.proceed(); System.out.println(&amp;#34;time aspect 耗时:&amp;#34;&#43; (new Date().getTime() - start)); return object; } } ```
Reference  filter(过滤器)与拦截器（AOP)区别 spring filter、interception、AOP之间对比 從攔截過濾器到AOP Java三大器之拦截器(Interceptor)的实现原理及代码示例 Java如何使用Listener  </content>
    </entry>
    
     <entry>
        <title>Go.异常处理</title>
        <url>http://domain.yqjdcyy.com/post/go.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  Defer, Panic, Recover 参考  Defer, Panic, and Recover Go的异常处理 defer, panic, recover  使用 defer  作用  用于在当前方法结束时，执行相关方法  特点
 声明 defer 时值即为方法中参数被赋的值 声明多个时，即以后进先出的顺序执行 可读取、操作命名的方法返回参数对象
 操作返回值
// return 2 func c() (i int) { defer func() { i&#43;&#43; }() return 1 } panic   特点
 内置方法 立即中断当前程序 方法内原defer定义方法仍可正常进行 向上抛出该程序崩溃处指针   recover  特点  内置方法 仅可用于defer方法中 用于捕获panic抛出的异常信息   实例 func main(){ // 必须要先声明defer，否则不能捕获到panic异常 defer func(){ fmt.Println(&amp;#34;c&amp;#34;) if err:=recover();err!=nil{ // 这里的err其实就是panic传入的内容，55 fmt.Println(err) } fmt.Println(&amp;#34;d&amp;#34;) }() f() } func f(){ fmt.Println(&amp;#34;a&amp;#34;) panic(55) fmt.Println(&amp;#34;b&amp;#34;) fmt.Println(&amp;#34;f&amp;#34;) } // 输出信息为：a/ c/ 55/ d</content>
    </entry>
    
     <entry>
        <title>Go.GoSublime</title>
        <url>http://domain.yqjdcyy.com/post/go.gosublime/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  注解  Path  分隔符  Windows - ; Linux| OS X - :    设置  路径  Packages/User/GoSublime.sublime-settings  推荐更新覆盖  Packages/GoSublime/GoSublime.sublime-settings  默认配置，不建议更新   代码补全  配置 Preferences/Package Settings/GoSublime/Settings - User  { &amp;quot;autocomplete_builtins&amp;quot;: true, &amp;quot;autocomplete_closures&amp;quot;: true }  快捷键  Code Complete  Ctrl&#43; [Space]  package import  Ctrl&#43;[.], Ctrl&#43; P  jump  F12 Crl&#43; [.], Ctrl&#43; i     项目定制化配置  project.sublime-project  { &amp;quot;settings&amp;quot;: { &amp;quot;GoSublime&amp;quot;: { &amp;quot;env&amp;quot;: { &amp;quot;GOPATH&amp;quot;: &amp;quot;$HOME/my-project&amp;quot; // 覆盖 `GoSublime.sublime-settings` } } }, &amp;quot;folders&amp;quot;: [] }   </content>
    </entry>
    
     <entry>
        <title>Go.Flag</title>
        <url>http://domain.yqjdcyy.com/post/go.flag/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Go</tag>
        </tags>
        <content type="html">  Flag 参考  Package flag Golang flag包使用详解  作用  用于解析命令行参数的功能接口  常用  flag.Xxx[String| Bool| Int](name string, default-value Xxx, usage-info string)  返回相应指针  flag.XxxVar(ptr-store *Xxx, name, default-value, usage-info)  将 flag 绑定到变量  flag.Var(&amp;amp;custom-type, name, usage-info)  custom-type 需要实现 Value 接口  flag.Parse()  直接使用国指针，绑定参数则为实际值 flag.Args() flag.Arg(i)  flag.PrintDefaults  define  flag.String(&amp;quot;I&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;searchdirectoryfor include files&amp;quot;)  output  -I directory search directory for include files.    示例  引用后获取相关信息
url := flag.String(&amp;#34;url&amp;#34;, &amp;#34;127.0.0.1&amp;#34;, &amp;#34;input the url, plz&amp;#34;) port := flag.Int(&amp;#34;port&amp;#34;, 8888, &amp;#34;input the port, plz&amp;#34;) flag.Parse() fmt.Printf(&amp;#34;%v %v\n&amp;#34;, *url, *port) 获取“species” flag的值，默认为“gopher”
 var species = flag.String(&amp;quot;species&amp;quot;, &amp;quot;gopher&amp;quot;, &amp;quot;the species we are studying&amp;quot;)  两个flag共享同一个变量，一般用于同时实现完整flag参数和对应简化版flag参数，需要注意初始化顺序和默认值
var gopherType string func init() { const ( defaultGopher = &amp;#34;pocket&amp;#34; usage = &amp;#34;the variety of gopher&amp;#34; ) flag.StringVar(&amp;amp;gopherType, &amp;#34;gopher_type&amp;#34;, defaultGopher, usage) flag.StringVar(&amp;amp;gopherType, &amp;#34;g&amp;#34;, defaultGopher, usage&#43;&amp;#34;(shorthand)&amp;#34;) }  </content>
    </entry>
    
     <entry>
        <title>Mysql.LOCK-WAITS</title>
        <url>http://domain.yqjdcyy.com/post/mysql.lock-waits/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Mysql</tag>
        </tags>
        <content type="html">  MySQL 5.5 InnoDB 锁等待 锁相关表    表名 作用     innodb_trx 当前正在执行事务的信息   innodb_locks 各已被请求但未被提交的事务锁   innodb_lock_waits 各阻塞事务的一至多行记录信息    字段 innodb_trx    字段 注释     trx_id 事务ID。   trx_state 事务状态，有以下几种状态:RUNNING、LOCK WAIT、ROLLING BACK 和 COMMITTING。   trx_started 事务开始时间。   trx_requested_lock_id 事务当前正在等待锁的标识，可以和 INNODB_LOCKS 表 JOIN 以得到更多详细信息。   trx_wait_started 事务开始等待的时间。   trx_weight 事务的权重。   trx_mysql_thread_id 事务线程 ID，可以和 PROCESSLIST 表 JOIN。   trx_query 事务正在执行的 SQL 语句。   trx_operation_state 事务当前操作状态。   trx_tables_in_use 当前事务执行的 SQL 中使用的表的个数。   trx_tables_locked 当前执行 SQL 的行锁数量。   trx_lock_structs 事务保留的锁数量。   trx_lock_memory_bytes 事务锁住的内存大小，单位为 BYTES。   trx_rows_locked 事务锁住的记录数。包含标记为 DELETED，并且已经保存到磁盘但对事务不可见的行。   trx_rows_modified 事务更改的行数。   trx_concurrency_tickets 事务并发票数。   trx_isolation_level 当前事务的隔离级别。   trx_unique_checks 是否打开唯一性检查的标识。   trx_foreign_key_checks 是否打开外键检查的标识。   trx_last_foreign_key_error 最后一次的外键错误信息。   trx_adaptive_hash_latched 自适应散列索引是否被当前事务锁住的标识。   trx_adaptive_hash_timeout 是否立刻放弃为自适应散列索引搜索 LATCH 的标识。    innodb_locks    字段 注释     lock_id 锁 ID。   lock_trx_id 拥有锁的事务 ID。可以和 INNODB_TRX 表 JOIN 得到事务的详细信息。   lock_mode 锁的模式。有如下锁类型: 行级锁包括 S、X、IS、IX，分别代表共享锁、排它锁、意向共享锁、意向排它锁。表级锁包括 S_GAP、X_GAP、IS_GAP、IX_GAP 和 AUTO_INC，分别代表共享间隙锁、排它间隙锁、意向共享间隙锁、意向排它间隙锁和自动递增锁。   lock_type 锁的类型。RECORD 代表行级锁，TABLE 代表表级锁。   lock_table 被锁定的或者包含锁定记录的表的名称。   lock_index 当 LOCK_TYPE=’RECORD’ 时，表示索引的名称；否则为 NULL。   lock_space 当 LOCK_TYPE=’RECORD’ 时，表示锁定行的表空间 ID；否则为 NULL。   lock_page 当 LOCK_TYPE=’RECORD’ 时，表示锁定行的页号；否则为 NULL。   lock_rec 当 LOCK_TYPE=’RECORD’ 时，表示一堆页面中锁定行的数量，亦即被锁定的记录号；否则为 NULL。   lock_data 当 LOCK_TYPE=’RECORD’ 时，表示锁定行的主键；否则为NULL。    innodb_lock_waits | 字段 | 注释 | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash; | | requesting_trx_id | 请求事务的 ID。 | | requested_lock_id | 事务所等待的锁定的 ID。可以和 INNODB_LOCKS 表 JOIN。 | | blocking_trx_id | 阻塞事务的 ID。 | | blocking_lock_id | 某一事务的锁的 ID，该事务阻塞了另一事务的运行。可以和 INNODB_LOCKS 表 JOIN。 |
常用 默认查询  SELECT * FROM information_schema.innodb_trx \G SELECT * FROM information_schema.innodb_locks \G SELECT * FROM information_schema.innodb_lock_waits \G  锁等待时长  SHOW VARIABLES LIKE &#39;%innodb_lock_wait%&#39; SET innodb_lock_wait_timeout=600;  事务处理  显示锁事件  SELECT trx_id, trx_requested_lock_id, trx_mysql_thread_id, trx_query FROM information_schema.innodb_trx WHERE trx_state = &#39;LOCK WAIT&#39; \G  消除锁  kill {trx_mysql_thread_id}   </content>
    </entry>
    
     <entry>
        <title>Java.Exception</title>
        <url>http://domain.yqjdcyy.com/post/java.exception/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  分类 Throwable Exception  ReflectiveOperationException  NoSuchMethodException IllegalAccessException NoSuchFieldException InstantiationException ClassNotFoundException  CloneNotSupportedException InterruptedException  ClassCastException EnumConstantNotPresentException IllegalStateException NullPointException IllegalMonitorStateException IllegalArgumentException  IllegalThreadStateException NumberFormatException  SecurityException  RuntimeException  ArithmeticException TypeNotPresentException IndexOutOfBoundsException  ArrayIndexoutOfBoundsExxception StringIndexoutOfBoundsException  NegativeArraySizeException ArrayStoreException UnsupportedOperationException UnCheckIOException  IOException  SyncFailedException CharConversionException UnsupportedEncodingException ObjectStreamException  NotSerializableException InvalidObjectException NotActiveException InvalidClassException WriteAbortedException StreamCorruptedException OptionDataException  InterruptedIOException UTFDataFormatException FileNotFoundException EOFException    Error  VirtualMachineError  InternalError StackOverflowError UnknownError OutOfMemoryError  ThreadDeath AssertionError LinkageError  UnsatisfiedLinkError NoClassDefFoundError VerifyError IncompatibleClassChangeError  InstantiationError NoSuchFieldError NoSuchMethodError AbstractMethodError IllegalAcessError  BootstrapMethodError ExceptionInInitializerError ClassFormatError  UnsupportedClassVersionError  ClassCircularityError  IOError  明细 Throwable  简介  所有错误和异常的基类 仅该类实例可被 JVM 抛出或于声明中抛出 设计中包含 cause 的原因  底层定义异常类型，顶层描述报错位置和具体异常原因 设计上提醒开发者注意异常，并进行捕获处理，而非直接抛出   方法  Throwable(String message) getMessage()  明细消息  getLocalizedMessage()  局部描述，子类重写该方法  toString()
 printStackTrace() printStackTrace(PrintStream s)   Exception  描述
 分类  检查型异常  编译器要求程序必须捕获或声明抛出异常  非检查型异常 | 运行时异常   方法
 Exception() Exception(String message)   Error  描述  编译时错误 | 系统错误  方法  Error() Error(String message)   </content>
    </entry>
    
     <entry>
        <title>Linux.Curl</title>
        <url>http://domain.yqjdcyy.com/post/linux.curl/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Linux</tag>
        </tags>
        <content type="html">  参考  curl网站开发指南 curl 官网 everything-curl.pdf  指令  -O | -o path  下载  -i  显示 http response 头信息  -v  显示通信全过程信息 可使用 --trace output.txt 保存更详细通信过程  -X [DELETE| POST| PUT| ...]  支持其它类型参数  --data &amp;quot;arg=val&amp;quot;  传递参数  --user-agent  传递客户端设备信息  -c cookie-file &#43; -b cookie-file  分别用于保留服务器返回的 cookie 至指定文件，和请求时读取文件作为 cookie 信息  -header &amp;quot;Content-Type:application/json&amp;quot;  增加头信息   示例  带 cookie 请求  curl -X POST -H &amp;quot;Content-Type: application/json;charset=UTF-8&amp;quot; -d &#39;{&amp;quot;username&amp;quot;:&amp;quot;15880777595&amp;quot;,&amp;quot;pwd&amp;quot;:&amp;quot;1&amp;quot;}&#39; --cookie-jar /data/cdn/resource/curl-cookie http://live.yunkai.com/basic-api/login curl -X POST --cookie /data/cdn/resource/curl-cookie http://test-live.yunkai.com/api/reset/topic/1101?file=2db80451-154d-482c-8a65-07ba5168a904.pptx curl -v --cookie /data/cdn/resource/curl-cookie http://live.yunkai.com/basic-api/exercises/142 &amp;gt; /data/tmp/yao/142  表单提交  curl --form arg1=val1 --form arg2=val2 {URL}  Multifile Request  curl -F file=@&amp;quot;/data/cdn/test/doc/2e8e1880-ba8c-4166-b4b1-c40205af3c95.txt&amp;quot; http://test-live.yunkai.com/api/resource/uploadError?type=back  下载  curl -v -o courseware-106.zip --cookie /data/tmp/yao/curl/curl-cookie &amp;quot;http://live.capitalnuts.com/basic-api/courseware/106/talk&amp;quot;   </content>
    </entry>
    
     <entry>
        <title>加藤鹰.秘技</title>
        <url>http://domain.yqjdcyy.com/post/%E5%8A%A0%E8%97%A4%E9%B9%B0-%E7%A7%98%E6%8A%80%E4%BC%A0%E6%8E%88/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>Sex</tag>
        </tags>
        <content type="html">  加藤鹰-秘技传授 接吻  搂脖子，抚摸脸颊、上下嘴唇，将耳边头发撩至耳后 侧头舔吸上下唇 敏感部位：上牙龈后侧  爱抚 耳朵  待定  舌技  待定  指技  待定  异物插入  待定  插入  待定  </content>
    </entry>
    
     <entry>
        <title>Mysql.Information_schema</title>
        <url>http://domain.yqjdcyy.com/post/mysql.information_schema/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Mysql</tag>
        </tags>
        <content type="html">  MYSQL.INFORMATION_SCHEMA 简介  MySQL自带的，它提供了访问数据库元数据的方式。 元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。 保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。  库表  SCHEMATA  提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。  TABLES  提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。  COLUMNS  提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。  STATISTICS  提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。  USER_PRIVILEGES（用户权限）  给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。  SCHEMA_PRIVILEGES（方案权限）  给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。  TABLE_PRIVILEGES（表权限）  给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。  COLUMN_PRIVILEGES（列权限）  给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。  CHARACTER_SETS（字符集）  提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。  COLLATIONS  提供了关于各字符集的对照信息。  COLLATION_CHARACTER_SET_APPLICABILITY  指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。  TABLE_CONSTRAINTS  描述了存在约束的表。以及表的约束类型。  KEY_COLUMN_USAGE  描述了具有约束的键列。  ROUTINES  提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。  VIEWS  给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。  TRIGGERS
 提供了关于触发程序的信息。必须有super权限才能查看该表  INNODB_BUFFER_PAGE
 提供了缓冲区中每页相关的元数据信息，包括更新缓冲索引页和更新缓冲位图页  INNODB_BUFFER_PAGE_LRU
 提供缓冲池中各页的消息，特别用于当缓冲池满时通过 LRU（近期最少使用算法）裁定移除哪些界面  INNODB_BUFFER_POOL_STATS
 提供缓冲池各页状态信息，通过标识 young 和 not young 状态来判定该各页的回收时机  INNODB_CMP
 提供压缩 InnoDB 表的操作状态信息  INNODB_CMPMEM
 提供压缩缓冲池中页面的操作状态信息  INNODB_CMP_PER_INDEX
 提供压缩表和索引的操作状态信息，并进行单独统计各种库、表、索引的组织，帮助评估特定表压缩的效果和作用  INNODB_FT_BEING_DELETED
 为 INNODB_FT_DELETED 的快照，仅用于执行 OPTIMIZE TABLE 时使用。当 OPTIMIZE TABLE 运行时时， INNODB_FT_BEING_DELETED 会被清空，并从 INNODB_FT_DELETED 中将 DOC_IDs 移除出来 DOC_ID  执行删除操作时，该行的文档 ID 该值指向基本表定义时的 ID 列   INNODB_FT_CONFIG
 展示全文索引和表关联执行的元数据 查询前，为包含有全文索引的表设置 innodb_ft_aux_table 配置属性  INNODB_FT_DEFAULT_STOPWORD
 创建全文索引时默认配置的停用词列表  INNODB_FT_DELETED
 记录由全文索引中被删除的记录行  INNODB_FT_INDEX_CACHE
 包含在全文索引中新插入行的 token 信息  INNODB_FT_INDEX_TABLE
 展示执行文本搜索时的倒序实现的相关信息  INNODB_LOCKS
 包含各已被请求但未被提交的事务锁，或被其它事务所阻塞的当前事务锁的信息  INNODB_LOCK_WAITS
 包含各阻塞事务的一至多行记录信息，用于描述锁如何被请求但又被其它锁所阻塞  INNODB_METRICS
 获取计数器的相关启动、停止和重启的相关信息  INNODB_SYS_COLUMNS
 提供表栏目的元数据信息，等价于 SYS_COLUMNS 中的信息  INNODB_SYS_DATAFILES
 提供表空间的数据文件的路径信息，等价于 SYS_DATAFILES 中的信息  INNODB_SYS_FIELDS
 提供索引关联字段的元数据，等价于 SYS_FIELDS 中的信息  INNODB_SYS_FOREIGN
 提供外键的元数据，等价于 SYS_FOREIGN 中的信息  INNODB_SYS_FOREIGN_COLS
 提供外键相关字段名的状态信息  INNODB_SYS_INDEXES
 提供索引的元数据，等价于 SYS_INDEXES 中的信息  INNODB_SYS_TABLES
 提供库表的元数据，等价于 SYS_TABLES 中的信息  INNODB_SYS_TABLESPACES
 提供 File-Per-Table 和一般表空间的元数据，等价于 SYS_TABLESPACES 中的信息 File-Per-Table 主要用于提升成功恢复的机会和节省时间，进行表复制、备份时的状态报告  INNODB_SYS_TABLESTATS
 提供库表的低等级状态信息，该数据用于在表查询时优化计算以判定使用哪个索引  INNODB_SYS_VIRTUAL
 提供虚拟生成字段或其所信赖的栏目信息的元数据，等价于 SYS_VIRTUAL 中的信息 generated virtual columns  栏目值通过栏目定义的表达式计算而来   INNODB_TEMP_TABLE_INFO
 提供当前状态的临时表的元数据，除了内部优化的临时表 记录所有用户和系统创建，激活状态，在指定实例中的临时表。 临时表仅保存于内存中，并不保存到硬盘  INNODB_TRX
 包含每个当前正在执行事务的信息，包括当事务开始时、执行 sql 时的事务是否正在等待锁   参考 INFORMATION_SCHEMA Tables InnoDB INFORMATION_SCHEMA Tables
</content>
    </entry>
    
     <entry>
        <title>Windows.Shell.Commons</title>
        <url>http://domain.yqjdcyy.com/post/%E5%B8%B8%E7%94%A8cmd%E6%8C%87%E4%BB%A4/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Windows</tag><tag>Shell</tag>
        </tags>
        <content type="html">  强制关闭占用指定端口服务  查询指定窗口是否被占用： netstat -aon|findstr &amp;ldquo;9050&amp;rdquo; 查询哪个应用占用了指定端口： tasklist|findstr &amp;ldquo;2748&amp;rdquo; 关闭相应的进程：taskkill /f /t /im adb.exe 常用：taskkill /f /t /im java.exe  硬盘检测及修复  检测指定盘符： chkdsk C: 若有异常时进行修复： chkdsk c: /f 注：若正在使用，可选择【Y】，待下次启动时检测  强制登录  发现超出并发人数的情况下，输入如下指令：mstsc /v:192.168.16.99:3389 /admin。 其中192.168.16.99:3389为连接的网址和端口，admin表示管理员登陆。 注：此例在win7远程win2003校验通过。  转换成系统隐藏文件  转换 attrib &#43;s &#43;h [fileName|folderaName] 进入 cd **/[fileName|folderaName] 恢复 attrib -s -h [fileName|folderaName]  临时更改环境变量  set GOPATH=%GOPATH%;xxxxxx  显示目录下文件  tree /f  查看 Linux 系统版本  lsb_release -a  </content>
    </entry>
    
     <entry>
        <title>音视频的相关名词</title>
        <url>http://domain.yqjdcyy.com/post/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9A%84%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/</url>
        <categories>
          <category>阅读</category>
        </categories>
        <tags>
          <tag>音视频</tag>
        </tags>
        <content type="html">  参考  码流 / 码率 / 比特率 / 帧速率 / 分辨率 / 高清  解析 码率  解析  Data Rate，又名码流、码流率 视频文件在单位时间内使用的数据流量，单位为 Kb/s 或 Mb/s 通指视频文中的音频和视频码流率总和 视频画面质量控制中最重要的部分  计算  File.size= duration* Data.Rate/ 8 90m 1Mbps 720P RMVB= 90* 60s* 1Mb/s/ 8= 675 MB   采样率  归类  音频  解析  Sampling Rate，又名采样辣度、采样频率 指将从连续信号中提取并组成离散信号的采样个数，单位为 Hz 以 44.1kHZ 采样率记录并播放，即可听到连续声音；越高则越连贯  人的听觉和视觉分辨采样率上限即为 44.1kHZ -   计算  比特率= 采样率* 采样位数* 声道数 CD 每秒 44100 次取样，2 个声道，13 位PCM编码  = 44100* 2* 13 = 144 KB/s   补充  位数  类比于画面的颜色数 上限  听觉 - 16位 视觉 - 24位   声道   比特率  解析  Bit Rate 每秒传送的比特数，单位为b/s 指将为数字声音、视频由模拟格式转化为数字格式的采样率  常见编码  VBR- Variable Bitrate  动态比特率，压缩时根据音频数据即时确定 质量前提，文件大小兼顾 推荐编码模式  ABR- Averate Bitrate  指定文件大小内，以每50帧为段，低频与不敏感使用较低流量，高频与动态表现时使用高流量 VBR 和 CBR 的折衷  CBR- Constant Bitrate  固定使用一位速率 压缩文件体积大，且音质无明显提高    帧速率  解析  FPS，Frames PerSecond 每秒钟刷新的图片的帧数，为图形处理器每秒刷新次数，单位为 f/s   分辨率  解析  指每帧图像的大小，如640* 480   720P 1080P  解析  分辨率简称  720P= 1280*720 1080P= 1920*1080  采用编码格式有MPEG2/ VC-1/ H.264/ Divx/ Xvid/ ts/ mkv/ wmv  压缩比上，H.264&amp;gt; VC-1&amp;gt; MPEG2    H.264  解析  High Definition，高分辨率 美国电影电视工程师协会确定的高清晰度电视标准格式 常见封装格式，avi/ mkv/ ts   </content>
    </entry>
    
     <entry>
        <title>XSD</title>
        <url>http://domain.yqjdcyy.com/post/xsd/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>XSD</tag>
        </tags>
        <content type="html">  简介  全称为 XML Schema 定义，即 XML Schema Definition (XSD) XML Schema 是基于 XML 的 DTD 替代，用于描述 XML 文档的结构。 支持数据类型，便于描述、验证正确性和约束、转换、定义等工作。  参考  教程：http://www.w3school.com.cn/schema/ 手册：http://www.w3school.com.cn/schema/schema_elements_ref.asp 验证：http://www.ltg.ed.ac.uk/~ht/xsv-status.html 实例：http://www.w3school.com.cn/schema/schema_example.asp
使用 XML结构 &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;note&amp;gt; &amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt; &amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt; &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt; &amp;lt;body&amp;gt;Don&amp;#39;t forget the meeting!&amp;lt;/body&amp;gt; &amp;lt;/note&amp;gt;  定义 - note.xsd &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;xs:schema xmlns:xs=&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34; // 指定该 Schema 中的元素和数据类型的命名空间来源， 同时指定当前命名空间的元素和类型都应需补充前缀 xs: targetNamespace=&amp;#34;http://www.w3school.com.cn&amp;#34; // 显示定义元素(node /to /from /heading /body)的来源命名空间 xmlns=&amp;#34;http://www.w3school.com.cn&amp;#34; // 指定默认命名空间 elementFormDefault=&amp;#34;qualified&amp;#34; &amp;gt; &amp;lt;xs:element name=&amp;#34;note&amp;#34;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;#34;to&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;from&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;heading&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;body&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;/xs:schema&amp;gt; 引用 &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;note xmlns=&amp;#34;http://www.w3school.com.cn&amp;#34; // 默认命名空间的声明 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; // 指定 XML Schema 实例命名空间 xsi:schemaLocation=&amp;#34;http://www.w3school.com.cn note.xsd&amp;#34; // 指定实例命名空间后使用， 用于指定需要使用的命名空间和供命名空间使用的 XML Schema 位置 &amp;gt; &amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt; &amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt; &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt; &amp;lt;body&amp;gt;Don&amp;#39;t forget the meeting!&amp;lt;/body&amp;gt; &amp;lt;/note&amp;gt; 类型 简单类型 元素 &amp;lt;xs:element name=&amp;#34;xxx&amp;#34; type=&amp;#34;yyy&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;color&amp;#34; type=&amp;#34;xs:string&amp;#34; default=&amp;#34;red&amp;#34;/&amp;gt; // 默认值 &amp;lt;xs:element name=&amp;#34;color&amp;#34; type=&amp;#34;xs:string&amp;#34; fixed=&amp;#34;red&amp;#34;/&amp;gt; // 固定值 &amp;lt;xs:attribute name=&amp;#34;lang&amp;#34; type=&amp;#34;xs:string&amp;#34; use=&amp;#34;required&amp;#34;/&amp;gt; // 缺省情况下可选 type 可选值 xs:string xs:decimal xs:integer xs:boolean xs:date xs:time 属性  &amp;lt;lastname lang=&amp;quot;EN&amp;quot;&amp;gt;Smith&amp;lt;/lastname&amp;gt;  限定  值范围  age 限定为 0 到 120 的整数值 &amp;lt;xs:element name=&amp;quot;age&amp;quot;&amp;gt; &amp;lt;xs:simpleType&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:integer&amp;quot;&amp;gt; &amp;lt;xs:minInclusive value=&amp;quot;0&amp;quot;/&amp;gt; &amp;lt;xs:maxInclusive value=&amp;quot;120&amp;quot;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;/xs:element&amp;gt; letter 属性只接受小写字母 a - z 中零个或多个字母 &amp;lt;xs:element name=&amp;quot;letter&amp;quot;&amp;gt; &amp;lt;xs:simpleType&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:string&amp;quot;&amp;gt; &amp;lt;xs:pattern value=&amp;quot;([a-z])*&amp;quot;/&amp;gt; // value 可使用正则相关约定 &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;/xs:element&amp;gt; address 属性中的所有空白字符（换行、回车、空格以及制表符会被替换为空格，开头和结尾的空格会被移除，而多个连续的空格会被缩减为一个单一的空格）将被移除 &amp;lt;xs:element name=&amp;quot;address&amp;quot;&amp;gt; &amp;lt;xs:simpleType&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:string&amp;quot;&amp;gt; &amp;lt;xs:whiteSpace value=&amp;quot;collapse&amp;quot;/&amp;gt; // value== preserve 时将不进行处理 // value== replace 时将移除所有空白字符 &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;/xs:element&amp;gt;  枚举值
限定类型名称只可选 Audi Golf 和 BMW 写法一： &amp;lt;xs:element name=&amp;#34;car&amp;#34;&amp;gt; &amp;lt;xs:simpleType&amp;gt; &amp;lt;xs:restriction base=&amp;#34;xs:string&amp;#34;&amp;gt; &amp;lt;xs:enumeration value=&amp;#34;Audi&amp;#34;/&amp;gt; &amp;lt;xs:enumeration value=&amp;#34;Golf&amp;#34;/&amp;gt; &amp;lt;xs:enumeration value=&amp;#34;BMW&amp;#34;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;/xs:element&amp;gt; 写法二： &amp;lt;xs:element name=&amp;#34;car&amp;#34; type=&amp;#34;carType&amp;#34;/&amp;gt; &amp;lt;xs:simpleType name=&amp;#34;carType&amp;#34;&amp;gt; &amp;lt;xs:restriction base=&amp;#34;xs:string&amp;#34;&amp;gt; &amp;lt;xs:enumeration value=&amp;#34;Audi&amp;#34;/&amp;gt; &amp;lt;xs:enumeration value=&amp;#34;Golf&amp;#34;/&amp;gt; &amp;lt;xs:enumeration value=&amp;#34;BMW&amp;#34;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; 长度限定
password 属性长度必须为 8 位 &amp;lt;xs:element name=&amp;#34;password&amp;#34;&amp;gt; &amp;lt;xs:simpleType&amp;gt; &amp;lt;xs:restriction base=&amp;#34;xs:string&amp;#34;&amp;gt; &amp;lt;xs:length value=&amp;#34;8&amp;#34;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;/xs:element&amp;gt; password 属性长度可为 5 到 8 位 &amp;lt;xs:element name=&amp;#34;password&amp;#34;&amp;gt; &amp;lt;xs:simpleType&amp;gt; &amp;lt;xs:restriction base=&amp;#34;xs:string&amp;#34;&amp;gt; &amp;lt;xs:minLength value=&amp;#34;5&amp;#34;/&amp;gt; &amp;lt;xs:maxLength value=&amp;#34;8&amp;#34;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;/xs:element&amp;gt;  扩展(数据类型限定) 限定 描述 enumeration 定义可接受值的一个列表 fractionDigits 定义所允许的最大的小数位数。必须大于等于0。 length 定义所允许的字符或者列表项目的精确数目。必须大于或等于0。 maxExclusive 定义数值的上限。所允许的值必须小于此值。 maxInclusive 定义数值的上限。所允许的值必须小于或等于此值。 maxLength 定义所允许的字符或者列表项目的最大数目。必须大于或等于0。 minExclusive 定义数值的下限。所允许的值必需大于此值。 minInclusive 定义数值的下限。所允许的值必需大于或等于此值。 minLength 定义所允许的字符或者列表项目的最小数目。必须大于或等于0。 pattern 定义可接受的字符的精确序列。 totalDigits 定义所允许的阿拉伯数字的精确位数。必须大于0。 whiteSpace 定义空白字符（换行、回车、空格以及制表符）的处理方式。 复合类型 空元素  XML 样式  &amp;lt;product pid=&amp;quot;1345&amp;quot;/&amp;gt;  XSD 写法  &amp;lt;xs:complexType name=&amp;quot;prodtype&amp;quot;&amp;gt; &amp;lt;xs:attribute name=&amp;quot;pid&amp;quot; type=&amp;quot;xs:positiveInteger&amp;quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; 或 &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:complexContent&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:integer&amp;quot;&amp;gt; &amp;lt;xs:attribute name=&amp;quot;pid&amp;quot; type=&amp;quot;xs:positiveInteger&amp;quot;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:complexContent&amp;gt; &amp;lt;/xs:complexType&amp;gt;   复合元素  XML 样式  &amp;lt;employee&amp;gt; &amp;lt;firstname&amp;gt;John&amp;lt;/firstname&amp;gt; &amp;lt;lastname&amp;gt;Smith&amp;lt;/lastname&amp;gt; &amp;lt;/employee&amp;gt;  XSD 写法  &amp;lt;xs:complexType name=&amp;quot;persontype&amp;quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; // 限定元素依序出现 &amp;lt;xs:element name=&amp;quot;firstname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;lastname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt;   仅包含文本的复合元素  XML 样式  &amp;lt;shoesize country=&amp;quot;france&amp;quot;&amp;gt;35&amp;lt;/shoesize&amp;gt;  XSD 写法  &amp;lt;xs:element name=&amp;quot;shoesize&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:simpleContent&amp;gt; // 仅包含简单内容（文本和属性），因此应该使用 xs:simpleContent 标签 &amp;lt;xs:extension base=&amp;quot;xs:integer&amp;quot;&amp;gt; // 填充内容类型 &amp;lt;xs:attribute name=&amp;quot;country&amp;quot; type=&amp;quot;xs:string&amp;quot; /&amp;gt; // 属性名称和其属性 &amp;lt;/xs:extension&amp;gt; &amp;lt;/xs:simpleContent&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt;   包含元素和文本的元素  XML 样式  &amp;lt;letter&amp;gt; Dear Mr.&amp;lt;name&amp;gt;John Smith&amp;lt;/name&amp;gt;. Your order &amp;lt;orderid&amp;gt;1032&amp;lt;/orderid&amp;gt; will be shipped on &amp;lt;shipdate&amp;gt;2001-07-13&amp;lt;/shipdate&amp;gt;. &amp;lt;/letter&amp;gt;  XSD 写法  &amp;lt;xs:element name=&amp;quot;letter&amp;quot;&amp;gt; &amp;lt;xs:complexType mixed=&amp;quot;true&amp;quot;&amp;gt; // 标志字符数据可出现在 Letter 的子元素之间 &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;name&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;orderid&amp;quot; type=&amp;quot;xs:positiveInteger&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;shipdate&amp;quot; type=&amp;quot;xs:date&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt;   写法  纯声明
&amp;lt;xs:element name=&amp;#34;employee&amp;#34;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;#34;firstname&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;lastname&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; 重复引用
&amp;lt;xs:element name=&amp;#34;employee&amp;#34; type=&amp;#34;personinfo&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;student&amp;#34; type=&amp;#34;personinfo&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;member&amp;#34; type=&amp;#34;personinfo&amp;#34;/&amp;gt; &amp;lt;xs:complexType name=&amp;#34;personinfo&amp;#34;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;#34;firstname&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;lastname&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; 复合引用
&amp;lt;xs:element name=&amp;#34;employee&amp;#34; type=&amp;#34;fullpersoninfo&amp;#34;/&amp;gt; &amp;lt;xs:complexType name=&amp;#34;personinfo&amp;#34;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;#34;firstname&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;lastname&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&amp;#34;fullpersoninfo&amp;#34;&amp;gt; &amp;lt;xs:complexContent&amp;gt; &amp;lt;xs:extension base=&amp;#34;personinfo&amp;#34;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;#34;address&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;city&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;country&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:extension&amp;gt; &amp;lt;/xs:complexContent&amp;gt; &amp;lt;/xs:complexType&amp;gt;  指示器  概念  用于控制文档中元素使用的方式  类型  Order 指示器：定义元素顺序  All：规定子元素可按任意顺序出来，且每个子元素必须也只出现一次 Choice：下属只元素只能出现一个 Sequence：必须按照特定顺序出现  Occurrence 指示器：定义某元素的出现频率  注：对于所有的 &amp;ldquo;Order&amp;rdquo; 和 &amp;ldquo;Group&amp;rdquo; 指示器，其中的 maxOccurs 以及 minOccurs 的默认值均为 1。 maxOccurs：规定某个元素可出现的最大次数，其中若值为 unbounded 则不限制次数 minOccurs：规定某个元素能够出现的最小次数  Group 指示器：  Group name ：元素组，内部必须定义一个 all、choice 或者 sequence 元素 attributeGroup name ：属性组   示例  &amp;lt;xs:element name=&amp;quot;person&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:all&amp;gt; &amp;lt;xs:element name=&amp;quot;firstname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;lastname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;/xs:all&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&amp;quot;person&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:choice&amp;gt; &amp;lt;xs:element name=&amp;quot;employee&amp;quot; type=&amp;quot;employee&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;member&amp;quot; type=&amp;quot;member&amp;quot;/&amp;gt; &amp;lt;/xs:choice&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&amp;quot;person&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;firstname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;lastname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&amp;quot;person&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;full_name&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;child_name&amp;quot; type=&amp;quot;xs:string&amp;quot; maxOccurs=&amp;quot;unbounded&amp;quot;/&amp;gt; // 不限制出现次数 &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&amp;quot;person&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;full_name&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;child_name&amp;quot; type=&amp;quot;xs:string&amp;quot; maxOccurs=&amp;quot;10&amp;quot; minOccurs=&amp;quot;0&amp;quot;/&amp;gt; // child_name最少出现0次，最多出现10次 &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&amp;quot;person&amp;quot; type=&amp;quot;personinfo&amp;quot;/&amp;gt; &amp;lt;xs:complexType name=&amp;quot;personinfo&amp;quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:group ref=&amp;quot;persongroup&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;country&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:group name=&amp;quot;persongroup&amp;quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;firstname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;lastname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;birthday&amp;quot; type=&amp;quot;xs:date&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:group&amp;gt; &amp;lt;xs:element name=&amp;quot;person&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:attributeGroup ref=&amp;quot;personattrgroup&amp;quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:attributeGroup name=&amp;quot;personattrgroup&amp;quot;&amp;gt; &amp;lt;xs:attribute name=&amp;quot;firstname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:attribute name=&amp;quot;lastname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:attribute name=&amp;quot;birthday&amp;quot; type=&amp;quot;xs:date&amp;quot;/&amp;gt; &amp;lt;/xs:attributeGroup&amp;gt;   扩展  定义  通过未被 Schema 规定的元素来拓展 XML 文本  Any(任意元素)
 初始定义
&amp;lt;xs:element name=&amp;#34;person&amp;#34;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;#34;firstname&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:element name=&amp;#34;lastname&amp;#34; type=&amp;#34;xs:string&amp;#34;/&amp;gt; &amp;lt;xs:any minOccurs=&amp;#34;0&amp;#34;/&amp;gt; // 预留扩展位置 &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; 拓展元素
&amp;lt;xs:element name=&amp;#34;children&amp;#34;&amp;gt; // 拓展属性 &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;#34;childname&amp;#34; type=&amp;#34;xs:string&amp;#34; maxOccurs=&amp;#34;unbounded&amp;#34;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; XSD 引用
&amp;lt;persons xmlns=&amp;#34;http://www.microsoft.com&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:SchemaLocation=&amp;#34;http://www.microsoft.com family.xsd http://www.w3school.com.cn children.xsd&amp;#34; &amp;gt; &amp;lt;person&amp;gt; &amp;lt;firstname&amp;gt;David&amp;lt;/firstname&amp;gt; &amp;lt;lastname&amp;gt;Smith&amp;lt;/lastname&amp;gt; &amp;lt;children&amp;gt; &amp;lt;childname&amp;gt;mike&amp;lt;/childname&amp;gt; &amp;lt;/children&amp;gt; &amp;lt;/person&amp;gt;  AnyAttribute(任意属性)
 初始定义  &amp;lt;xs:element name=&amp;quot;person&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;firstname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;lastname&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:anyAttribute/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt;  拓展元素  &amp;lt;xs:attribute name=&amp;quot;gender&amp;quot;&amp;gt; &amp;lt;xs:simpleType&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:string&amp;quot;&amp;gt; &amp;lt;xs:pattern value=&amp;quot;male|female&amp;quot;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;/xs:attribute&amp;gt;  XSD 引用  &amp;lt;person gender=&amp;quot;female&amp;quot;&amp;gt; &amp;lt;firstname&amp;gt;Jane&amp;lt;/firstname&amp;gt; &amp;lt;lastname&amp;gt;Smith&amp;lt;/lastname&amp;gt; &amp;lt;/person&amp;gt;    元素替换  定义  进行元素之间的替换，如多语言定义，针对不同国家允许其使用本国语言进行相关的 XML 格式定义  示例  XSD 定义  &amp;lt;xs:element name=&amp;quot;name&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;navn&amp;quot; substitutionGroup=&amp;quot;name&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;customer&amp;quot; type=&amp;quot;custinfo&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;kunde&amp;quot; substitutionGroup=&amp;quot;customer&amp;quot;/&amp;gt; &amp;lt;xs:complexType name=&amp;quot;custinfo&amp;quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element ref=&amp;quot;name&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt;  有效 XML  &amp;lt;customer&amp;gt; &amp;lt;name&amp;gt;John Smith&amp;lt;/name&amp;gt; &amp;lt;/customer&amp;gt; &amp;lt;kunde&amp;gt; &amp;lt;navn&amp;gt;John Smith&amp;lt;/navn&amp;gt; &amp;lt;/kunde&amp;gt;   注  // 防止其它元素替换指定元素 substitutionGroup 作用的元素，都必须声明为全局元素  全局元素： Schema 层级下的直接子元素    解析实例 XML 数据 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;ISO-8859-1&amp;#34;?&amp;gt; &amp;lt;shiporder orderid=&amp;#34;889923&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:noNamespaceSchemaLocation=&amp;#34;shiporder.xsd&amp;#34;&amp;gt; &amp;lt;orderperson&amp;gt;George Bush&amp;lt;/orderperson&amp;gt; &amp;lt;shipto&amp;gt; &amp;lt;name&amp;gt;John Adams&amp;lt;/name&amp;gt; &amp;lt;address&amp;gt;Oxford Street&amp;lt;/address&amp;gt; &amp;lt;city&amp;gt;London&amp;lt;/city&amp;gt; &amp;lt;country&amp;gt;UK&amp;lt;/country&amp;gt; &amp;lt;/shipto&amp;gt; &amp;lt;item&amp;gt; &amp;lt;title&amp;gt;Empire Burlesque&amp;lt;/title&amp;gt; &amp;lt;note&amp;gt;Special Edition&amp;lt;/note&amp;gt; &amp;lt;quantity&amp;gt;1&amp;lt;/quantity&amp;gt; &amp;lt;price&amp;gt;10.90&amp;lt;/price&amp;gt; &amp;lt;/item&amp;gt; &amp;lt;item&amp;gt; &amp;lt;title&amp;gt;Hide your heart&amp;lt;/title&amp;gt; &amp;lt;quantity&amp;gt;1&amp;lt;/quantity&amp;gt; &amp;lt;price&amp;gt;9.90&amp;lt;/price&amp;gt; &amp;lt;/item&amp;gt; &amp;lt;/shiporder&amp;gt; XSD 格式  写法一  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;ISO-8859-1&amp;quot; ?&amp;gt; &amp;lt;xs:schema xmlns:xs=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot;&amp;gt; &amp;lt;xs:element name=&amp;quot;shiporder&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;orderperson&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;shipto&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;name&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;address&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;city&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;country&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element maxOccurs=&amp;quot;unbounded&amp;quot; name=&amp;quot;item&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;title&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element minOccurs=&amp;quot;0&amp;quot; name=&amp;quot;note&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;quantity&amp;quot; type=&amp;quot;xs:positiveInteger&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;price&amp;quot; type=&amp;quot;xs:decimal&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:attribute name=&amp;quot;orderid&amp;quot; type=&amp;quot;xs:string&amp;quot; use=&amp;quot;required&amp;quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;/xs:schema&amp;gt;  写法二  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;ISO-8859-1&amp;quot; ?&amp;gt; &amp;lt;xs:schema xmlns:xs=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot;&amp;gt; &amp;lt;!-- 简易元素的定义 --&amp;gt; &amp;lt;xs:element name=&amp;quot;orderperson&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;name&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;address&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;city&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;country&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;title&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;note&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;quantity&amp;quot; type=&amp;quot;xs:positiveInteger&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;price&amp;quot; type=&amp;quot;xs:decimal&amp;quot;/&amp;gt; &amp;lt;!-- 属性的定义 --&amp;gt; &amp;lt;xs:attribute name=&amp;quot;orderid&amp;quot; type=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;!-- 复合元素的定义--&amp;gt; &amp;lt;xs:element name=&amp;quot;shipto&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element ref=&amp;quot;name&amp;quot;/&amp;gt; &amp;lt;xs:element ref=&amp;quot;address&amp;quot;/&amp;gt; &amp;lt;xs:element ref=&amp;quot;city&amp;quot;/&amp;gt; &amp;lt;xs:element ref=&amp;quot;country&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&amp;quot;item&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt;n &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element ref=&amp;quot;title&amp;quot;/&amp;gt; &amp;lt;xs:element minOccurs=&amp;quot;0&amp;quot; ref=&amp;quot;note&amp;quot;/&amp;gt; &amp;lt;xs:element ref=&amp;quot;quantity&amp;quot;/&amp;gt; &amp;lt;xs:element ref=&amp;quot;price&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;xs:element name=&amp;quot;shiporder&amp;quot;&amp;gt; &amp;lt;xs:complexType&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element ref=&amp;quot;orderperson&amp;quot;/&amp;gt; &amp;lt;xs:element ref=&amp;quot;shipto&amp;quot;/&amp;gt; &amp;lt;xs:element maxOccurs=&amp;quot;unbounded&amp;quot; ref=&amp;quot;item&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:attribute ref=&amp;quot;orderid&amp;quot; use=&amp;quot;required&amp;quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;/xs:element&amp;gt; &amp;lt;/xs:schema&amp;gt;  写法三  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;ISO-8859-1&amp;quot; ?&amp;gt; &amp;lt;xs:schema xmlns:xs=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot;&amp;gt; &amp;lt;xs:simpleType name=&amp;quot;stringtype&amp;quot;&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:string&amp;quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&amp;quot;inttype&amp;quot;&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:positiveInteger&amp;quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&amp;quot;dectype&amp;quot;&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:decimal&amp;quot;/&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:simpleType name=&amp;quot;orderidtype&amp;quot;&amp;gt; &amp;lt;xs:restriction base=&amp;quot;xs:string&amp;quot;&amp;gt; &amp;lt;xs:pattern value=&amp;quot;[0-9]{6}&amp;quot;/&amp;gt; &amp;lt;/xs:restriction&amp;gt; &amp;lt;/xs:simpleType&amp;gt; &amp;lt;xs:complexType name=&amp;quot;shiptotype&amp;quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;name&amp;quot; type=&amp;quot;stringtype&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;address&amp;quot; type=&amp;quot;stringtype&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;city&amp;quot; type=&amp;quot;stringtype&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;country&amp;quot; type=&amp;quot;stringtype&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&amp;quot;itemtype&amp;quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;title&amp;quot; type=&amp;quot;stringtype&amp;quot;/&amp;gt; &amp;lt;xs:element minOccurs=&amp;quot;0&amp;quot; name=&amp;quot;note&amp;quot; type=&amp;quot;stringtype&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;quantity&amp;quot; type=&amp;quot;inttype&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;price&amp;quot; type=&amp;quot;dectype&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:complexType name=&amp;quot;shipordertype&amp;quot;&amp;gt; &amp;lt;xs:sequence&amp;gt; &amp;lt;xs:element name=&amp;quot;orderperson&amp;quot; type=&amp;quot;stringtype&amp;quot;/&amp;gt; &amp;lt;xs:element name=&amp;quot;shipto&amp;quot; type=&amp;quot;shiptotype&amp;quot;/&amp;gt; &amp;lt;xs:element maxOccurs=&amp;quot;unbounded&amp;quot; name=&amp;quot;item&amp;quot; type=&amp;quot;itemtype&amp;quot;/&amp;gt; &amp;lt;/xs:sequence&amp;gt; &amp;lt;xs:attribute name=&amp;quot;orderid&amp;quot; type=&amp;quot;orderidtype&amp;quot; use=&amp;quot;required&amp;quot;/&amp;gt; &amp;lt;/xs:complexType&amp;gt; &amp;lt;xs:element name=&amp;quot;shiporder&amp;quot; type=&amp;quot;shipordertype&amp;quot;/&amp;gt; &amp;lt;/xs:schema&amp;gt;   数据类型 字符串  可选类型  xs:string：可包含字符、换行、回车以及制表符。 xs:normalizedString：可包含字符，但是 XML 处理器会移除折行，回车以及制表符。 xs:token：可包含字符，但是 XML 处理器会移除换行符、回车、制表符、开头和结尾的空格以及（连续的）空格。  支持限定  enumeration length maxLength minLength pattern (NMTOKENS、IDREFS 以及 ENTITIES 无法使用此约束) whiteSpace   日期  可选类型  xs:date：时间格式为 YYYY-MM-DD xs:time：时间格式为 hh:mm:ss xs:dateTime：时间格式为 YYYY-MM-DDThh:mm:ss，限定输入应为 2002-05-30T09:00:00[.5] xs:duration：用于规定时间间隔，时间格式为 PnYnMnDTnHnMnS  P 表示周期(必需) nY 表示年数 nM 表示月数 nD 表示天数 T 表示时间部分的起始 （如果您打算规定小时、分钟和秒，则此选项为必需） nH 表示小时数 nM 表示分钟数 nS 表示秒数  示例：  P5Y2M10DT15H 表示周期为 5年2个月10天及15小时   支持限定  enumeration maxExclusive maxInclusive minExclusive minInclusive pattern whiteSpace   ###数值 - 可选类型 - xs:decimal：十进制数据，最大位数为 18 位 - xs:integer：整数 - 支持限定 - enumeration - fractionDigits - maxExclusive - maxInclusive - minExclusive - minInclusive - pattern - totalDigits - whiteSpace
杂项  类型  布尔值  xs:boolean：逻辑项，仅可输入 true | false  二进制  xs:hexBinary：十六进制编码的二进制数据 xs:base64Binary：Base64 编码的二进制数据  URI  xs:anyURI：用于限定输入值仅可为 URL，且若含有空格，需用 %20 替换。   支持限定  enumeration (布尔数据类型无法使用此约束*) length (布尔数据类型无法使用此约束) maxLength (布尔数据类型无法使用此约束) minLength (布尔数据类型无法使用此约束) pattern whiteSpace   </content>
    </entry>
    
     <entry>
        <title>Oracle.分析函数</title>
        <url>http://domain.yqjdcyy.com/post/oracle.%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Oracle</tag>
        </tags>
        <content type="html">  统计方面 合并  Sum( ) Over ([Partition by ] [Order by ]) ROLLUP(COL1, COL2&amp;hellip;)  按照COLX的降序层次逐层汇总合并  CUBE(COL1, COL2&amp;hellip;)  排序  Rank() Over ([Partition by ] [Order by ] [Nulls First/Last])  相同数据排名一致，但下一记录会空出其中的排名  Dense_rank() Over ([Patition by ] [Order by ] [Nulls First/Last])  相同数据排名一致，之后数据接上一次序继续  Row_number() Over ([Partitionby ] [Order by ] [Nulls First/Last])  碰到相同数据时不做处理依照记录顺序依次递增  Ntile( ) Over ([Partition by ] [Order by ])  最值  [Min|Max]() Keep (Dense_rank First/Last [Partition by ] [Order by ])  MIN 用于确保返回唯一记录 KEEP 用于告知Oracle保留符合KEEP条件的记录 Dense_rank 固定写法，不可更改  Ratio_to_report(value)  Ratio_to_report(value)= value/ sum(value)   首/末记录  [First_value|Last_value|(Sum() Over ([Patition by ] [Order by ] Rows Between Preceding And Following ))  相邻记录比较  LAG(其它行表达式, &amp;lt;偏移行数，缺省为1&amp;gt;, &amp;lt;偏移行数超出分组范围时的返回值&amp;gt;)  LAG(SUM( ), 1) OVER([PATITION BY] [ORDER BY ])  LEAD(其它行表达式, &amp;lt;偏移行数，缺省为1&amp;gt;, &amp;lt;偏移行数超出分组范围时的返回值&amp;gt;)  LEAD(SUM( ), 1) OVER([PATITION BY] [ORDER BY ])   家族树  START WITH COL1= &amp;lsquo;XXX&amp;rsquo; CONNECT BY COL1= PRIOR COL2  语法  1&amp;gt;语句顺序：SELECT&amp;gt; FROM&amp;gt; WHERE&amp;gt; START WITH&amp;gt; CONNECT BY&amp;gt; ORDER BY 2&amp;gt;PRIOR位置：在前（CONNECT BY PRIOR COL1=COL2），强制由根到叶自顶向上，置于后面则相反由叶到根 3&amp;gt;WHERE可以排除树中个体，但无法排除其子孙或祖先 4&amp;gt;CONNECT BY条件则可以排除个体及其后代信息 5&amp;gt;CONNECT BY不以和WHERE子句中表连接使用  例子  SELECT LEVEL, NVL(B.COW, &#39;EVES-COW&#39;) COW, NVL(B.BULL, &#39;EVE-BULL&#39;) BULL, NVL(LPAD(B.OFFSPRING, 6*(LEVEL- 1), &#39; &#39;), &#39;EVE&#39;)AS OFFSPRING, --LEVEL为相当于树层级，为自动带出 B.SEX, B.BIRTHDATE FROM BREEDING B START WITH B.OFFSPRING= &#39;EVE&#39; --起始节点 CONNECT BY COW= PRIOR B.OFFSPRING --相当于自表关联的条件 AND B.OFFSPRING!= &#39;MANDY&#39;; --有效地去除该分支，而不像WHERE只能去除该指定对象    </content>
    </entry>
    
     <entry>
        <title>AngularJS.Basic</title>
        <url>http://domain.yqjdcyy.com/post/angularjs.basic/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>AngularJS</tag>
        </tags>
        <content type="html">  导言和准备  地址 源码 图解Git  引导程序 参考 - 详细：http://angularjs.cn/A003 - 源码：https://github.com/angular/angular-phonecat - 环境：https://github.com/nodejs/node-gyp - 安装异常：http://stackoverflow.com/questions/21365714/nodejs-error-installing-with-npm - 安装异常：http://blog.sina.com.cn/s/blog_9b624c5d0102vgwl.html  启动服务  npm install npm start
 需要行先安装 python，仅目前只支持 2.*.，不支持 3..* 并将 git 设置为环境变量，即将 D:\Program Files (x86)\Git\bin\;D:\Program Files (x86)\Git\libexec\git-core; 加入环境变量中
 注：有时需要重启才能生效 更多注意事项请看 https://github.com/nodejs/node-gyp
测试服务   npm test
切换服务 git checkout -f step-0
 其中各阶段主要重点均在 https://github.com/angular/angular-phonecat
应用界面  http://localhost:8000/app/index.html
核心代码解析 &amp;lt;!-- np-app 指令，用于标记 AngularJS 脚本的作用域 --&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34; ng-app&amp;gt; &amp;lt;!-- 加载 AngularJS 脚本 --&amp;gt; &amp;lt;script src=&amp;#34;bower_components/angular/angular.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- {{&amp;#39;yet&amp;#39; &#43; &amp;#39;!&amp;#39;}} 表示绑定功能，用于将运算结果插入 DOM 中 --&amp;gt; &amp;lt;p&amp;gt;Nothing here {{&amp;#39;yet&amp;#39; &#43; &amp;#39;!&amp;#39;}}&amp;lt;/p&amp;gt;&amp;lt;br/&amp;gt;  AngularJS模板 地址  详细：http://angularjs.cn/A005 ngController：https://docs.angularjs.org/api/ng/directive/ngController ngRepeat：https://docs.angularjs.org/api/ng/directive/ngRepeat
特点 在AngularJS中，一个视图是模型通过HTML模板渲染之后的映射。
 这意味着，不论模型什么时候发生变化，AngularJS会实时更新结合点，随之更新视图。 ``` 注： Header {{ item }} Body {{ item }} Footer {{ item }} // 在控制器中初始化数据，其中 scope 指代作用域 // 方法一 var phonecatApp = angular.module(&amp;lsquo;phonecatApp&amp;rsquo;, []); phonecatApp.controller(&amp;lsquo;PhoneListCtrl&amp;rsquo;, function($scope) { $scope.hello=&amp;ldquo;hello, world&amp;rdquo;; $scope.phones = [ {&amp;lsquo;name&amp;rsquo;: &amp;lsquo;Nexus S&amp;rsquo;, &amp;lsquo;snippet&amp;rsquo;: &amp;lsquo;Fast just got faster with Nexus S.&amp;rsquo;} ]; });
  // 方法二 angular.module(&amp;lsquo;controllerAsExample&amp;rsquo;, []) .controller(&amp;lsquo;SettingsController1&amp;rsquo;, SettingsController1); function SettingsController1() { this.name = &amp;ldquo;John Smith&amp;rdquo;; this.contacts = [ {type: &amp;lsquo;phone&amp;rsquo;, value: &amp;lsquo;408 555 1212&amp;rsquo;}, {type: &amp;lsquo;email&amp;rsquo;, value: &amp;lsquo;john.smith@example.org&amp;rsquo;} ]; } // 为控制器提供方法 SettingsController1.prototype.greet = function() { alert(this.name); };
### 迭代器 - 地址 &#43; 详细：http://angularjs.cn/A006 - 示例 {{val}} index.html controllers.js $scope.orderProp = &amp;lsquo;name&amp;rsquo;;
### XHR和依赖注入 - 地址 - 详细：http://angularjs.cn/A008 $Http：https://code.angularjs.org/1.1.0/docs/api/ng.$http - 关于 Angular.js 你需要知道的知识： http://codethoughts.info/angular.js/2015/05/15/things-i-wish-i-were-told-about-angular-js/ - AngularJS 单元测试： http://codethoughts.info/javascript/2015/09/06/angularjs-apps-unit-testing/ - 依赖注入 - 异步响应，且 Angular 会自动检测应答并解析 ``` function PhoneListCtrl($scope, $http) { $http.get(&amp;#39;phones/phones.json&amp;#39;).success(function(data) { $scope.phones = data; }); $scope.orderProp = &amp;#39;age&amp;#39;; } ``` - 避免压缩造成系统无法识别参数 ``` var PhoneListCtrl = [&amp;#39;$scope&amp;#39;, &amp;#39;$http&amp;#39;, function($scope, $http) { /* constructor body */ }]; ``` ### 建议 - `$` 前缀为 AngularJS 内部使用前缀，不建议使用 ### 测试 - 注入指定的函数， - $httpBackend 为 XMLHttpRequest 或 JSONP 的兼容 HTTP 后端，使用时使用高层次抽象的 $http 等 ，测试时用于模拟 HTTP 服务器实现 - inject(function(_$httpBackend_, $rootScope, $controller) {} - 为每个执行创建新作用域 - $rootScope.$new(); - 将新作用域传递给 PhoneListCtrl - $controller(PhoneListCtrl, {$scope: scope}); - 通知等待 HTTP 请求并确认响应方式 - $httpBackend.expectGET(&amp;#39;phones/phones.json&amp;#39;).respond([{name: &amp;#39;Nexus S&amp;#39;}, {name: &amp;#39;Motorola DROID&amp;#39;}]); - 清空请求队列，使用请求实际发出并得到响应 - $httpBackend.flush() ## 链接与图片模板 ### 地址 - 详细：http://angularjs.cn/A009 - ngSrc：https://code.angularjs.org/1.1.0/docs/api/ng.directive:ngSrc ### 数据 - &amp;#34;imageUrl&amp;#34;: &amp;#34;img/phones/motorola-defy-with-motoblur.0.jpg&amp;#34; ### 链接 - ng-src 同 src，但使用 img 时浏览器一遇到就会向未编译的 URL 发送一个请求，但 AngularJS 只在页面载入完成后开始编译从而得到正确的 URL 地址 - `&amp;lt;img ng-src=&amp;#34;{{phone.imageUrl}}&amp;#34;&amp;gt;` ## 依赖注入 ### 地址 - 详细：http://angularjs.cn/A00z ### 依赖实现 - 它的依赖是能被创建的，一般用new操作符就行。 - 能够通过全局变量查找依赖。 - 依赖能在需要时被导入。 ### 注入器服务 angular.module(&amp;lsquo;myModule&amp;rsquo;, []). // 创建&amp;rsquo;greeter&amp;rsquo;时需依赖&amp;rsquo;$window&amp;rsquo; factory(&amp;lsquo;greeter&amp;rsquo;, function($window) { // 创建&amp;rsquo;greet&amp;rsquo;的工厂方法 return { greet: function(text) { $window.alert(text); } }; }). // 由 module 中创建注入器，正常由 Angular bootstrap 自动实现 var injector = angular.injector(&amp;lsquo;myModule&amp;rsquo;); // 向注入器请求依赖 var greeter = injector.get(&amp;lsquo;greeter&amp;rsquo;);
### 分离控制器和注入器 Hello  function MyController($scope, greeter) { $scope.sayHello = function() { greeter(&amp;lsquo;Hello World&amp;rsquo;); }; } // The &amp;lsquo;ng-controller&amp;rsquo; directive does this behind the scenes injector.instantiate(MyController);
### 依赖标记 Angular 提供等效依赖方式 推荐依赖 function MyController($scope, greeter) { // $scope, greeter 均需注入到函数中的依赖 // 这种方法无法使用压缩混淆，因为参数名的改变而导致其无效 } $inject 标记 var MyController = function(renamed$scope, renamedGreeter) {&amp;hellip;} MyController.$inject = [&amp;lsquo;$scope&amp;rsquo;, &amp;lsquo;greeter&amp;rsquo;]; 行内标记 someModule.factory(&amp;lsquo;greeter&amp;rsquo;, [&amp;lsquo;$window&amp;rsquo;, function(renamed$window) {&amp;hellip;;}]); 等价于 var greeterFactory = function(renamed$window) {&amp;hellip;;}; greeterFactory.$inject = [&amp;lsquo;$window&amp;rsquo;]; someModule.factory(&amp;lsquo;greeter&amp;rsquo;, greeterFactory);
### 工厂方法 angualar.module(&amp;lsquo;myModule&amp;rsquo;, []). config([&amp;lsquo;depProvider&amp;rsquo;, function(depProvider){ &amp;hellip; }]). factory(&amp;lsquo;serviceId&amp;rsquo;, [&amp;lsquo;depService&amp;rsquo;, function(depService) { &amp;hellip; }]). directive(&amp;lsquo;directiveName&amp;rsquo;, [&amp;lsquo;depService&amp;rsquo;, function(depService) { &amp;hellip; }]). filter(&amp;lsquo;filterName&amp;rsquo;, [&amp;lsquo;depService&amp;rsquo;, function(depService) { &amp;hellip; }]). run([&amp;lsquo;depService&amp;rsquo;, function(depService) { &amp;hellip; }]);
## 路由与多视图 ### 地址 - 详细：http://angularjs.cn/A00a ### 目录结构 /app/index.html /app/partials/phone-list.html /app/partials/phone-detail.html
### index.html // 模板点位符，配合 $route 使用 
### app.js // 引入 phonecatApp 模块并配置路由、控制器 var phonecatApp = angular.module(&amp;lsquo;phonecatApp&amp;rsquo;, [&amp;lsquo;ngRoute&amp;rsquo;, &amp;lsquo;phonecatControllers&amp;rsquo;]); // 路由配置= 指定路径-&amp;gt; 跳转界面&#43; 控制器 phonecatApp.config([&amp;lsquo;$routeProvider&amp;rsquo;, function($routeProvider) { $routeProvider. when(&amp;lsquo;/phones&amp;rsquo;, {templateUrl: &amp;lsquo;partials/phone-list.html&amp;rsquo;,controller: &amp;lsquo;PhoneListCtrl&amp;rsquo;}). when(&amp;lsquo;/phones/:phoneId&amp;rsquo;, {templateUrl: &amp;lsquo;partials/phone-detail.html&amp;rsquo;,controller: &amp;lsquo;PhoneDetailCtrl&amp;rsquo;}). // :phoneId 表示输入参数，将自动被提取至 $routeParams 对象 otherwise({redirectTo: &amp;lsquo;/phones&amp;rsquo;}); }]);
### controllers.js // 获取参数值并填充至全局对象中。支持压缩写法 phonecatControllers.controller(&amp;lsquo;PhoneDetailCtrl&amp;rsquo;, [&amp;lsquo;$scope&amp;rsquo;, &amp;lsquo;$routeParams&amp;rsquo;, function($scope, $routeParams) { $scope.phoneId = $routeParams.phoneId; }]);
### 参数解析 phonecatApp：DI 实现模块化对象 phonecatControllers：ID 实现控制器模块化对象 PhoneDetailCtrl：控制器实例
## 过滤器 ### 地址： - 详细：http://angularjs.cn/A00c ### 流程 &#43; 界面引用 filter.js &#43; ngApp 中 moudle phonecatFilters，如 angular.module(&amp;#39;phonecat&amp;#39;, [&amp;#39;phonecatFilters&amp;#39;]) &#43; 指定字段调用 {{ expression | filter }} ### 定义 angular.module(&amp;lsquo;phonecatFilters&amp;rsquo;, []).filter(&amp;lsquo;checkmark&amp;rsquo;, function() { return function(input) { return input ? &amp;lsquo;\u2713&amp;rsquo; : &amp;lsquo;\u2718&amp;rsquo;; }; });
### 内置过滤器currency：格式化为货币 {{num | currency : &amp;#39;￥&amp;#39;}} date {{1304375948024 | date}} {{1304375948024 | date:&amp;#34;MM/dd//yyyy @ h:mma&amp;#34;}} filter：过滤文字是否包含指定内容 json：转化为 JSON 格式 limitTo lowercase/ uppercase number orderBy## 事件处理器 ### 地址 - 详细：http://angularjs.cn/A00d ### 定义全局方法 function PhoneDetailCtrl($scope, $routeParams, $http) { $scope.setImage = function(imageUrl) { $scope.mainImageUrl = imageUrl; } }
### 事件绑定 // 参数若引用全局值，不需要再加 {{}} AngularJS入门教程11：REST和定制服务 http://angularjs.cn/A00e $resource： https://code.angularjs.org/1.1.0/docs/api/ngResource.$resource 步骤 app/js/services.js 定义 REST 服务 app/js/app.js 注册时依赖模块 app/js/controllers.js 控制器 app/index.html 界面引用 ngResource 模块
实现 定义 REST 服务 // 定义工厂服务 Phone // 服务格式：$resource(url[, paramDefaults][, actions]); // 默认包含 // { // &amp;lsquo;get&amp;rsquo;: {method:&amp;lsquo;GET&amp;rsquo;}, // &amp;lsquo;save&amp;rsquo;: {method:&amp;lsquo;POST&amp;rsquo;}, // &amp;lsquo;query&amp;rsquo;: {method:&amp;lsquo;GET&amp;rsquo;, isArray:true}, // &amp;lsquo;remove&amp;rsquo;: {method:&amp;lsquo;DELETE&amp;rsquo;}, // &amp;lsquo;delete&amp;rsquo;: {method:&amp;lsquo;DELETE&amp;rsquo;} // }; angular.module(&amp;lsquo;phonecatServices&amp;rsquo;, [&amp;lsquo;ngResource&amp;rsquo;]). factory(&amp;lsquo;Phone&amp;rsquo;, function($resource){ return $resource( &amp;lsquo;phones/:phoneId.json&amp;rsquo;, {}, { query: {method:&amp;lsquo;GET&amp;rsquo;, params:{phoneId:&amp;lsquo;phones&amp;rsquo;}, isArray:true} } ); }); 添加服务依赖： angular.module(&amp;lsquo;phonecat&amp;rsquo;, [&amp;lsquo;phonecatFilters&amp;rsquo;, &amp;lsquo;phonecatServices&amp;rsquo;]) 数据查询 phonecatControllers.controller(&amp;lsquo;PhoneListCtrl&amp;rsquo;, [&amp;lsquo;$scope&amp;rsquo;, &amp;lsquo;Phone&amp;rsquo;, function($scope, Phone) { $scope.phones = Phone.query(); // 调用 Service 的指定服务 query }]); phonecatControllers.controller(&amp;lsquo;PhoneDetailCtrl&amp;rsquo;, [&amp;lsquo;$scope&amp;rsquo;, &amp;lsquo;$routeParams&amp;rsquo;, &amp;lsquo;Phone&amp;rsquo;, function($scope, $routeParams, Phone) { $scope.phone = Phone.get({phoneId: $routeParams.phoneId}, function(phone) { $scope.mainImageUrl = phone.images[0]; }); }]);
- 注意： - 调用 Phone 服务时未传递任何回调函数，但非同步返回。 - 被同步返回的为 Future 对象，当 XHR 相应返回时将填充进数据 ## AngularJS补充 ### 介绍 - 为动态WEB应用设计的结构框架，利用 数据绑定 和 依赖注入 补充 HTML 的不足 - AngularJS 的 HTML 编译器能让浏览器识别新的 HTML 语法，从而关联到 HTML 元素或属性上 -&amp;gt; 指令 - 特定领域语言（Domain Specific Language） ### 标识符实现 - 使用双大括号{{}}语法进行数据绑定； - 使用DOM控制结构来实现迭代或者隐藏DOM片段； - 支持表单和表单的验证； - 能将逻辑代码关联到相关的DOM元素上； - 能将HTML分组成可重用的组件。 ### 适用 - 构建 CRUD 工程， - 支持数据绑定 - 基本模板标识符 - 表单验证 - 路由 - 深度链接 - 组件重用 - 依赖注入 ### 编译 - 编译 &#43; 遍历 DOM 并收集所有指令，生成一个链接函数 - 链接 &#43; 给指令绑定作用域，生成动态视图。作用域模型的任何改变都会反映到视图上。 ### 指令 - ng-app 自动初始化 载入和指令内容相关的模块 创建一个应用的注入器（Injector） 拥有 ngApp 的标签将指定为 AngularJS 应用 注：手动初始化 代码  angular.element(document).ready(function() { angular.bootstrap(document); });  遵守顺序 等页面和所有脚本加载完成后指定要成为 AngularJS 应用的节点 调用 api/angular.bootstrap 将模板编译成可执行的、数据双向绑定的应用程序 ```
</content>
    </entry>
    
     <entry>
        <title>常用技术</title>
        <url>http://domain.yqjdcyy.com/post/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  灰化 grayscale(document.body); 遮罩 //隐藏页面上一些特殊的控件 function HideElement(){ var HideElementTemp = new Array(&amp;#39;IMG&amp;#39;,&amp;#39;SELECT&amp;#39;,&amp;#39;OBJECT&amp;#39;,&amp;#39;IFRAME&amp;#39;); for(var j=0;j&amp;lt;HideElementTemp.length;j&#43;&#43;){ try{ var strElementTagName=HideElementTemp[j]; for(i=0;i&amp;lt;document.all.tags(strElementTagName).length; i&#43;&#43;){ var objTemp = document.all.tags(strElementTagName)[i]; if(!objTemp||!objTemp.offsetParent) continue; //objTemp.style.visibility=&amp;#34;hidden&amp;#34;; objTemp.disabled=&amp;#34;disabled&amp;#34; } } catch(e){} } } //隐藏特殊控件&#43; 全网页置灰 function MaskAndGray(){ HideElement(); grayscale(document.body); //全网页置灰 var shield = document.createElement(&amp;#34;DIV&amp;#34;); //产生一个背景遮罩层 shield.id = &amp;#34;shield&amp;#34;; shield.style.position = &amp;#34;absolute&amp;#34;; shield.style.left = &amp;#34;0px&amp;#34;; shield.style.top = &amp;#34;0px&amp;#34;; shield.style.width = &amp;#34;100%&amp;#34;; shield.style.height = ((document.documentElement.clientHeight&amp;gt;document.documentElement.scrollHeight)?document.documentElement.clientHeight:document.documentElement.scrollHeight)&#43;&amp;#34;px&amp;#34;; shield.style.background = &amp;#34;#333&amp;#34;; shield.style.textAlign = &amp;#34;center&amp;#34;; shield.style.zIndex = &amp;#34;10000&amp;#34;; shield.style.filter = &amp;#34;alpha(opacity=0)&amp;#34;; shield.style.opacity = 0; document.body.appendChild(shield); /* var alertFram = document.createElement(&amp;#34;DIV&amp;#34;); //产生一个提示框 var height=&amp;#34;45px&amp;#34;; alertFram.id=&amp;#34;alertFram&amp;#34;; alertFram.style.position = &amp;#34;absolute&amp;#34;; alertFram.style.width = &amp;#34;200px&amp;#34;; alertFram.style.height = height; alertFram.style.left = &amp;#34;35%&amp;#34;; alertFram.style.top = &amp;#34;30%&amp;#34;; alertFram.style.background = &amp;#34;#fff&amp;#34;; alertFram.style.textAlign = &amp;#34;center&amp;#34;; alertFram.style.lineHeight = height; alertFram.style.zIndex = &amp;#34;10001&amp;#34;; alertFram.innerHTML=msg; document.body.appendChild(alertFram); //将遮罩与提示添加至当前界面 */ this.setOpacity = function(obj,opacity){ if(opacity&amp;gt;=1)opacity=opacity/100; try{ obj.style.opacity=opacity; }catch(e){} try{ if(obj.filters.length&amp;gt;0&amp;amp;&amp;amp;obj.filters(&amp;#34;alpha&amp;#34;)){ obj.filters(&amp;#34;alpha&amp;#34;).opacity=opacity*100; }else{ obj.style.filter=&amp;#34;alpha(opacity=\&amp;#34;&amp;#34;&#43;(opacity*100)&#43;&amp;#34;\&amp;#34;)&amp;#34;; } } catch(e){} } var c = 0; this.doAlpha = function(){ if (&#43;&#43;c &amp;gt; 20){clearInterval(ad);return 0;} setOpacity(shield,c); } var ad = setInterval(&amp;#34;doAlpha()&amp;#34;,1);//渐变效果 document.body.onselectstart = function(){return false;} document.body.oncontextmenu = function(){return false;} } java读取properties Properties po = new Properties(); InputStream in = null; String dwzszfVersion = &amp;#34;&amp;#34;; try { in = TbYwJjxmWpzListAction.class.getResourceAsStream(&amp;#34;/intelliweb2Syncweb.properties&amp;#34;); po.load(in); if(po.containsKey(&amp;#34;url4IntelliWeb2SyncWeb&amp;#34;)){ dwzszfVersion = po.getProperty(&amp;#34;url4IntelliWeb2SyncWeb&amp;#34;); } } catch (IOException e) { e.printStackTrace(); }finally{ try { if(in!=null){ in.close(); } } catch (IOException e) { e.printStackTrace(); } } java调用控制台指令 String[] cmd = new String[5]; cmd[0] = &amp;#34;cmd&amp;#34;; cmd[1] = &amp;#34;/c&amp;#34;; cmd[2] = &amp;#34;start&amp;#34;; cmd[3] = &amp;#34; &amp;#34;; cmd[4] = localTempPath; Runtime.getRuntime().exec(cmd); SERVLET文件下载 文件服务支持形式 WEB.XML文件配置 &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;FileBatchDownServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;com.longtop.ywgl.fileUpload.web.FileBatchDownServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;FileBatchDownServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/fileBatchDownServlet&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; 界面调用方式 /** * 文件批量下载功能 * @author 姚清居 * @param wjbhs 指定文件编号，并以逗号格开 * @param fileName 指定下载文件的名称 * @return false 无作用，只针对于使用open方式打开时的强制返回 */ function fileBatchDown(wjbhs, fileName){ var id= window.open(&amp;#34;/ggzypz/fileBatchDownServlet?wjbhs=&amp;#34;&#43; wjbhs&#43; &amp;#34;&amp;amp;fileName=&amp;#34;&#43; fileName); return false; } 代码实现 /*** * 文件批量下载 * @author 姚清居 * */ public class FileBatchDownServlet extends HttpServlet { /** * 序列号 */ private static final long serialVersionUID = 998L; private static final int BUFFER = 2048; /*** * @author 姚清居 * * 初始实现逻辑： * 1、获取指定文档对应的各文件编号，并以，隔开 * 2、关联查询出该批次的文件编号对应的上传文件的文件名称及现文件名称 * 3、保存至本地的C盘/报名审核文件_当前系统时期（精确至毫秒）的文件夹中 * 4、保存完成后默认打开该文件夹 * 异常： * 该种方式的文件只会默认保存在服务器的C盘，而非用户的C盘 * * 更新逻辑 * 1和2、3步骤不变 * 4、重新进行读取临时文件夹中的各文件信息，并将之一起封闭成Zip文件 * 5、将之作为输出流返回给客户端 * @throws IOException */ @SuppressWarnings(&amp;#34;unchecked&amp;#34;) protected void doPost(HttpServletRequest requse, HttpServletResponse response) throws IOException { String wjbhs = requse.getParameter(&amp;#34;wjbhs&amp;#34;); String fileName = requse.getParameter(&amp;#34;fileName&amp;#34;); YwglBaseService ywglBaseService = (YwglBaseService) SpringBeanFactory.getBean(YwglBaseService.BEAN_ID); String localZip = &amp;#34;C:/报名审核文件_&amp;#34;&#43; DateUtil.getNow(DateEnum.YYYYMMDDHHMMSSSSS)&#43; &amp;#34;.zip&amp;#34;; File zipFile=new File(localZip); FTPClient ftp= FTPUtil.getFTPClient(); byte data[]= new byte[BUFFER]; int count; InputStream is = null; OutputStream out = null; ZipOutputStream zipOut= null; try { //查询指定文件编号对应文件名称 Map param= new HashMap&amp;lt;String, String&amp;gt;(); param.put(&amp;#34;wjbhs&amp;#34;, wjbhs); List&amp;lt;MyMap&amp;gt; list= ywglBaseService.queryForListBySql(&amp;#34;ywgl-wjscxx-sqlmap.queryTbYwWjscxx&amp;#34;, param); zipOut=new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFile), BUFFER)); if(list!= null &amp;amp;&amp;amp; list.size()&amp;gt; 0){ for(MyMap wjssxx: list){ if(wjssxx!= null &amp;amp;&amp;amp; wjssxx.get(&amp;#34;wjmc&amp;#34;)!= null){ is= ftp.retrieveFileStream(wjssxx.getString(&amp;#34;wjmc&amp;#34;)); if(null!= is){ zipOut.putNextEntry(new ZipEntry(wjssxx.get(&amp;#34;ywjmc&amp;#34;).toString())); //在向ZIP输出流写入数据之前，必须首先使用out.putNextEntry(entry); 方法安置压缩条目对象 zipOut.setEncoding(&amp;#34;GBK&amp;#34;); while((count=is.read(data, 0, BUFFER))!=-1){ //向ZIP 文件写入数据 zipOut.write(data, 0, count); } zipOut.closeEntry(); is.close(); is= null; if(!ftp.completePendingCommand()){ //调用retrieveFileStream之后必须检查该服务是否完成 ftp.logout(); ftp.disconnect(); ftp= FTPUtil.getFTPClient(); System.out.println(wjssxx.get(&amp;#34;ywjmc&amp;#34;)&#43; &amp;#34;输出流没有关闭成功！&amp;#34;); } } } } } zipOut.flush(); zipOut.close(); zipOut= null; /** * 客户使用保存文件的对话框 * 首先，进行输出的流的配置，其中filename为固定写法，不能随意修改 * 其次，获取输出流的流对象，并使用它进行数据输出 * 最后，使用完成之后，注意流对象的缓存输出与关闭 */ response.reset(); response.setContentType(&amp;#34;application/x-msdownload&amp;#34;); //x-msdownload octet-stream response.setHeader(&amp;#34;Content-Disposition&amp;#34;, &amp;#34;attachment; filename=&amp;#34; &#43; new String(fileName.getBytes(), &amp;#34;ISO-8859-1&amp;#34;)); out = response.getOutputStream(); zipFile=new File(localZip); if(zipFile.exists()){ FileInputStream fis= new FileInputStream(zipFile); while((count=fis.read(data, 0, BUFFER))!=-1){ out.write(data, 0, count); } fis.close(); }else{ System.out.println(localZip&#43; &amp;#34;不存在！&amp;#34;); } }catch (Exception e) { e.printStackTrace(); }finally{ if(null!= zipOut){ zipOut.flush(); zipOut.close(); } if(null!= out){ out.flush(); out.close(); } if(zipFile.exists()){ zipFile.delete(); } } } protected void doGet(HttpServletRequest requse, HttpServletResponse response) throws ServletException, IOException { doPost(requse, response); } } 文件服务支持形式 WEB.XML文件配置 &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;ServerData&amp;lt;/servlet-name&amp;gt; &amp;lt;display-name&amp;gt;ServerData&amp;lt;/display-name&amp;gt; &amp;lt;description&amp;gt;中文名文件下载&amp;lt;/description&amp;gt; &amp;lt;servlet-class&amp;gt;com.syncsoft.framework.utils.ServerData&amp;lt;/servlet-class&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;ServerData&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/ServerData&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt;  界面调用方式 &amp;lt;a href=&amp;#34;/clgl/ServerData?abosulte=false&amp;amp;fileName=需求分析规格.docx&amp;amp;url=/fileDownload/xqfxgg.docx&amp;#34; target=&amp;#39;_self&amp;#39; /&amp;gt; 代码实现 /** * doGet模式进行数据读取 * PARAM： * URL-文件下载地址（路径&#43;文件名&#43;文件格式） * ABOSULUTE-是否绝对路径 * DOWNLOAD_NAME-下载文件名称 */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String isAbosulute= request.getParameter(&amp;#34;abosulte&amp;#34;); String url= request.getParameter(&amp;#34;url&amp;#34;); String fileName= request.getParameter(&amp;#34;fileName&amp;#34;); String sysPath= Thread.currentThread().getContextClassLoader().getResource(&amp;#34;&amp;#34;).getPath(); String systemPath= sysPath.substring(0, sysPath.indexOf(&amp;#34;WEB-INF&amp;#34;)-1); if (url == null || url.equals(&amp;#34;&amp;#34;)) { throw new IllegalArgumentException(url&#43; &amp;#34;: 路径下不存在!&amp;#34;); }else if(fileName == null || fileName.equals(&amp;#34;&amp;#34;)) { fileName= url.substring(url.lastIndexOf(&amp;#34;/&amp;#34;)); }else{ fileName= new String(fileName.getBytes(&amp;#34;ISO-8859-1&amp;#34;), &amp;#34;UTF-8&amp;#34;); } File file = new File((Boolean.valueOf(isAbosulute)? &amp;#34;&amp;#34;: systemPath)&#43; url); if (!file.exists()) { throw new IOException(file&#43; &amp;#34;: 指定下载文件路径不存在!&amp;#34;); } OutputStream os = response.getOutputStream(); FileInputStream fips = new FileInputStream(file); byte[] btImg = readStream(fips); response.setContentType(&amp;#34;application/x-msdownload&amp;#34;); response.addHeader(&amp;#34;Content-disposition&amp;#34;, &amp;#34;attachment;filename=\&amp;#34;&amp;#34; &#43; new String(fileName.getBytes(&amp;#34;UTF-8&amp;#34;), &amp;#34;ISO-8859-1&amp;#34;) &#43; &amp;#34;\&amp;#34;&amp;#34;); os.write(btImg); os.flush(); fips.close(); } 解析超链接中文参数 java.net.URLEncoder.encode(&amp;#34;要解析的参数&amp;#34;, &amp;#34;UTF-8&amp;#34;) Java发送POST/GET请求 /** * 调用GET方法请求 */ @SuppressWarnings(&amp;#34;deprecation&amp;#34;) public static void getProperties4intelliweb2Syncweb(String key, String param){ try { URL url = new URL(FileUtils.getPropertiesContent(properties4intelliweb2Syncweb, key)&#43; param); HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); urlConnection.setRequestMethod(Constants.REQUEST_METHOD_GET); urlConnection.connect(); urlConnection.getInputStream(); urlConnection.disconnect(); } catch (IOException e) { e.printStackTrace(); } } /** * 调用POST方法请求 */ public static void getProperties4intelliweb2SyncwebByPost(String key, String param){ try { URL url = new URL(FileUtils.getPropertiesContent(properties4intelliweb2Syncweb, key)); HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); urlConnection.setRequestMethod(Constants.REQUEST_METHOD_POST); urlConnection.setUseCaches(false); urlConnection.setDoOutput(true); urlConnection.setInstanceFollowRedirects(true); urlConnection.setRequestProperty(&amp;#34; Content-Type &amp;#34;,&amp;#34; application/x-www-form-urlencoded &amp;#34;); DataOutputStream out = new DataOutputStream(urlConnection.getOutputStream());//getOutputStram()隐含调用connect() out.writeBytes(param); out.flush(); out.close(); urlConnection.getInputStream(); urlConnection.disconnect(); } catch (IOException e) { e.printStackTrace(); } } Log4j多日志配置 配置-log4j.properties #Interface log4j.logger.interface= DEBUG, interface --【对应log4j.appender.interface的interface】 log4j.additivity.interface= true --配置开关 log4j.appender.interface=org.apache.log4j.DailyRollingFileAppender log4j.appender.interface.File=logs/clgl4Interface.log --日志存储位置 log4j.appender.interface.layout=org.apache.log4j.PatternLayout log4j.appender.interface.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n 业务代码中 private static Logger log = Logger.getLogger(Constants.LOG4INTERFACE); log.info(&amp;#34;\t\t短信发送结果：&amp;#34;&#43;result); ORACLE指定节点数据 select * from TB_YW_BJXXPZ as of timestamp to_timestamp(&amp;#39;2014-05-04 17:01:43&amp;#39;,&amp;#39;yyyy-mm-dd hh24:mi:ss&amp;#39;) ; JSP界面乱码  于JSP文件最上方补充这两个文件引入  &amp;lt;%@ page language=&amp;quot;java&amp;quot; import=&amp;quot;java.util.*&amp;quot; pageEncoding=&amp;quot;utf-8&amp;quot;%&amp;gt; &amp;lt;%@ page contentType=&amp;quot;text/html;charset=utf-8&amp;quot;%&amp;gt;   界面获取项目名称  代码获取：&amp;lt;%= this.getServletContext().getContextPath() %&amp;gt; EL表达式：${pageContext.request.contextPath}  加密&amp;amp;解密 推荐网址：  各种算法介绍及相关使用方法 RSA密钥保存 RSA公私钥加解密-OpenSSL方式 OpenSSL官网
算法介绍： BASE64
 特点  Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。  用途  邮件 http加密  截取http信息，你就会发现登录操作的用户名、密码字段加密   实现 sun.misc.BASE64Decoder 解密：(new BASE64Decoder()).decodeBuffer(String key); 加密：(new BASE64Encoder()).encodeBuffer(byte[] key);  MD5
 特点：  message-digest algorithm 5 （信息-摘要算法）缩写，且无法进行解密 可由碰撞法破解  用途：  不管文件多大，经过MD5后都能生成唯一的MD5值。  实现：  MessageDigest.getInstance(&amp;ldquo;MD5&amp;rdquo;).update(byte[] data).digest();   SHA
 特点  Secure Hash Algorithm，安全散列算法 可由碰撞法破解  用途  电子商务等信息安全领域  实现  MessageDigest.getInstance(&amp;ldquo;SHA&amp;rdquo;).update(byte[] data).digest();   HMAC
 特点  Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议  原理  用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。 使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。 接收方利用与发送方共享的密钥进行鉴别认证等。  实现  MessageDigest.getInstance(&amp;quot;SHA&amp;quot;).update(byte[] data).digest();   RSA
 特点  RSA同时有两把钥匙，公钥与私钥。同时支持数字签名。 数字签名的意义在于，对传输过来的数据进行校验。确保数据在传输工程中不被修改。  流程  甲方构建密钥对儿，将公钥公布给乙方，将私钥保留。 甲方使用私钥加密数据，然后用私钥对加密后的数据签名，发送给乙方签名以及加密后的数据；乙方使用公钥、签名来验证待解密数据是否有效，如果有效使用公钥对数据解密。 乙方使用公钥加密数据，向甲方发送经过加密后的数据；甲方获得加密数据，通过私钥解密。  注意  公钥和私钥是匹配产生，且格式为A[换行]B[换行]C，其中[换行]在保存为文本时以/r或/n替换使用均无法正常使用，保存方式待定   DES
 特点  Data Encryption Standard,即数据加密算法，典型对称加密方法  实现  DES算法的入口参数有三个:Key、Data、Mode。 其中Key为8个字节共64位,是DES算法的工作密钥;Data也为8个字节64位,是要被加密或被解密的数据;Mode为DES的工作方式,有两种:加密或解密。   实际使用 具体各算法建议参见推荐网址第一个，均有详细介绍。
  图片转换为文字  将指定文档转换后 PDF 下载安装 CAJViewer 7.2.self 打开 CAJViewer 并加载该 PDF，后选取“文字识别功能”圈取要识别文字的区块  加密&amp;amp;解密 视频转Gif  软件  Ulead GIF Animator PotPlayer  过程  使用 PotPlayer 打开影片并拖至要截取视频片段开始处，点击 Ctrl&#43;G 设置好时间间隔和张数后点击开始，完成后点击停止  该环节会保存多张过程图片  运行 Ulead GIF Animator ，新建并调整合适显示大小，后将「1」中保存的图片拖入下侧进度条，并选择插入新建帧 点击「文件-另存为-Gif文件」即可   Java-文件上传 单个 @RequestMapping(value = &amp;#34;/upload&amp;#34;, method = RequestMethod.POST) public BasicResource upload( @RequestBody @NotNull MultipartFile file, @RequestParam(value = &amp;#34;type&amp;#34;, required = false) String type) 多个 @RequestMapping(value = &amp;#34;/writeback&amp;#34;, method = RequestMethod.POST) public void writeBack2( MultipartHttpServletRequest request, @RequestParam(value = &amp;#34;topicId&amp;#34;, required = true) long topicId) { List&amp;lt;MultipartFile&amp;gt; files = request.getFiles(&amp;#34;file&amp;#34;); } 界面操作作转 Gif  软件  灵者 Gif 录制 （GifGod）  过程  点击“选定区域”，鼠标选框后回车  建议取消“跟随鼠标坐标”  “录制” -&amp;gt; “停止”   </content>
    </entry>
    
     <entry>
        <title>Git.命令小结</title>
        <url>http://domain.yqjdcyy.com/post/git.%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Git</tag>
        </tags>
        <content type="html">  查看 分支状态  git status git branch
 分支列表 &amp;ndash;merged：查看哪些分支被合并到当前分支 &amp;ndash;no-merged：查看哪些分支未并合并到当前分支
日志  git log
 &amp;ndash;pretty=oneline：单行显示 &amp;ndash;graph：图形分支
标签  git tag
 &amp;lt;&amp;gt;：查看当前分支标签 -l &amp;lsquo;v1.4*&amp;lsquo;：查看所有匹配该正则的标签信息
文件提交明细  git blame &amp;lt;fileName&amp;gt;：查看文件每行的提交 hash / author/ time
  提交 首次提交  git init： 将当前目录转换为 Git 仓库 git push -u origin &amp;lt;branch&amp;gt; ###新增提交 git add -A git commit -m &amp;ldquo;commit content&amp;rdquo; git push origin &amp;lt;branch&amp;gt;
修改提交 git commit -a -m &amp;ldquo;commit content&amp;rdquo;
 git push origin &amp;lt;branch&amp;gt;
强制提交 git push -f origin &amp;lt;branch&amp;gt;
标签 单个
 git push origin &amp;lt;tagname&amp;gt;  所有
 git push &amp;ndash;tags   创建 分支  checkout  git checkout -b &amp;lt;branch&amp;gt; &amp;lt;origin/ dev&amp;gt;： 创建分支 [关联远程分支 dev ]  branch
 git branch &amp;lt;branch&amp;gt;：创建分支 git checkout &amp;lt;branch&amp;gt;： 切换分支
标签  git tag
 &amp;lt;tagname&amp;gt;：当前版本上创建标签（轻量标签） &amp;lt;tagname&amp;gt; &amp;lt;commit id&amp;gt;：针对 &amp;lt;commit id&amp;gt; 历史提交打上标签 -a &amp;lt;tagname&amp;gt; -m &amp;ldquo;&amp;lt;more info&amp;gt;&amp;ldquo;：创建附注标签   切换 分支  git checkout &amp;lt;branch&amp;gt;
标签 git checkout &amp;lt;tagname&amp;gt;
  关联 关联远程分支  set  git branch &amp;ndash;set-upstream-to=origin/dev git branch -u origin/dev  将当前分支的 upstream 更新为 origin/dev 分支   push &amp;amp; set  git push -u origin master  将 master 分支推送至 origin/master 分支 更新本地 master 分支的 upstream 为 origin/master   set other
 git push -u origin/dev dev
 将本地 dev 分钟的 upstream 更新为 origin/dev
取消关联   unset
 git branch &amp;ndash;unset-upstream  unset other
 git branch &amp;ndash;unset-upstream dev   更新 仓库  git clone ssh-url
所有 git pull
指定分支 git pull origin branch
  合并 分支  git merge  git merge &amp;lt;dev&amp;gt;： 将 dev 分支快速合并到当前分支 git merge [ ff | no-ff ] dev：默认使用 ff ，即 fast-forward ， 当删除分支 dev 后，则无法再次查看 dev 分支的日志等  git rebase  当前分支 dev ： 将 dev 分支历次提交转成补丁，并以 master 分支最后一个提交为出发点逐个应用补丁。即使 dev 提交历史成为 master 分支的直接下流。 flow  git rebase master client  将 client 补丁至 master git checkout master git merge client   args  git rebase &amp;ndash;onto master server client  master-&amp;gt;server-&amp;gt; client 跳过 server 直接将 client 补丁至 master  git rebase &amp;ndash;continue：冲突处理后调用，继续完成 git rebase &amp;ndash;abort：放弃 git rebase -i HEAD~2：合并最后两次提交 git rebase &amp;ndash;skip：直接使用分支取代当前分支    提交  git cherry-pick  &amp;lt;commit id&amp;gt;：将其它分支指定提交合并至当前分支，适用于通用分支 bug 的修复 注：会引起冲突！  git merge &amp;lt;commit id&amp;gt;  回滚 按版本  git reset &amp;ndash;hard
 commitId HEAD：当前分支最新版本 HEAD^：上一版本 HEAD^^：上上版本 HEAD~10：上第十个版本
按文件  git checkout
 &amp;ndash; files： 如 git checkout &amp;ndash; /src/*
按提交  git revert &amp;lt;commit id&amp;gt;：撤消指定提交
 -m parent-number: 指定回滚时的指定主分支  -m 1：默认当前分支 -m 2: 清除但保留主分支内容    删除 文件  git rm files git commit -m &amp;ldquo;commit content&amp;rdquo;
分支 git branch
 -d branch： 删除分支 -D branch：强制删除分支，放弃修改   暂存  git stash  将当前代码暂存起来，便于切换到其它分支 list：显示当前分支下所有列表 drop：删除暂存内容 pop：恢复，并删除暂存内容   维护 性能  git gc： 压缩历史命令
可靠性 git fsck：系统文件检查
 &amp;ndash;lost-found：显示丢弃提交  git show &amp;lt;commit id&amp;gt;：显示该提交的改变内容
 git merge&amp;lt;commit id&amp;gt;：恢复到之前提交
 注：有可能会有冲突   报错 push时遇到unpack failed: error Missing tree错误  本地索引损坏，需重新构建  git gc git pull &amp;ndash;rebase   </content>
    </entry>
    
     <entry>
        <title>HTTP.协议相关</title>
        <url>http://domain.yqjdcyy.com/post/http.%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>HTTP</tag>
        </tags>
        <content type="html">  参考  Http 协议详解 HTTP headers Hypertext Transfer Protocol &amp;ndash; HTTP/1.1 四种常见的 POST 提交数据方式 Http.vary  Http.detail  Message Body 消息体 Request 请求头  POST http://dev-p.yunkai.com/api/resource/upload HTTP/1.1  Header 头文件  Accept: application/json, text/plain, */* Content-Type: multipart/form-data; boundary=---------------------------7e016f3be0a4a Referer: http://dev-p.yunkai.com/admin/index.html#/meetings/98/update/agendas Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko Content-Length: 4708261 Host: dev-p.yunkai.com Connection: Keep-Alive Pragma: no-cache Cookie: SESSION=82526c96-4740-4d52-b3c1-757384ba3017  Empty line Body 消息体  -----------------------------7e016f3be0a4a Content-Disposition: form-data; name=&amp;quot;file&amp;quot;; filename=&amp;quot;B2283659A4B9302BE09FE2EC97690382.pptx&amp;quot; Content-Type: application/vnd.openxmlformats-officedocument.presentationml.presentation  Method GET Data.length.limit Browser IE: 2083B= 2KB&#43; 35B
 Firefox: 65,536 Char -&amp;gt; 1 Char= 2B Safari: 80,000 Char Opera: 190,000 Char Chrome: 8,182 Char Server Apache: 8,192 Char IIS: 16,384 Char POST Data.length.limit Http not set the limit Apache.Tomcat.default.maxPostSize= 2M HEAD TRACE PUT DELETE OPTION CONNECT  Status Code Http Status code  参考 http://www.cnblogs.com/DeasonGuan/articles/Hanami.html http://www.cnblogs.com/shanyou/archive/2012/05/06/2486134.html
 1XX - Informational
 define: provisional response, consisting only of the status-line and optional headers, and is terminated by an empty line. expect for proxy
 list
 100 - Continue: continue the request
 101 - Switching Protocols: terminate the 101 response after the empty line then change the application protocol
 2XX - Successful
 define: client&amp;rsquo;s request was successfully received, understood and accepted
 list
 200 - OK: the request has succeeded
 201 - Created: new resource created immediately
 202 - Accepted: has been accepted but not completed
 203 - Non-Authoritative Information: may fathered from a local or a third-party copy
 204 - No Content: not need to return an entity-body, just like update method, and MUST NOT include an entity
 205 - Reset Content: reset the form and MUST NOT include an entity
 206 - Partial content:for download big data and MUST have a range header, and MUST NOT include other entity
 3XX - Redirection
 define: further action needs to be taken by the user agent, detect infinite redirection loops
 list
 300 - Multiple Choices: select a preferred representation from a set of them
 301 - Moved Permanently: other than GET/ HEAD, NUST NOT automatically redirect to an new permanent URI
 302 - Found: redirect to a different URI on occasion, and only cacheable by Cache-control or Expires header
 303 - See Other: SHOULD retrieved different URI using a GET method, user HEAD to get the new URI from the short hypertext note with a hyperlink
 304 - Not Modified: the document has not been modified, the server MUST NOT contain a message-body, thus always terminated by the first empty line after the header fields
 305 - Use Proxy: generated by origin servers, and MUST accessed through the proxy, or notice the client to repeat request via the proxy
 306 : Unused
 307 - Temporary Redirect: resource resieds temporarily on occasion, and the client SHOULD continue use the Request-URI for future requests
 4XX - Client Error
 define: for cases in which the client seems to have erroed
 list
 400 - Bad Request: the request could not be understood
 401 - Unauthorized: the request requires user authentication, MUST inclued a WWW-Authenticate header field
 402 - Payment Required: reserved for future use
 403 - Forbidden: the server understood the request, but is refusing to fulfill it
 404 - Not Found: the server has not found anything matching the Request-URI
 405 - Method Not Allowed: specified in the request-line is not allowed
 406 - Not Acceptable: the content characteristics of the request is not acceptable. while HEAD request, the response SHOULD include an entity containing a list of available entity characteristics and location
 407 - Proxy Authentication Required: similar to 401, but indicates that the client must first authenticate itself with the poxy
 408 - Request Timeout: no produce a request with the time
 409 - Conflict: conflict with the current state of resource. the body include the conflict info and expect the client
 410 - Gone: the requested resource is no longer available
 411 - Length Required: the Content-length header of the request is not enought
 412 - Precondition Failed: one or more of the request-header fields evaluated to false
 413 - Request Entity Too Large: the server resusing to process the request because the request entity is larger than the server is willing or able to process
 414 - Request-URI Too Long
 415 - Unsupported Media Type:
 416 - Requested Range Not Satisfiable: the request included a Range request-header and the byte-ranges is out of array
 417 - Expectation Failed: expect request-header field could not be met
 5XX - Server Error
 list
 500 - Internal Server Error: the server encountered an unexpected condition
 501 - Not Implemented: the server does not support
 502 - Bad Gateway: the server, while acting as a gateway or proxy, received an invalid response from the upstream server
 503 - Service Unavailable: unable to handle the request due to a temporary overloading or maintenance of the server, temporary status
 504 - Gateway Timeout: acting as a gateway or proxy, could not receive the timely response from the upstream server
 505 - HTTP Version Not Supported: the HTTP protocol version was used is not supported in the server
  Header.request  Cache If-Modified-Since 与 Last-Modified 配合使用，进行缓存读取或新文件获取 If-None-Match 与 ETags 配合使用，进行缓存读取或新文件获取 Cache-Control Public: cache by client and proxy Private: default, only cache by client no-cache: no cache Pragma: no-cache，同 Cache-Control: no-cache
 Client
 Accept
 lists the MIME types expected by the user agent
 example
 Accept: audio/*; q=0.2, audio/basic
 I prefer audio/basic, but send me any audio type if it is the best available after an 80% mark-down in quality
 Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c
 text/html and text/x-c are the preferred media types, but if they do not exist, then send the text/x-dvi entity, and if that does not exist, send the text/plain entity
 Accept-Encoding
 lists the compression methods supported by the user agent
 example - Accept-Encoding: compress, gzip - Accept-Encoding: - Accept-Encoding: * - Accept-Encoding: compress;q=0.5, gzip;q=1.0 - Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
 Accept-Language
 lists the languages the user agent expect the page in
 example
 Accept-Language: da, en-gb;q=0.8, en;q=0.7
 I prefer Danish, but will accept British English and other types of English
 User-Agent
 list the name and version of client system and browser
 example
 User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)
 Accept-Charset
 lists the character sets supported by the user agent
 example
 Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
 if server cannot response, it will response 406 error
 Cookies/ Login
 Cookie
 Entity
 Content-Length
 Content-Type
 Choice
 application/x-www-form-urlencoded
 默认方式
 提交数据以 key1=val1&amp;amp;key2=val2 形式编码，且 key/ val 均进行了 URL 转码
 multipart/form-data
 主要用于文件上传
 application/json
 指定消息主体为 Json 字符串
 text/xml
 HTTP 作为传输协议， XML 作为编码方式的远程调用规范
 example
 Content-Type: application/x-www-form-urlencoded
 Miscellaneous
 Referer
 special the resource from
 example
 Referer:http://translate.google.cn/?hl=zh-cn&amp;amp;tab=wT
 Transport
 Connection
 keep-alive
 http 1.0 默认关闭， http 1.1中默认启用Keep-Alive
 判断消息长度
 Conent-Length
 Transfer-Encoding: chunked
 由 length=0 的 chunk 标示结束
 chunk= header&#43; content [&#43; CRLF-回车换行分享]
 header: 0xContent.length [unit]
 content
 close
 Host
 specifies the Internet host and port number of the resource being requested
 example
 http://www.guet.edu.cn/index.html -&amp;gt; host= www.guet.edu.cn
 http://192.168.70.198:8080/api/resource/upload -&amp;gt; host= 192.168.70.198:8080
  Header.response  Cache Date represents the date and time at which the message was originated example Date: Tue, 15 Nov 1994 08:12:31 GMT Expires use cache before expire RFC 1123 date format example Expires: Thu, 01 Dec 1994 16:00:00 GMT Vary the Vary field value advises the user agent about the criteria that were used to select the representation example Vary: User-Agent, Cookie Vary 字段用于列出一个响应字段列表，告诉缓存服务器遇到同一个 URL 对应着不同版本文档的情况时，如何缓存和筛选合适的版本。
 Cookie/ Login
 P3P
 用于跨域设置Cookie, 可解决iframe跨域访问cookie的问题
 example
 P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR
 Set-Cookie
 更新客户端浏览器 Cookie 信息
 example
 Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com
 Entity
 Etag
 Last-Modified
 参考 If-Modified-Since
 Content-Type
 Content-Length
 Content-Encoding
 Content-Language
 Miscellaneous
 Server
 指明 Http 服务器软件信息
 example
 Server: Microsoft-IIS/7.5
 X-AspNet-Version
 指明 ASP.NET 版本
 example
 X-AspNet-Version: 4.0.30319
 X-Powered-By
 指明开发技术
 example
 X-Powered-By: ASP.NET
 Transport
 Connection
 Location
 Location
 重定向，包含 URL 地址
  Other 缓存  分类 强缓存 判断命中，则直接从浏览器缓存中读取资源，不发请求至服务器（200） 协商缓存 发请求至服务器，协商缓存命中，则返回请求（304），告知浏览器从缓存中加载 实现 强缓存 请求资源时，资源及其 response header 一并被缓存 再次请求时，优先比对该资源 header 中的 Expries（失效时间） 或 Cache-Control：max-age=315360000 &amp;amp; Date: Mon, 11 Jan 2016 06:41:22 GMT 对比判断是否命中 注：Cache-Control 为相对时间，都使用客户端时间进行判断，相比 Expries 的服务器时间对比更安全。 协商缓存 请求资源时，资源及其 response header 一并被缓存 再次和服务器请求该请求时，一并传上 header.Last-Modified: Tue 12 Jan 2016 03:08:53 GMT - 服务器上该资源的最后修改时间 header.If-Modified-Since: Tue 12 Jan 2016 03:08:53 GMT - 上一次浏览器请求时返回的 Last-Modified 值 或 ETag: &amp;ldquo;17fd8-5291a5f96fd20&amp;rdquo; - 请求资源的唯一标识 If-None-Match: &amp;ldquo;17fd8-5291a5f96fd20&amp;rdquo; - 上一次请求时的 ETag 值  </content>
    </entry>
    
     <entry>
        <title>Hello.Spring.JPA</title>
        <url>http://domain.yqjdcyy.com/post/springboot.jpa/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Spring</tag><tag>JPA</tag>
        </tags>
        <content type="html">  示例 Basic Example Entity @Entity @Table(name = &amp;#34;user&amp;#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @Column(name = &amp;#34;user_name&amp;#34;) private long userName; } Repository public interface UserRepository extends CrudRepository&amp;lt;User, Long&amp;gt; { // 必须指定操作对象及ID类型 Long countByLastname(String lastname); List&amp;lt;User&amp;gt; findByLastname(String lastname); } Common-Repository PagingAndSortingRepository CrudRepository Repository Config @Configuration @EnableJpaRepositories(basePackages = &amp;#34;com.yunkai&amp;#34;) // 指定 Repository 位置 @ComponentScan(basePackages = &amp;#34;com.yunkai&amp;#34;) @EntityScan(basePackages = &amp;#34;com.yunkai&amp;#34;) // 指定 Entity 对象位置 class ApplicationConfiguration { @Bean public EntityManagerFactory entityManagerFactory() { // … } } Using @Autowired private UserRepository repository; Page&amp;lt;User&amp;gt; users = repository.findAll(new PageRequest(1, 20)); Cunstom-tuning @NoRepositoryBean // 自定义基础库时使用，保证能被运行时创建 interface MyBaseRepository&amp;lt;T, ID extends Serializable&amp;gt; extends Repository&amp;lt;T, ID&amp;gt; { T save(T entity); } Defining query methods Query lookup strategies CREATE USE_DECLARED_QUERY CREATE_IF_NOT_FOUND = CREATE&#43; USE_DECLARED_QUERY Query creation prefixes find…by read…by query…by count…by get…by expressions distinct and or operators between lessThan GreaterThan like orderBy…asc|desc parameter handling Page Slice List Pageable Sort limiting first top Streaming Java 8 Stream&amp;lt;T&amp;gt; try (Stream&amp;lt;User&amp;gt; stream = repository.findAllByCustomQueryAndStream()) { stream.forEach(…); } Example // 获取唯一值 List&amp;lt;Person&amp;gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname); // 忽略大小写，单独忽略时跟在查询元素后 List&amp;lt;Person&amp;gt; findByLastnameIgnoreCase(String lastname); List&amp;lt;Person&amp;gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname); // 排序 List&amp;lt;Person&amp;gt; findByLastnameOrderByFirstnameAsc(String lastname); // 查询 x.address.zipCode ，其中算法会遍历 AddressZipCode/ AddressZip&#43; Code/ Address&#43; ZipCode List&amp;lt;Person&amp;gt; findByAddressZipCode(ZipCode zipCode); // 同上，明确分词 List&amp;lt;Person&amp;gt; findByAddress_ZipCode(ZipCode zipCode); // 分页列表查询 Page&amp;lt;User&amp;gt;|Slice&amp;lt;User&amp;gt;|List&amp;lt;User&amp;gt; findByLastname(String lastname, Pageable pageable|Sort sort); // 指定前X条记录 User find[First|Top]ByOrderByLastnameAsc(); Page&amp;lt;User&amp;gt; query[First10|Top3]ByLastname(String lastname, Pageable pageable); // @Query(&amp;#34;select u from User u&amp;#34;) Stream&amp;lt;User&amp;gt; findAllByCustomQueryAndStream(); Stream&amp;lt;User&amp;gt; readAllByFirstnameNotNull(); Data extensions Web support java config @Configuration @EnableWebMvc @EnableSpringDataWebSupport class WebConfiguration { } Xml config &amp;lt;bean class=&amp;#34;org.springframework.data.web.config.SpringDataWebConfiguration&amp;#34; /&amp;gt; &amp;lt;!-- If you&amp;#39;re using Spring HATEOAS as well register this one *instead* of the former --&amp;gt; &amp;lt;bean class=&amp;#34;org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration&amp;#34; /&amp;gt; config support DomainClassConverter Define convert reuqest parameters or path variables to domain class Example @RequestMapping(&amp;#34;/{id}&amp;#34;) public String showUserForm(@PathVariable(&amp;#34;id&amp;#34;) User user, Model model) {} // id-&amp;gt; user，domain call findOne automatic HandlerMethodArgumentResolver Define resovle Pageable/ Sort instances from request parameters Example @RequestMapping public String showUsers(Model model, Pageable pageable) {} public String showUsers(Model model, @Qualifier(&amp;#34;foo&amp;#34;) Pageable first, @Qualifier(&amp;#34;bar&amp;#34;) Pageable second) { … } Url request page=1&amp;amp;size=10&amp;amp;sort=firstname&amp;amp;sort=lastname,asc Attention @PageableDefaults on controller.method Auto create next and prev link method @RequestMapping(value = &amp;#34;/persons&amp;#34;, method = RequestMethod.GET) HttpEntity&amp;lt;PagedResources&amp;lt;Person&amp;gt;&amp;gt; persons(Pageable pageable, PagedResourcesAssembler assembler) { Page&amp;lt;Person&amp;gt; persons = repository.findAll(pageable); return new ResponseEntity&amp;lt;&amp;gt;(assembler.toResources(persons), HttpStatus.OK); } response { &amp;#34;links&amp;#34; : [ { &amp;#34;rel&amp;#34; : &amp;#34;next&amp;#34;, &amp;#34;href&amp;#34; : &amp;#34;http://localhost:8080/persons?page=1&amp;amp;size=20 }], &amp;#34;content&amp;#34; : [… // 20 Person instances rendered here], &amp;#34;pageMetadata&amp;#34; : { &amp;#34;size&amp;#34; : 20, &amp;#34;totalElements&amp;#34; : 30, &amp;#34;totalPages&amp;#34; : 2, &amp;#34;number&amp;#34; : 0 } } Repository populators Json file [ { &amp;#34;_class&amp;#34; : &amp;#34;com.acme.Person&amp;#34;, &amp;#34;firstname&amp;#34; : &amp;#34;Dave&amp;#34;, &amp;#34;lastname&amp;#34; : &amp;#34;Matthews&amp;#34; }, { &amp;#34;_class&amp;#34; : &amp;#34;com.acme.Person&amp;#34;, &amp;#34;firstname&amp;#34; : &amp;#34;Carter&amp;#34;, &amp;#34;lastname&amp;#34; : &amp;#34;Beauford&amp;#34; } ] XML config &amp;lt;repository:jackson-populator locations=&amp;#34;classpath:data.json&amp;#34; /&amp;gt; &amp;lt;oxm:jaxb2-marshaller contextPath=&amp;#34;com.acme&amp;#34; /&amp;gt; Query methods Query creation **Keyword** **Sample** **JPQL snippet** And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstnameIs … where x.firstname = 1? Between findByStartDateBetween … where x.startDate between 1? and ?2 LessThan findByAgeLessThan … where x.age &amp;lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age ⇐ ?1 GreaterThan findByAgeGreaterThan … where x.age &amp;gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &amp;gt;= ?1 After findByStartDateAfter … where x.startDate &amp;gt; ?1 Before findByStartDateBefore … where x.startDate &amp;lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &amp;lt;&amp;gt; ?1 In findByAgeIn(Collection&amp;lt;Age&amp;gt; ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection&amp;lt;Age&amp;gt; age) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) Name Query XML /META-INF/orm.xml &amp;lt;named-query name=&amp;#34;User.findByLastname&amp;#34;&amp;gt; &amp;lt;query&amp;gt;select u from User u where u.lastname = ?1&amp;lt;/query&amp;gt; &amp;lt;/named-query&amp;gt; Annotation @Entity @NamedQuery(name = &amp;#34;User.findByEmailAddress&amp;#34;, query = &amp;#34;select u from User u where u.emailAddress = ?1&amp;#34;) public class User {} Repository public interface UserRepository extends JpaRepository&amp;lt;User, Long&amp;gt; { User findByEmailAddress(String emailAddress); } Query take precedence over name query Annotation JPQL query @Query(&amp;#34;select u from User u where u.firstname like %?1&amp;#34;) List&amp;lt;User&amp;gt; findByFirstnameEndsWith(String firstname); Native Query @Query(value = &amp;#34;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?0&amp;#34;, nativeQuery = true) User findByEmailAddress(String emailAddress); @Query(&amp;#34;select u from #{#entityName} u where u.lastname = ?1&amp;#34;) List&amp;lt;User&amp;gt; findByLastname(String lastname); Native Query with named parameters @Query(&amp;#34;select u from User u where u.firstname = :firstname or u.lastname = :lastname&amp;#34;) User findByLastnameOrFirstname(@Param(&amp;#34;lastname&amp;#34;) String lastname, @Param(&amp;#34;firstname&amp;#34;) String firstname); Modifying Query Annotation @Modifying @Query(&amp;#34;update User u set u.firstname = ?1 where u.lastname = ?2&amp;#34;) int setFixedFirstnameFor(String firstname, String lastname); 注： @Modifying(clearAutomatically = true) 可促使 EntityManager 立即抛弃缓存的数据并重新读取 Query Hints user for cache data Annotation @QueryHints({ @QueryHint(name = &amp;#34;org.hibernate.cacheable&amp;#34;, value =&amp;#34;true&amp;#34;) }) public User findById(long id); Load Graphs Annotation @Entity @NamedEntityGraph(name = &amp;#34;GroupInfo.detail&amp;#34;, attributeNodes = @NamedAttributeNode(&amp;#34;members&amp;#34;)) public class GroupInfo {} @Repository public interface GroupRepository extends CrudRepository&amp;lt;GroupInfo, String&amp;gt; { @EntityGraph(value = &amp;#34;GroupInfo.detail&amp;#34;, type = EntityGraphType.LOAD) GroupInfo getByGroupName(String name); } Stored Procedures HSQL DB Definition /; DROP procedure IF EXISTS plus1inout /; CREATE procedure plus1inout (IN arg int, OUT res int) BEGIN ATOMIC set res = arg ` 1; END /; Entity Definition @Entity @NamedStoredProcedureQuery(name = &amp;#34;User.plus1&amp;#34;, procedureName = &amp;#34;plus1inout&amp;#34;, parameters = { @StoredProcedureParameter(mode = ParameterMode.IN, name = &amp;#34;arg&amp;#34;, type = Integer.class), @StoredProcedureParameter(mode = ParameterMode.OUT, name = &amp;#34;res&amp;#34;, type = Integer.class) }) public class User {} Mapped In Database @Procedure(&amp;#34;plus1inout&amp;#34;) Integer explicitlyNamedPlus1inout(Integer arg); Specifications Interface public interface Specification&amp;lt;T&amp;gt; { Predicate toPredicate(Root&amp;lt;T&amp;gt; root, CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder builder); } Definition public class CustomerSpecs { public static Specification&amp;lt;Customer&amp;gt; isLongTermCustomer() { return new Specification&amp;lt;Customer&amp;gt;() { public Predicate toPredicate(Root&amp;lt;Customer&amp;gt; root, CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder builder) { LocalDate date = new LocalDate().minusYears(2); return builder.lessThan(root.get(_Customer.createdAt), date); } }; } public static Specification&amp;lt;Customer&amp;gt; hasSalesOfMoreThan(MontaryAmount value) { return new Specification&amp;lt;Customer&amp;gt;() { public Predicate toPredicate(Root&amp;lt;T&amp;gt; root, CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder builder) {} }; } } Using List&amp;lt;Customer&amp;gt; customers = customerRepository.findAll(where(isLongTermCustomer()).or(hasSalesOfMoreThan(amount))); Transaction Retrieve Benefit rollback after setted timeout improve the Example @Transactional(timeout = 10, readOnly= true) public List&amp;lt;User&amp;gt; findAll(); Create/Update/Delete Benefit ensure the data is correct Example @Transactional public void addRoleToAllUsers(String roleName) @Modifying @Transactional @Query(&amp;#34;delete from User u where u.active = false&amp;#34;) void deleteInactiveUsers(); Locking @Lock(LockModeType.READ) List&amp;lt;User&amp;gt; findByLastname(String lastname); Auditing Base Metadata Annotation @CreateBy | @LastModifiedBy | @CreateDate | @LastModifiedDate -&amp;gt; 实体调整时自动赋值 参考 Spring Data JPA - Reference Documentation
</content>
    </entry>
    
     <entry>
        <title>Hello.SpringBoot</title>
        <url>http://domain.yqjdcyy.com/post/springboot.%E5%85%A5%E9%97%A8/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Spring</tag>
        </tags>
        <content type="html">  作用 创建和启动新的 Spring 框架项目 特性 嵌入 Tomcat 或 Jetty 提供生产环境使用功能，如性能指标、应用信息和应用健康检查 POM 配置 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.midgetontoes&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-simple&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;spring.boot.version&amp;gt;1.1.4.RELEASE&amp;lt;/spring.boot.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; &amp;lt;/project&amp;gt; 启动程序 @RestController @EnableAutoConfiguration public class Application { @RequestMapping(&amp;#34;/&amp;#34;) String home() { return &amp;#34;Hello World!&amp;#34;; } public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 推荐基础 POM 文件  spring-boot-starter 核心 POM，包含自动配置支持、日志库和对 YAML 配置文件的支持。 spring-boot-starter-amqp 通过 spring-rabbit 支持 AMQP。 spring-boot-starter-aop 包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。 spring-boot-starter-batch 支持 Spring Batch，包含 HSQLDB。 spring-boot-starter-data-jpa 包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。 spring-boot-starter-data-mongodb 包含 spring-data-mongodb 来支持 MongoDB。 spring-boot-starter-data-rest 通过 spring-data-rest-webmvc 支持以 REST 方式暴露 Spring Data 仓库。 spring-boot-starter-jdbc 支持使用 JDBC 访问数据库。 spring-boot-starter-security 包含 spring-security。 spring-boot-starter-test 包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。 spring-boot-starter-velocity 支持使用 Velocity 作为模板引擎。 spring-boot-starter-web 支持 Web 应用开发，包含 Tomcat 和 spring-mvc。 spring-boot-starter-websocket 支持使用 Tomcat 开发 WebSocket 应用。 spring-boot-starter-ws 支持 Spring Web Services。 spring-boot-starter-actuator 添加适用于生产环境的功能，如性能指标和监测等功能。 spring-boot-starter-remote-shell 添加远程 SSH 支持。 spring-boot-starter-jetty 使用 Jetty 而不是默认的 Tomcat 作为应用服务器。 spring-boot-starter-log4j 添加 Log4j 的支持。 spring-boot-starter-logging 使用 Spring Boot 默认的日志框架 Logback。 spring-boot-starter-tomcat 使用 Spring Boot 默认的 Tomcat 作为应用服务器
外部配置（高到低） 命令行参数。
 通过 System.getProperties() 获取的 Java 系统参数。
 操作系统环境变量。
 从 java:comp/env 得到的 JNDI 属性。
 通过 RandomValuePropertySource 生成的“random.*”属性
 user.count=${random.int} user.max=${random.long}  user.number=${random.int(100)}   应用 Jar 文件之外的属性文件。
 应用 Jar 文件内部的属性文件。
 在应用配置 Java 类（包含“@Configuration”注解的 Java 类）中通过“@PropertySource”注解声明的属性文件。
 通过“SpringApplication.setDefaultProperties”声明的默认属性。
属性文件 搜索位置， 由高到低 当前目录的“/config”子目录。
 当前目录。
 classpath 中的“/config”包。
 classpath
配置属性 spring.config.name：配置属性指定不同的属性文件名称
 spring.config.location：添加额外属性文件搜索路径
 配置多个 profile ：文件名格式为 application-{profile}
运维支持 条件 POM 文件中添加 org.springframe.boot:spring-boot-starter-actuator 依赖
HTTP 服务： autoconfig 显示 Spring Boot 自动配置的信息。 是
 beans 显示应用中包含的 Spring bean 的信息。 是
 configprops 显示应用中的配置参数的实际值。 是
 dump 生成一个 thread dump。 是
 env 显示从 ConfigurableEnvironment 得到的环境配置信息。 是
 health 显示应用的健康状态信息。 否
 info 显示应用的基本信息。 否
 metrics 显示应用的性能指标。 是
 mappings 显示 Spring MVC 应用中通过“
 @RequestMapping”添加的路径映射。 是
 shutdown 关闭应用。 是
 trace 显示应用相关的跟踪（trace）信息。 是
例子： Health 服务 作用： 对应用本身、关系数据库连接、MongoDB、Redis 和 Rabbit MQ 的健康状态的检测
前置条件： 实现 org.springframework.boot.actuate.health.HealthIndicator 接口 返回一个 org.springframework.boot.actuate.health.Health 对象
实现类： @Component public class AppHealthIndicator implements HealthIndicator { @Override public Health health() { return Health.up().build(); } } 返回结果： {&amp;ldquo;status&amp;rdquo;:&amp;ldquo;UP&amp;rdquo;,&amp;ldquo;app&amp;rdquo;:{&amp;ldquo;status&amp;rdquo;:&amp;ldquo;UP&amp;rdquo;},&amp;ldquo;db&amp;rdquo;:{&amp;ldquo;status&amp;rdquo;:&amp;ldquo;UP&amp;rdquo;,&amp;ldquo;database&amp;rdquo;:&amp;ldquo;HSQL Database Engine&amp;rdquo;,&amp;ldquo;hello&amp;rdquo;:1}}
JMX 管理  Spring Boot 默认提供 JMX 管理的支持 注解支持：@ManagedResource、@ManagedAttribute 和 @ManagedOperation MBean 域：org.springframework.boot   </content>
    </entry>
    
     <entry>
        <title>Hello.Storm</title>
        <url>http://domain.yqjdcyy.com/post/storm/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>框架</tag><tag>Storm</tag>
        </tags>
        <content type="html">  通信机制 选型  进程间使用 Netty/ ZeroMQ 进行通信 同一进程内的诸多线程，采用 Disruptor Queue 完成通信 注： LocalCluster 模式下，参数 storm.local.mode.zmq= false 则采用线程模拟进程方式启动，通过 LinkedBlockingQueue 模拟
进程间通信协议 Connection
 recv-with-flags[conn flags] - flags 表示是否为阻塞方式 send[conn task message] close[conn]  Context
 bind[context storm-id port] - 绑定端口号并返回 Socket 对象，主要用于接收信息 connect[context storm-id host port] - 链接到指定商品号，负责发消息 teim[context] - 关闭连接  LocalCluster 模式实现
 采用一个进程模拟集群环境，Nimbus/ Supervisor/ Worker 均为该进程中的线程 Connection  用 LinkedBlockingQueue 和 queue 等队列模拟消息的发送接收  Context
 用 quenes-map 和 LinkedBlockingQueue 模拟绑定和消失发送
分布式模式   实现转使用对应 ZeroMQ 或 Netty 进行绑定和相关消息发送
协议使用 launch-receive-thread
 启动 Worker 对应的消息接收线程  async-loop：启动一个接收线程
 msg= taskId(recource)&#43; msgBody 阻塞获取第一条后，切换至非阻塞方式接收 max-buffer-size 条，具体数值由 topology.receiver.buffer.size 配置确定，默认为 8  kill-socket：
 task == -1 时调用  进程内通信
 封装使用 Disruptor Queue 实现   多语言 使用 Thrift 的多语言支持来拓展 ShellProcess  加载其它语言定义进程，并通过 STDIN STDOUT 进行通信
public Number launch(Map conf, TopologyContext context) JSONObject setupInfo= new JSONObject(); // setupInfo= workerDir/pidDir&#43; topology.setting&#43; context public JSONObject readMessage() private String readString() case: end 消息结束 case: Null 子进程不存在 ShellBolt 定义读写线程，分别向子进程进行消息的发送和接收
 使用 ShellProcess.launch 加载子进程
ShellSpout querySubprocess - 核心
 case sync: return case emit: 获取消息，并根据目标 ID 有无跟踪发送   </content>
    </entry>
    
     <entry>
        <title>Markdown</title>
        <url>http://domain.yqjdcyy.com/post/markdown/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Markdown</tag>
        </tags>
        <content type="html">  目录 [TOC]
标题 二级标题 ####### 最大支持六级标题
注：序号和*号，与内容之间均需要一个空格
 列表1 列表2 列表3   无序列表 无序列表  无序列表缩进  无序列表  字体支持很多样式，比如加粗、*斜体*、删除线等特别样式
当然也可以引用名人名言 &amp;gt;Markdown 很好用的 —— 阿尔伯特·爱因斯坦
百度
代码格式表示
for(var i= 0; i&amp;lt; count; i&#43;&#43;) 表格 |为知| md| |-|-| |WizNote|Markdown|
公式啊！！！ $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$
st=&amp;gt;start: Start:&amp;gt;http://www.google.com[blank] e=&amp;gt;end:&amp;gt;http://www.google.com op1=&amp;gt;operation: My Operation sub1=&amp;gt;subroutine: My Subroutine cond=&amp;gt;condition: Yes or No?:&amp;gt;http://www.google.com io=&amp;gt;inputoutput: catch something... st-&amp;gt;op1-&amp;gt;cond cond(yes)-&amp;gt;io-&amp;gt;e cond(no)-&amp;gt;sub1(right)-&amp;gt;op1 Title: [教程可以看](http://bramp.github.io/js-sequence-diagrams/) A-&amp;gt;B: 【备注演示】 Note left of A: 此轮回应前\nA 左侧备注 Note over A: 此轮 A 线上的备注 Note right of A: 此轮回应前A 右侧备注 Note over A,B:此轮回应前横跨 AB 两线的备注 A-&amp;gt;B: 【线型演示】 A-&amp;gt;B: 实线三角标 B--&amp;gt;A: 虚线三角标 A-&amp;gt;&amp;gt;B: 实线角标 B--&amp;gt;&amp;gt;A: 虚线角标 </content>
    </entry>
    
     <entry>
        <title>Mysql.开发规范</title>
        <url>http://domain.yqjdcyy.com/post/mysql.%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Mysql</tag>
        </tags>
        <content type="html">  [数据库开发规范简版] 数据库创建 命名规范  Pascal样式(每个单词首字母大写)命名 命名格式为[项目英文名称]
例 CREATE DATABASE test CHARACTER SET &amp;lsquo;utf8&amp;rsquo; COLLATE &amp;lsquo;utf8_general_ci&amp;rsquo;;
  表创建 命名规范 表  以组件或子系统名称为前缀 添加表和字段注释，明确各值可选值含义
列 列名称命名采用英文单词或缩写，关联具体业务
 尽量不允许为 Null，用默认值代替
例 FetionUser.FU_TableName.ColName
  类型选择 整型  tinyint 2^8 -128到127或0到255 smallint 2^16 -32768到32767或0到65535 int 2^32 -2147483648到2147483647或0到4294967295 bigint 2^64 -9223372036854775808到9223372036854775807或0到18446744073709551615 例 tinyint(3) 明确指定宽度 确认无符号时，需要添加 unsigned 限制  文本  CHAR(1) VARCHAR(2- 20000) TEXT 单表维护！  时间  timestamp datetime  索引创建 命名规范  IX[TableName][Column1]_[Column2] 字段与索引顺序一致  主键设计  InnoDB 必须有自增主键，建议为 int 且与业务无关 唯一索引  复合索引  MYSQL 搜索顺序同索引字段顺序  建议  索引个数控制于 3 个以内，不超过 5 个  SQL 编程 SELECT  SELECT COLUMN_NAME, NOT SELECT *  多表关联  为各表使用别名  DISTINCT  唯一索引不需要 可考虑程序去重  OR  多个 OR 或 AND 常会导致表扫描 可用 UNION代替 OR，或 FORCE INDEX 强制使用主索引  COUNT  Use COUNT(*) in one table and no WHERE  LIMIT  建议 尽量使用 LIMIT M，避免 LIMIT M,N 通过条件和 LIMIT M 来代替 LIMIT M,N 例 SELECT * FROM message WHERE id &amp;gt; 9520 ORDER BY id ASC LIMIT 20;  !=  避免 != | &amp;lt;&amp;gt; ，使用 &amp;gt; | &amp;lt; | &amp;gt;= | &amp;lt;= 代替，从而正常使用索引  避免 IN  建议 IN 只接常量 子查询使用表关联代替 例 select * from tb1 where tb1.id in (select id from tb2 where tb2.c1…) Select tb1.* from tb1 , (select id from tb2 where tb2.c1…)t where tb1.id = t.id  </content>
    </entry>
    
     <entry>
        <title>Spring.Basic</title>
        <url>http://domain.yqjdcyy.com/post/spring.basic/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Spring</tag>
        </tags>
        <content type="html">  AOP 介绍  Aspect-Oriented Programming 面向切面编程，对着代码横着切入 对方法的增强为 Weaving （织入） 对类的增强为 Introduction （引入）  代理 代码写死  interface
public interface Greeting { void sayHello(String name); }  implement
public class GreetingImpl implements Greeting { @Override public void sayHello(String name) { before(); System.out.println(&amp;#34;Hello! &amp;#34; &#43; name); after(); } private void before() { System.out.println(&amp;#34;Before&amp;#34;); } private void after() { System.out.println(&amp;#34;After&amp;#34;); } }   静态代理  resolution 单独为 GeetingImpl 创建代理类 proxy
public class GreetingProxy implements Greeting { private GreetingImpl greetingImpl; public GreetingProxy(GreetingImpl greetingImpl) { this.greetingImpl = greetingImpl; } @Override public void sayHello(String name) { before(); greetingImpl.sayHello(name); after(); } private void before() { System.out.println(&amp;#34;Before&amp;#34;); } private void after() { System.out.println(&amp;#34;After&amp;#34;); } }  call
Greeting greetingProxy = new GreetingProxy(new GreetingImpl()); greetingProxy.sayHello(&amp;#34;Jack&amp;#34;);   JDK 动态代理  resolution 合并所有代理类功能至动态代理类中 只能代理接口 proxy
public class JDKDynamicProxy implements InvocationHandler { private Object target; public JDKDynamicProxy(Object target) { this.target = target; } @SuppressWarnings(&amp;#34;unchecked&amp;#34;) public &amp;lt;T&amp;gt; T getProxy() { return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), // 使用该实现类的接口实现  target.getClass().getInterfaces(), // 通用代理功能  this // 代理实现功能  ); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { before(); Object result = method.invoke(target, args); after(); return result; } private void before() { System.out.println(&amp;#34;Before&amp;#34;); } private void after() { System.out.println(&amp;#34;After&amp;#34;); } }  call
Greeting greeting = new JDKDynamicProxy(new GreetingImpl()).getProxy(); greeting.sayHello(&amp;#34;Jack&amp;#34;);   CGLib 动态代理  resolution 支持对任意类的代理 proxy
public class CGLibDynamicProxy implements MethodInterceptor { private static CGLibDynamicProxy instance = new CGLibDynamicProxy(); private CGLibDynamicProxy() { } public static CGLibDynamicProxy getInstance() { return instance; } @SuppressWarnings(&amp;#34;unchecked&amp;#34;) public &amp;lt;T&amp;gt; T getProxy(Class&amp;lt;T&amp;gt; cls) { return (T) Enhancer.create(cls, this); } @Override public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable { before(); Object result = proxy.invokeSuper(target, args); // 使用反射支持所有类  after(); return result; } private void before() { System.out.println(&amp;#34;Before&amp;#34;); } private void after() { System.out.println(&amp;#34;After&amp;#34;); } }  call
Greeting greeting = CGLibDynamicProxy.getInstance().getProxy(GreetingImpl.class); greeting.sayHello(&amp;#34;Jack&amp;#34;);   Spring AOP 前置增强  proxy
@Component public class GreetingBeforeAdvice implements MethodBeforeAdvice { @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(&amp;#34;Before&amp;#34;); } }  call ``` java ProxyFactory proxyFactory = new ProxyFactory(); // 创建代理工厂
proxyFactory.setTarget(new GreetingImpl()); // 射入目标类对象
proxyFactory.addAdvice(new GreetingBeforeAdvice()); // 添加前置增强
  Greeting greeting = (Greeting) proxyFactory.getProxy(); // 从代理工厂中获取代理
greeting.sayHello(&amp;ldquo;Jack&amp;rdquo;);
#### 后置增强 - proxy ``` java @Component public class GreetingAfterAdvice implements AfterReturningAdvice { @Override public void afterReturning(Object result, Method method, Object[] args, Object target) throws Throwable { System.out.println(&amp;#34;After&amp;#34;); } }   call ``` java ProxyFactory proxyFactory = new ProxyFactory(); // 创建代理工厂
proxyFactory.setTarget(new GreetingImpl()); // 射入目标类对象
proxyFactory.addAdvice(new GreetingAfterAdvice()); // 添加后置增强
  Greeting greeting = (Greeting) proxyFactory.getProxy(); // 从代理工厂中获取代理
greeting.sayHello(&amp;ldquo;Jack&amp;rdquo;);
#### 环绕增强 - resolution - 前置增强&#43; 后置增强 - proxy ``` java @Component public class GreetingAroundAdvice implements MethodInterceptor { @Override public Object invoke(MethodInvocation invocation) throws Throwable { before(); Object result = invocation.proceed(); after(); return result; } private void before() { System.out.println(&amp;#34;Before&amp;#34;); } private void after() { System.out.println(&amp;#34;After&amp;#34;); } }   call java ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;aop/demo/spring.xml&amp;quot;); // 获取 Spring Context Greeting greeting = (Greeting) context.getBean(&amp;quot;greetingProxy&amp;quot;); // 从 Context 中根据 id 获取 Bean 对象（其实就是一个代理） greeting.sayHello(&amp;quot;Jack&amp;quot;);   抛出增强  implements
@Component public class GreetingImpl implements Greeting { @Override public void sayHello(String name) { System.out.println(&amp;#34;Hello! &amp;#34; &#43; name); throw new RuntimeException(&amp;#34;Error&amp;#34;); // 故意抛出一个异常，看看异常信息能否被拦截到 } } proxy
@Component public class GreetingThrowAdvice implements ThrowsAdvice { public void afterThrowing(Method method, Object[] args, Object target, Exception e) { System.out.println(&amp;#34;---------- Throw Exception ----------&amp;#34;); System.out.println(&amp;#34;Target Class: &amp;#34; &#43; target.getClass().getName()); System.out.println(&amp;#34;Method Name: &amp;#34; &#43; method.getName()); System.out.println(&amp;#34;Exception Message: &amp;#34; &#43; e.getMessage()); System.out.println(&amp;#34;-------------------------------------&amp;#34;); } }   引入增强  interface
public interface Apology { void saySorry(String name); }  proxy
@Component public class GreetingIntroAdvice extends DelegatingIntroductionInterceptor implements Apology { @Override public Object invoke(MethodInvocation invocation) throws Throwable { return super.invoke(invocation); } @Override public void saySorry(String name) { System.out.println(&amp;#34;Sorry! &amp;#34; &#43; name); } }  config
&amp;lt;bean id=&amp;#34;greetingProxy&amp;#34; class=&amp;#34;org.springframework.aop.framework.ProxyFactoryBean&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;interfaces&amp;#34; value=&amp;#34;aop.demo.Apology&amp;#34;/&amp;gt; &amp;lt;!-- 需要动态实现的接口 --&amp;gt; &amp;lt;property name=&amp;#34;target&amp;#34; ref=&amp;#34;greetingImpl&amp;#34;/&amp;gt; &amp;lt;!-- 目标类 --&amp;gt; &amp;lt;property name=&amp;#34;interceptorNames&amp;#34; value=&amp;#34;greetingIntroAdvice&amp;#34;/&amp;gt; &amp;lt;!-- 引入增强 --&amp;gt; &amp;lt;property name=&amp;#34;proxyTargetClass&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;!-- 使用CGLib代理目标类（默认为 false，使用JDK动态代理接口） --&amp;gt; &amp;lt;/bean&amp;gt;  call ``` java ApplicationContext context = new ClassPathXmlApplicationContext(&amp;ldquo;aop/demo/spring.xml&amp;rdquo;);
GreetingImpl greetingImpl = (GreetingImpl) context.getBean(&amp;ldquo;greetingProxy&amp;rdquo;); // 注意：转型为目标类，而并非它的 Greeting 接口
greetingImpl.sayHello(&amp;ldquo;Jack&amp;rdquo;);
  Apology apology = (Apology) greetingImpl; // 将目标类强制向上转型为 Apology 接口（这是引入增强给我们带来的特性，也就是“接口动态实现”功能）
apology.saySorry(&amp;ldquo;Jack&amp;rdquo;);
```
</content>
    </entry>
    
     <entry>
        <title>Sublime.Plugin</title>
        <url>http://domain.yqjdcyy.com/post/sublime.plugin/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Sublime</tag><tag>Plugin</tag>
        </tags>
        <content type="html">  参考  sublime插件开发  结构  Packages plugin-fodler plugin.sublime-package(.zip) default key/ menu/ setup user read at lastest plugin-command Text Commands: current view Window Commands: current windows Application Commands: nothing 注： sublime 会将继承 plugin-command 的类去掉 Command 后缀，并将驼峰格式转换为下划线格式  流程  Tools-&amp;gt; new plugin&amp;hellip; mkdir Packages/ hello_world/ hello_world.py： 同名 ctrl&#43; ` 并输入 view.run_command(&amp;lsquo;example&amp;rsquo;) -&amp;gt; 即可看到当前文章头部插入 &amp;lsquo;Hello, World!&amp;rsquo;  sublime插件开发手记 Sublime插件开发API手册  API Sublime error/ message clipboard.setter&amp;amp; getter run_command(string, ) log_commands/input(flag) version/ platform/ arch View - 缓冲区视图 run_command(string, ) insert/ erase/ replace/ find sel()/ rowcol show/ fold/ unfold run_command RegionSet Region Edit Window new_file([file_name, ]) flag sublime.ENCODED_POSITION - 查找文件名后缀 sublime.TRANSIENT - 指定预览打开 active_view/ focus_view/ views Settings - sublime.load_settings get/ set/ erase Basic EventListener new/ clone/ load/ close/ preSave/ postSave/ modified/ selectionModified/ activated ApplicationCommand run isEnabled/ isVisible description WindowCommand 每个 window 只初始化一次，方法同 ApplicationCommand TextCommand 每个 view 只初始化一次，方法同 ApplicationCommand  </content>
    </entry>
    
     <entry>
        <title>Mysql.Basic</title>
        <url>http://domain.yqjdcyy.com/post/mysql.basic/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Mysql</tag>
        </tags>
        <content type="html">  基础知识 存储结构 表空间：所有数据逻辑地存放于ib_data1文件中 |- 数据库 |- 区：InnoDB每次最多申请4个区，即 4M 的存储空间 |- 页1：B-Tree 结构存储，16KB，大小不能调整，Mysql 最小逻辑单位 |- …… |- 页* 64 |- 行1： 数据行存在数据行中，每页最多7992行 |- …… |- 行* 7992 |- 索引段 |- 回滚段 |- 页 注：InnoDB按每张表的主键构造一 B&#43; 树 索引 聚集索引 是否支持聚集引擎，取决于采用的存储引擎，其中InnoDB会建立。 概念：实际数据行和相关的键值保存在一起。 原理：把索引和数据都保存于一 B&#43; 树数据结构，并同时将索引列与相关数据行保存在一起。则访问同一数据页不同记录，数值数据于内存中已存在。 注：一表仅可包含一个聚集索引，仅于按索引顺序过滤查询有效。 非聚集索引 概念&amp;amp; 原理：参考聚集索引，同样按索引值进行 B&#43; 树存储，但区别于树中只存放索引和相应数值的指针，而不与数据一同存储。 联合索引 概念：两个或两个以上列索引 注意：建立时考虑列顺序，索引越少越好（更新数据时需维护索引值） 注：避免file sort（索引不到情况下使用临时文件排序查找）、临时表（建立在系统临时文件夹中的表）和表扫描（操作中数据库引擎必须读取表中的所有页以查找符合查询条件的行）。 执行顺序 （5）SELECT DISTINCT TOP() （1）FROM (1-J) &amp;lt;left_table&amp;gt; &amp;lt;join_type&amp;gt; JOIN &amp;lt;right_table&amp;gt; ON &amp;lt;on_predicate&amp;gt; | (1-A) &amp;lt;left_table&amp;gt; &amp;lt;apply_type&amp;gt; APPLY &amp;lt;right_table_expression&amp;gt; AS &amp;lt;alias&amp;gt; | (1-P) &amp;lt;left_table&amp;gt; PIVOT(&amp;lt;pivot_specification&amp;gt;) AS &amp;lt;alias&amp;gt; | (1-U) &amp;lt;left_table&amp;gt; UNPIVOT(&amp;lt;unpivot_specification&amp;gt;) AS &amp;lt;alias&amp;gt; （2）WHERE &amp;lt;where_predicate&amp;gt; （3）GROUP BY &amp;lt;group_by_specification&amp;gt; （4）HAVING &amp;lt;having_predicate&amp;gt; （6）ORDER BY &amp;lt;order_id_list&amp;gt; 操作相关 更改密码 mysql -u root -p &amp;gt; Enter password user mysql; update user set password=passworD(&amp;#34;new pass&amp;#34;) where user=&amp;#39;root&amp;#39;; flush privileges; exit; 允许指定 IP 访问 &amp;gt; mysql -uroot -p; &amp;gt; Yk1qazxsw2 // root &amp;gt; use mysql; &amp;gt; show grants for yunkai_user@110.89.71.200; &amp;gt; GRANT ALL PRIVILEGES ON yunkai.* TO &amp;#39;yunkai_user&amp;#39;@&amp;#39;110.89.71.200&amp;#39; IDENTIFIED BY &amp;#39;@Y#z!2aZx&amp;#39;; &amp;gt; GRANT ALL PRIVILEGES ON yunkai.* TO &amp;#39;yunkai_user&amp;#39;@&amp;#39;120.36.189.%&amp;#39; IDENTIFIED BY &amp;#39;@Y#z!2aZx&amp;#39;; // 范围值</content>
    </entry>
    
     <entry>
        <title>Oracle.基础</title>
        <url>http://domain.yqjdcyy.com/post/oracle.%E5%9F%BA%E7%A1%80/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Oracle</tag>
        </tags>
        <content type="html">  系统构造 The System Global Area (SGA)  组成 描述 Buffer Cache 作为查询修改前的优先查看区 Shared Pool SQL重用、储存程序、数据字典信息如用户账号信息及表索引 Redo Log Buffer 多次缓存重做信息一次写入 Large Pool 服务进程的大数据量I/O请求之用 Java Pool 用于Java虚拟机的特定会话的代码和数据 Streams Pool Oracle流产品专用
The Program Global Area (PGA) 系统启动后应客户端请求建立的服务进程专用的，主要用于实现SQL和保存登陆等相关会话信息
Oracle Background Processes 初始时创建的用于维护内存结构、进行异步数据I/O读写及日常的维护任务，从而更好地实现增加并行操作的可靠性
  数据库管理 Control Files 物理组成元件，可复制即实现复用 Tablespaces  逻辑结构  包含一个或多个Datafiles或Tempfiles.  默认表空间  EXAMPLE：Oracle测试、示例空间 SYSAUX：SYSTEM辅助空间 SYSTEM：含数据字典等控制数据库信息的表和索引 TEMP：执行SQL用作系统的临时操作空间 UNDOTBS1：专用存储撤消操作信息 USERS：存储永久用户对象和数据  表空间类型
 永久：用于存储用户或程序数据 撤消：用于避免读一致和启用数据回滚，不用时会被自动删除，多个情况下同时也只- 一个会被启用 临时：用于执行SQL排序等操作时的辅助库
Temporary Tablespace Groups Datafiles  保存数据库数据的操作系统文件，但用数据库方式写入，无法为其它程序识别。
 可分化组件：段和区（多块邻近数据块组成）、数据块（最小IO元件，建库后不可变更）
Rollback Segments Redo Log Groups 多份重做日志，避免由于错误操作导致变更数据永久写入数据文件而无法恢复。
 多重做日志组（通常有三组），通过内存缓冲区写入数据直到组信息满或请求切换，并循环切换。
Archive Logs 重做日志的异地存储复本，可用于数据恢复。
  数据库空间回收  收缩操作  对表进行操作，不影响表的DML操作  重组操作  重组表空间中的不同部分，但必须事先拥有与对象大小相等的自由空间才能成功  人工清表  还原数据  概念  事务操作前事先保存下来的数据  特点  便于事务的快速回滚&amp;amp; 保持读一致性&amp;amp; 使用闪回表保存   ORACLE报告顺序  根据WHERE子句选择行 根据GROUP BY子句将这些行分组 为第一组计算分组函数的结果 根据HAVING子句选择和排除组 根据ORDER BY子句中分组函数的结果对组进行排序  ORDER BY子句必须使用分组函数（COUNT(*)） 或者使用在GROUP BY子句中指定的列   ORACLE常用函数 CHAR  TO_CHAR  TO_CHAR(SYSDATE, &amp;lsquo;DDD&amp;rsquo;) TO_CHAR(TO_DATE(&amp;lsquo;2002-08-26&amp;rsquo;, &amp;lsquo;YYYY-MM-DD&amp;rsquo;),&amp;lsquo;DAY&amp;rsquo;,&amp;lsquo;NLS_DATE_LANGUAGE = FRENCH&amp;rsquo;) TO_CHAR(&amp;lsquo;11111111.&amp;rsquo;, &amp;lsquo;$99999,999.99&amp;rsquo;)  $11111,111.00  TO_CHAR(TO_DATE(222, &amp;lsquo;J&amp;rsquo;), &amp;lsquo;Jsp&amp;rsquo;)  Two Hundred Twenty-Two  TO_CHAR(TO_DATE(222, &amp;lsquo;J&amp;rsquo;), &amp;lsquo;JSP&amp;rsquo;)  TWO HUNDRED TWENTY-TWO    TIME  TO_DATE  TO_DATE(&amp;lsquo;2013-02-18 22:20:15&amp;rsquo;, &amp;lsquo;YYYY-MM-DD HH24:MI:SS&amp;rsquo;) TO_DATE(&amp;lsquo;2013&amp;rsquo;, &amp;lsquo;YYYY&amp;rsquo;)  BETWEEN  FLOOR(SYSDATE - TO_DATE(&amp;lsquo;20130101&amp;rsquo;, &amp;lsquo;YYYYMMDD&amp;rsquo;)) FLOOR(MONTHS_BETWEEN(TO_DATE(&amp;lsquo;20131231&amp;rsquo;, &amp;lsquo;YYYYMMDD&amp;rsquo;), TO_DATE(&amp;lsquo;20010201&amp;rsquo;, &amp;lsquo;YYYYMMDD&amp;rsquo;)))  NEXT_DAY  NEXT_DAY(SYSDATE, 1) ADD_MONTHS(SYSDATE, 2)  NEW_TIME  NEW_TIME(SYSDATE, &amp;lsquo;GMT&amp;rsquo;, &amp;lsquo;EST&amp;rsquo;)  大西洋标准时间：AST或ADT 阿拉斯加_夏威夷时间：HST或HDT 英国夏令时：BST或BDT 美国山区时间：MST或MDT 美国中央时区：CST或CDT 新大陆标准时间：NST 美国东部时间：EST或EDT 太平洋标准时间：PST或PDT 格林威治标准时间：GMT Yukou标准时间：YST或YDT    FUNCTION  ROUND  ROUND(SYSDATE [,&amp;rsquo;[DD|year|mouth|day]&amp;ldquo;)  获取最近的 [日期|年|月|周日] 日期  TRUNC(SYSDATE [,&amp;rsquo;[DD|year|mouth|day]&amp;ldquo;)  截取 [当天|当年首日|当月首日|周日] 的时间，且无时分秒   BYTE  TO_MULTI_BYTE(&amp;lsquo;高A&amp;rsquo;)  将字串的半角转换为全角  TO_SINGLE_BYTE(&amp;lsquo;高Ａ&amp;rsquo;)  全角转半角   NULL  NVL(EXP1, EXP2)  NULl == EXP1? EXP2: EXP1 两者类型要求一致  NVL2(EXP1, EXP2, EXP3)  NULL== EXP1? EXP3: EXP2 EXP2与EXP3类型不同，则EXP3自动转换为EXP2的类型  NULLIF(EXP1, EXP2)  EXP1== EXP2? NULL: EXP1  COALESCE(EXP1, EXP2,&amp;hellip;EXPN)  返回列表中第一个非空表达式，若均空则返回空值   TYPE  DUMP(INPUT[,TYPE [,Y [,Z]]]  返回INPUT的数据类型，字节长度及内部存储位置  GREATEST(EXP1, EXP2,&amp;hellip;, EXPN) LEAST(EXP1, EXP2,&amp;hellip;, EXPN) LENGTH/LENGTHC(INPUT)  一个汉字算一个字符  VSIZE/LENGTHB(INPUT)  一个汉字算两个字节    </content>
    </entry>
    
     <entry>
        <title>Redis.Basic</title>
        <url>http://domain.yqjdcyy.com/post/redis.basic/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Redis</tag>
        </tags>
        <content type="html">  参考  Redis Virtual Memory: the story and the code ​Virtual Memory technical specification  数据类型 Keys  del key1 key2&amp;hellip; keyN  删除给定KEY  type key  返回当前key类型  keys pattern  匹配指定模式的所有KEY  randomkey  返回当前库随机KEY  rename oldkey newkey  重命名，若newkey存在则以oldkey值覆盖  renamenx oldkey newkey  重命名，但newkey存在时返回0  dbsize  返回当前数据库key数量  expire key seconds  为KEY指定过期时间  ttl key  返回设置过期时间的KEY的剩余时间  select db-index  通过索引选择数据库，默认为0，默认数据库个数16个  move key db-index  将当前库中的KEY移动至指定索引库中  flushdb  删除当前库中所有KEY，不会失败  flushall  删除所有库中的所有KEY，不会失败   String 特点  最基本类型，二进制安全，可包含任何数据，上限为一G字节
常用方法 set key value
 设置KEY对应的Sring类型值  setnx key value
 若key不存在时设置，nx= not exists  get key
 获取KEY对应Sring值  getset key value
 原子设置KEY值，并返回原值  mset key1 value1&amp;hellip; keyN valueN
 批量写入  msetnx key1 value1&amp;hellip; keyN valueN
 批量写入，但不覆盖已有值  mget key1 key2&amp;hellip; keyN
 一次性获取多个KEY  incr key
 key&#43;&#43;  decr key
 key&amp;ndash;  incrby key integer
 set key nvl(key, 0)&#43;integer  decrby key integer
 substr key start end
 截取KEY的值，只读不改，且从0开始   List 特点  元素均为String类型的双向链接 [lr]push/[lr]pop/llen的时间复杂度均为O(1) 最大长度为2的32次方-1
常用方法 l/rpush key string
 于key列表头部[尾部]添加元素  llen key
 返回key列表长度  lrange key start end
 返回key列表指定区间内的元素  lset key index value
 设置key列表指定位置的元素值  lrem key count value
 从左开始key列表中指定count个值为value的元素，若count=0表示清除所有  l/rpop key
 于key列表的头部[尾部]移除元素  blpop key1&amp;hellip; keyN timeout
 从左至右扫描并返回第一个非空list进行lpop操作，若均为空或不存在，则阻塞timeout时间（若timeout=0则表示一直等待），并且于阻塞期间，若有记录插入其中一个列表，则立即对其执行lpop操作  rpoplpush strkey destkey
 将strkey的尾部移除并插入destkey的头部，该操作为原子操作   Set 特点  string类型无序集合，最大可含2的32次方-1个元素 增删查因为hash table实现，复杂度均为O(1) 调整hash table大小需同步，会获取锁而阻塞其它读写操作。
常用方法 sadd key member
 为数据添加元素  stem key member
 移除指定数组中的指定元素  spop key
 随机取除任一元素  srandmember key
 随机读取任一元素  smove strkey dstkey member
 将strkey数组中的member移动至dstkey数组中，原子操作。  scard key
 返回数组元素个数  sismember key member
 判断member是否为key数组的元素  sinter key1..keyN
 返回数组的交集  sinterstore dstkey key1..keyN
 存储sinter结果至dstkey  sunion key1..keyN
 所有数组的并集集  sunionstore dstkey key1..keyN
 存储sunion结果至dstkey  sdiff key key1..keyN
 返回key中于其它数组中所不包含的元素  sdfif dstkey key key1..keyN
 存储sdiff结果至dstkey  smembers key
 返回key中所有元素   Sorted Set 特点  [score: double, value: string] score映射至hash table，因此获取score的复杂度为O(1) 增删开销为O(log(N)) 一般作为索引使用
常用方法 zadd key score member
 添加元素到集合，若element存在则更新其score  zrem key member
 移除集合中的element元素  zincryby key incr member
 为集合中element元素的的score加上incr值，并调整list序列顺序  z[rev]rank key member
 显示集合中member元素的排位  z[rev]range key start end
 显示集合中指定区域的数值情况  zcount key min max
 显示集中指定区域内的元素个数  zcard key
 显示集合中无数的个数  zscore key element
 显示集中中element元素对应的score值  zremrangebyrank[score] key min max
 按排名[score]删除集合中给定区域的值   Hash 特点  field/value映射表，适合存储对象，复杂度为平均O(1) 初始使用zipmap存储，待达到配置文件指定限制后转hash实现
常用方法 hset key field value
 hget key field
 hmset key field1 value1..fieldN valueN
 hmget key field1..fieldN
 hexists key field
 hdel key field
 hlen/hkeys/hvals/hgetall key
 返回hash中的field数量/所有field/所有value/所有的field和value   排序 特点  支持对list/set/sorted set进行排序操作
格式 SORT key [BY pattern] [LIMIT start count] [GET pattern] [ASC|DESC] [ALPHA] [STORE dstkey]
详解  [BY pattern] 将集合元素内容按给定pattern组成新key后，按其对应的内容进行排序。 例  list uid= 1/2/3/4 set user_name_1[2/3/4]= admin[jack/peter/mary] set user_level_1[2/3/4]= 99[32/80/9] sort uid by user_name_*= 4/3/2/1 sort uid by user_level_*= 4/2/3/1  [LIMIT start count] 限制返回由start开始的count个结果 [GET pattern] 返回pattern作为新值时的元素值。 例  sort uid get user_name*= nil/nil/nil/nil sort uid get user_name_*= admin/jack/peter/mary  [ASC|DESC] 指定排序方式，如bz/az/1/2或2/1/bz/az(desc) [ALPHA] 按字母进行排序，如1/2/az/bc或bz/az/2/1(desc) [STORE dstkey] 将结果以list方式保存 [KEY-&amp;gt;FIELD]`  于BY/GET pattern方式中使用，用于获取pattern组装值对应的域值 例  hmset user_info_1 name admin level 99 hmset user_info_2 name jack level 10 hmset user_info_3 name peter level 25 hmset user_info_4 name mary level 70  sort uid user_info_* -&amp;gt; desc get user_info_* -&amp;gt;name 按userinfo*中的等级进行降序排列，并输出对应位置的名称      事务 特点  单线程来处理所有client请求 一般接到client发来的命令时立即处理并返回处理结果，但连接中发出multi命令后进入事务上下文，后续命令先放入队列中，并于接收到exec命令后执行所有并汇总打包所有 命令结果至client 事务中的写操作不能依赖于事务中的读操作结果，因为事务中命令只排队不立即执行  缺陷  事务中一个命令失败，并不回滚其它命令 事务执行期间，redis挂了则后面事务丢失。  -&amp;gt; 使用append-only file方式持久化，redis会使用单个write操作定稿事务内容，但仍存在部分写事务到磁盘。 而redis重启时会检测部分写入事务情况，并失败退出。 可用redis-chec-aof进行修复，删除部分写入的事务内容后重启即可。   常用指令  multi  开启事务上下文  exec/discard  执行或放弃操作，结束事务上下文  watch  整个连接内监听keys，可于事务exec前判断是否有keys值发生改变，而决定跳出事务。   pipeline 介绍  redis为cs模式的tcp server，使用类http请求响应协议。 支持一个client通过一个socket连接必起狐假虎威请求命令，并阻塞等待redis服务处理。 由于网络延迟等，客户端一秒可能只能发N条命令，但redis服务一秒可以执行远大N条的命令。 而pipeline便是将命令打包后一并发出一并处理的操作。
注意事项 pipeline方式打包指令，redis须于处理完所有命令前无缓存所有命令处理结果，命令越多则缓存消耗内存越大。
  代码 ConnectionSpec spec = DefaultConnectionSpec.newSpec(&amp;#34;192.168.56.55&amp;#34;, 6379, 0, null); JRedis jredis = new JRedisPipelineService(spec); 持久化 特点  支持持久化的内存数据库
类型 Snapshooting（快照） 默认方式
 特点
 将内存数据以快照方式写入二进制文件，默认文件名为dump.rdb  配置
 redis.conf-&amp;gt; save time count，若time秒内count个key被修改则发起快照保存  流程
 redis调用fork，生成父子进程 父进程继续处理client请求，子进程负责将内存内容写入到临时文件。  由于os的写时复制机制(copy on write)父子进程会共享相同的物理页面。 当父进程处理写处理写请求时os会为父进程要修改的页面创建副本，而不是写共享页面。 所以子进程的地址空间内的数据是fork时刻整个数据库的一个快照。  当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。  注意
 client可使用save/bgsave通知redis做一次快照持久化。 save为主线程中保存快照，会阻塞所有client请求。 每次快照持久化均将内存数据完整写入，数据量大会影响IO性能。 由于快照一段时间操作一次，若redis意外down掉，会丢失最后一次快照后的所有修改。   Append-only fill（aof）  特点  redis会将每一个收到的写命令都通过write函数追加至文件中，默认为appendonly.aof。redis重启时再重新执行文件命令来重建事个数据库。  配置  redis.conf  appendonly yes //启用aof持久化方式 #appendfsync always //每次收到写命令就立即强制写入硬盘，最慢量最能保证完全持久化，不推荐 appendfsync everysec //每秒钟强制写入磁盘一次，推荐使用 #appendfsync no //完全依赖OS，性能最好，但无法保证持久化   流程  提供bgrewriteaof命令，要求redis使用快照方式将内存数据以命令方式保存至临时文件，最后替换原文件。 redis调用fork，生成父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令 父进程继续处理client请求，将写命令写入aof文件并缓存起来（避免子进程重写失败） 子进程将快照内容写入命令方式的临时文件后，通知父进程将缓存写命令也写入 父进程将临时文件远的旧aof文件并重命令，同时继续往之追加写命令  注意  只根据现有库记录写命令，不读旧AOF，相当于快照方式   主从复制 特点  主从复制允许多个slave server拥有和master server相同的数据库脚本。 slave可以和master或其它slave相连。 主从复制不会阻塞master，而slave在初次同步时会阻塞。因此可通过多个slave专用于处理client的读请求以提高系统的可伸缩性。同时可限制master的数据持久化而转于slave上配置数据持久化。
过程 配置好slave服务器后，slave自动建立与master的连接并发送sync命令。
 master为slave创建后台进程，保存快照并缓存后续的写命令。
 待快照完成后由master发送给slave，slave保存至本地后加载至内存恢复。后续master再将缓存写命令同样连接发送给slave。
 slave和master连接断开时时自动重连，而多个slave同步连接时，仅会启动一个进程来写数据库镜像并发送给所有slave。
配置 slaveof 192.168.1.1 6379
 指定master的ip和端口   虚拟内存 特点  暂时将不经常访问的数据从内存交换到磁盘 不使用OS虚拟内存原因
 redis.obj远小于虚拟内存的最小单位4K，影响系统识别页面活跃情况而不利于资源回收 redis可将交换到磁盘的对象压缩（去除指针和对象元数据信息），比内存对象小10倍
配置 vm-enabled yes #开启vm功能 vm-swap-file /tmp/redis.swap #交换出来的value保存的文件路径/tmp/redis.swap vm-max-memory 1000000 #redis使用的最大内存上限，超过上限后redis开始交换value到磁盘文件中。 vm-page-size 32 #每个页面的大小32个字节 vm-pages 134217728 #最多使用在文件中使用多少页面,交换文件的大小= vm-page-size * vm-pages vm-max-threads 4 #用于执行value对象换入换出的工作线程数量。0表示不使用工作线程   </content>
    </entry>
    
     <entry>
        <title>Java.常用技术</title>
        <url>http://domain.yqjdcyy.com/post/java.%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag>
        </tags>
        <content type="html">  参考  http://unmi.cc/jdk-5-concurrent-callable-futuretask-etc/ http://www.cnblogs.com/wn398/archive/2013/06/15/3130967.html http://ifeve.com/locks/  获取路径 ###分类： - 绝对路径：主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 - 例：C:xyz est.txt 代表了test.txt文件的绝对路径 - 相对路径：相对与某个基准目录（一般对照WEB）的路径。 - 例：&amp;rdquo;/&amp;ldquo;代表Web应用的跟目录， &amp;ldquo;./&amp;rdquo; 代表当前目录,&amp;ldquo;../&amp;ldquo;代表上级目录 - 注：JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的
获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&amp;ldquo;？&amp;rdquo;) &amp;ndash;&amp;gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&amp;rdquo;\&amp;ldquo;) //站点绝对路径 application.getRealPath(&amp;ldquo;&amp;rdquo;) //JSP界面使用 ServletContext().getRealPath(&amp;ldquo;&amp;rdquo;)  返回字串  C:\Apache\Tomcat\webapps\local&#43; （\ . 空格 \web.xml）   工程Classes下路径（SRC/CLASS）  使用环境  SERVLET/JSP/JAVA（即任意CLASS）  使用语句  this.getClass()/JdomParse.class .getClassLoader().getResource(&amp;ldquo;&amp;rdquo;).getPath(); //注：因为三者均为JAVA程序，都为CLASS，故为三者通用方法 this.getClass()JdomParse.class .getResource(&amp;ldquo;&amp;rdquo;).getPath().toString(); //可用于不同WEB环境来确认路径 Thread.currentThread().getContextClassLoader().getResource(&amp;ldquo;&amp;rdquo;).getPath()  返回字串
 /D:/workspace/strutsTest/WebRoot/WEB-INF/classes/ /D:/workspace/strutsTest/WebRoot/WEB-INF/classes/bl/ /E:/order/002_ext/WebRoot/WEB-INF/classes/
系统路径  使用环境
 APPLICATION/SERVLET/JSP  使用语句：
 System.getProperty(&amp;ldquo;user.dir&amp;rdquo;) //相对项目（JAVA为项目，WEB依工具而定）路径 ServletContext servletContext = config.getServletContext(); String rootPath = servletContext.getRealPath(&amp;ldquo;/&amp;rdquo;); application.getRealPath(&amp;ldquo;&amp;rdquo;)  返回字串
  WEB根上下文环境（即相对路径）  使用环境  于SERVLET的INIT中 于httpServletRequest中  使用语句  request.getContextPath()getRealPath(&amp;ldquo;/&amp;rdquo;); request.getSession().getServletContext().getRealPath(&amp;ldquo;/&amp;rdquo;);  返回字串  D:\工具\Tomcat-6.0\webapps\002_ext\ （其中002_ext为项目名称） request.getContextPath() -&amp;gt; web项目名   站点虚拟路径  使用环境 使用语句  getContextPath():  返回字串  类加载器路径  使用环境 使用语句  class.getClassLoader.getPath()；  InputStream is=TestAction.class.getClassLoader().getResourceAsStream(&amp;ldquo;test.txt&amp;rdquo;); InputStream is=Test1.class.getResourceAsStream(&amp;ldquo;/test.txt&amp;rdquo;);   返回字串  均返回指定路径文件（\src\test.txt）的装载项目 注：不论是一般的java项目还是web项目,先定位到能看到包路径的第一级目录（TestAction在其中）   泛型  介绍  重复代码重构，于编译时检测类型安全，保存所有强制类型均为自动或隐式，提高代码重用率  规则  泛型参数允许多个，且仅能为类类型，不能为简单类型 泛型参数支持extends(有办类型)或通配符类型 支持类型有泛型类、接口和方法  实例  class Gen&amp;lt;T&amp;gt; { private T ob; //定义泛型成员变量 public Gen(T ob) { this.ob = ob; } public T getOb() { return ob; } public void setOb(T ob) { this.ob = ob; } public void showType() { System.out.println(&amp;quot;T的实际类型是: &amp;quot; &#43; ob.getClass().getName()); } } public class GenDemo { public static void main(String[] args){ //定义泛型类Gen的一个Integer版本 Gen&amp;lt;Integer&amp;gt; intOb=new Gen&amp;lt;Integer&amp;gt;(88); intOb.showType(); int i= intOb.getOb(); System.out.println(&amp;quot;value= &amp;quot; &#43; i); //定义泛型类Gen的一个String版本 Gen&amp;lt;String&amp;gt; strOb=new Gen&amp;lt;String&amp;gt;(&amp;quot;Hello Gen!&amp;quot;); strOb.showType(); String s=strOb.getOb(); System.out.println(&amp;quot;value= &amp;quot; &#43; s); } }  泛型方法  public static &amp;lt;T&amp;gt; T display(T t) { return t; }   JMX 推荐  介绍：http://www.ibm.com/developerworks/cn/java/j-lo-jse63/ Tomcat配置：http://tomcat.apache.org/tomcat-7.0-doc/monitoring.html#Enabling_JMX_Remote 入门示例：http://rabbit9898.iteye.com/blog/1009198 官方事例：http://docs.oracle.com/javase/1.5.0/docs/guide/jmx/examples.html 官方教程：http://docs.oracle.com/javase/tutorial/jmx/index.html  组成  Instrumentation  使用MBean在遵循JMX规范中定义的设计模式和接口的基础上，确保提供标准化管理资源的仪表。 MXBean为在MBean的基础上预定义了一组数据类型。  JMX agent  直接操作资源并使之于远程应用上生效，其核心部件为MBean server。  Remote management  通过协议适配器和连接器支持JVM提供外部JMX agent   监控管理 平台MXBeans和平台MBean Server 平台MXBeans是用监视和管理JVM及运行时环境的的组件，功能包括类加载系统，即时编译系统和垃圾回收等平台。并保证不同环境下的JVM使用统一规范。 平台MBean Server用于注册管理平台MXBeans或自行创建的MBeans。 JConsole  特点  java自带(JAVA_HOME/bin/jconsole.exe)可视化监控管理工具，可查看Java平台上运行的程序的性能和资源消耗的信息。  推荐  使用指导：http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html  定义  监控本地和远程JVM、java应用程序的可视化监督工具，使用JMX技术实现。  异常  描述  jConsole的MXBean树显示不合理  事例  MXBean列表：  com.sun.example:type=Triangle,side=isosceles,name=1 com.sun.example:type=Triangle,name=2,side=isosceles com.sun.example:type=Triangle,side=isosceles,name=3  树形结构  |-com.sum.example |-Triangle |-isosceles |-1 |-3 |-2 |-isosceles   解决  补充-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=type,side,name，指定关键字的顺序    MBeans介绍  概念  类似于JavaBean，并可管理所有需要管理的应用、资源和设备。  组成  一系列可读可写属性 一系列可调用方法 自行描述  分类  Standard MBeans Dynamic MBeans Open MBeans Model MBeans MXBeans  实例
标准MBean= todoMBean接口（定义所有方法属性）&#43; todo实现 public interface HelloMBean { //todoMBean接口 注：规范要求接口必须以 dosome&#43; MBean为名称 public String getName(); //只读 public int getCacheSize(); //可读可写 public void setCacheSize(int size); } public class Hello implements HelloMBean { //todo实现 private final String name = &amp;#34;Reginald&amp;#34;; private int cacheSize = DEFAULT_CACHE_SIZE; private static final int DEFAULT_CACHE_SIZE = 200; public String getName() { return this.name; } public int getCacheSize() { return this.cacheSize; } public synchronized void setCacheSize(int size) { this.cacheSize = size; System.out.println(&amp;#34;Cache size now &amp;#34; &#43; this.cacheSize); } } MXBean= 可支持任意客户端（包括远程）。命名不一定要为todoMXBean，可使用@MXBean注解 public interface QueueSamplerMXBean { //MXBean接口 public QueueSample getQueueSample(); public void clearQueue(); } public class QueueSampler implements QueueSamplerMXBean { //定义QueueSamplerMXBean实现 private Queue&amp;lt;String&amp;gt; queue; public QueueSampler (Queue&amp;lt;String&amp;gt; queue) { this.queue = queue; } public QueueSample getQueueSample() { //自定义返回类型 synchronized (queue) { return new QueueSample(new Date(), queue.size(), queue.peek()); } } public void clearQueue() { synchronized (queue) { queue.clear(); } } } 通知：用于反馈状态改变、事件或问题异常 必须实现 NotificationEmitter 或继承 NotificationBroadcasterSupport 实现 Notification 或子类如 AttributeChangedNotification public class Hello extends NotificationBroadcasterSupport implements HelloMBean { public synchronized void setCacheSize(int size) { Notification n = new AttributeChangeNotification(this, sequenceNumber&#43;&#43;, System.currentTimeMillis(), &amp;#34;CacheSize changed&amp;#34;, &amp;#34;CacheSize&amp;#34;, &amp;#34;int&amp;#34;, oldSize, this.cacheSize); sendNotification(n); } @Override public MBeanNotificationInfo[] getNotificationInfo() { String[] types = new String[]{ AttributeChangeNotification.ATTRIBUTE_CHANGE }; String name = AttributeChangeNotification.class.getName(); String description = &amp;#34;An attribute of this MBean has changed&amp;#34;; MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description); return new MBeanNotificationInfo[]{info}; } }  远程管理  概念  JMX API 允许通过JMX连接器（服务端和客户端组成）远程管理个人资源，并定义了远程方法调用（RMI）基础上标准连接协议。  注：需要应用配置以正常的参数，具体可参见【Tomcat本地JMX监控】或如下例   指令调用  javac com/example/*.java //编译java文件 java -Dcom.sun.management.jmxremote.port = 9999 \ -Dcom.sun.management.jmxremote.authenticate = false \ -Dcom.sun.management.jmxremote.ssl = false \ com.example.Main //启动时配置调用端口等信息  启动要求  java1.5：命令行指定JMX才会启动 java1.6：默认启动JMX  注：jConsole可通过pid（进程ID）进行JMX管理，其中内部将pid转换为JMX URL   调用  //RMI&#43; 连接&#43; MBeanServer获取 JMXServiceURL url =new JMXServiceURL(&amp;quot;service:jmx:rmi:///jndi/rmi://:9999/jmxrmi&amp;quot;); JMXConnector jmxc = JMXConnectorFactory.connect(url, null); MBeanServerConnection mbsc = jmxc; //明确的MBean或MXBean - 代理调用 ObjectName mbeanName = new ObjectName(&amp;quot;com.example:type=Hello&amp;quot;); HelloMBean mbeanProxy = JMX.newMBeanProxy(mbsc, mbeanName, HelloMBean.class, true); 或 OperatingSystemMXBean osBean= ManagementFactory.newPlatformMXBeanProxy(mbsc, ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME, OperatingSystemMXBean.class); mbeanProxy.getCacheSize(); //调用方法和属性 //未明确MBean或MXBean情况 ObjectName objectName= new ObjectName(appName&#43; &amp;quot;:name=MuleContext&amp;quot;); //获取属性 String status= mbsc.getAttribute(objectName, &amp;quot;Stopped&amp;quot;).toString(); mbsc.invoke(object, action, param, signature); //调用方法  连接方式整理  1&amp;gt; MBeanServerFactory.createMBeanServer(); //ManagementFactory.getPlatformMBeanServer()第一次调用时会默认调用上述方法 ObjectName name = new ObjectName(&amp;quot;book.liuyang:service=Counter&amp;quot;); server.registerMBean(new Counter(), name); 注：可见Domain为JMImplementation 2&amp;gt; JMXConnectorFactory.connect( new JMXServiceURL(&amp;quot;service:jmx:rmi:///jndi/rmi://:9999/jmxrmi&amp;quot;), null ).getMBeanServerConnection() 注：可见Domain为JMImplementation,com.sun.management,Catalina,java.nio,org.apache.commons.pool2,java.lang,java.util.logging   JVM运行情况 - JMX 监控双方于同一JVM MBeanServer server = ManagementFactory.getPlatformMBeanServer(); RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(server, &amp;#34;java.lang:type=Runtime&amp;#34;, RuntimeMXBean.class);  监控双方位于不同JVM  被监控JVM补充JVM代码启动参数  -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=127.0.0.1:8000 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false  连接代理
JMXServiceURL url = new JMXServiceURL(&amp;#34;service:jmx:rmi:///jndi/rmi://127.0.0.1:8000/jmxrmi&amp;#34;); JMXConnector connector = JMXConnectorFactory.connect(url); RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(connector.getMBeanServerConnection(),&amp;#34;java.lang:type=Runtime&amp;#34;, RuntimeMXBean.class); 监控双方位于不同JVM，但处于同一物理主机(Java Instrutment&amp;amp; Attach API) 通过Attach到被监控的JVM进程，并在被监控的JVM中启动一个JMX代理，然后使用该代理通过2的方式连接到被监控的JVM的JMX上。 ``` //Attach 到5656的JVM进程上，后续Attach API再讲解 VirtualMachine virtualmachine = VirtualMachine.attach(&amp;ldquo;5656&amp;rdquo;);
  //让JVM加载jmx Agent，后续讲到Java Instrutment再讲解 String javaHome = virtualmachine.getSystemProperties().getProperty(&amp;ldquo;java.home&amp;rdquo;); String jmxAgent = javaHome &#43; File.separator &#43; &amp;ldquo;lib&amp;rdquo; &#43; File.separator &#43; &amp;ldquo;management-agent.jar&amp;rdquo;; virtualmachine.loadAgent(jmxAgent, &amp;ldquo;com.sun.management.jmxremote&amp;rdquo;);
//获得连接地址 Properties properties = virtualmachine.getAgentProperties(); String address = (String)properties.get(&amp;ldquo;com.sun.management.jmxremote.localConnectorAddress&amp;rdquo;);
//Detach virtualmachine.detach();
JMXServiceURL url = new JMXServiceURL(address); JMXConnector connector = JMXConnectorFactory.connect(url); RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(connector.getMBeanServerConnection(), &amp;ldquo;java.lang:type=Runtime&amp;rdquo;,RuntimeMXBean.class);
### [TOMCAT本地JMX监控](http://sharpspeed.iteye.com/blog/2009770) #### windows - 系统配置 - windows7 64位 - java 1.7.0_55 - tomcat 7.0.54 - 配置修改 - D:\Program Files\Apache\Tomcat\apache-tomcat-7.0.54\bin\catalina.bat - 于:doRun节点下补充 ``` set JMX_REMOTE_CONFIG=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=true -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false set CATALINA_OPTS=%CATALINA_OPTS% %JMX_REMOTE_CONFIG% 其中port为代码连接端口，与jConsole中列举的端口不一致 若需要鉴权，则请将authenticate设置为true，并调整鉴权相同配置，具体可见参考内容 ``` - 连接测试 String rmi= &amp;ldquo;service:jmx:rmi:///jndi/rmi://localhost:9999/jmxrmi&amp;rdquo;; JMXServiceURL serviceURL = new JMXServiceURL(rmi); conn = JMXConnectorFactory.connect(serviceURL); conn.getMBeanServerConnection();
#### Linux - 系统配置 - CentOS 6.5 - java 1.6.0_33 - tomcat 7.0.54Z - 配置修改（含tomcat安装） - `cd /data/test/download/targz` - `rz #上传apache-tomcat-7.0.54.tar.gz` - `tar -xzf apache-tomcat-7.0.54.tar.gz` - `cd apache-tomcat-7.0.54/bin` - `vi catalina.sh` - `/Execute The Requested Command` - 于当行后补充 ``` CATALINA_OPTS=&amp;#34;$CATALINA_OPTS -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&amp;#34; // 且注意上例代码不能折行！！ ``` - ESC - :wq - ./startup.sh - rz #上传测试执行文件jmx.jar - 连接测试： - `java -jar /data/test/download/targz/apache-tomcat-7.0.54/bin/jmx.jar` ## 多线程 ### 创建方法 - 继续Threadpublic class ExtendThread extends Thread { public void run(){System.out.println(this.getName());} } new ExtendThread().start();- 实现Runnablepublic class ImpleRunnable implements Runnable { public void run(){System.out.println(this.getName());} } new Thread(new ImpleRunnable(),&amp;#34;Thread&amp;#34;).start(); - 注意事项 - Runable非常适合多个相同线程来处理同一份资源的情况 ### 生命周期 - New新建 - 当线程被创建时，该线程处于新建状态，此时它和其他java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量的值。（此时的线程没有表现出任何表现出任何线程的动态特征，程序也不会执行线程的线程执行体） - new Thread（）||new Thread（Runnable target，String name） - Runnable就绪 - 就绪也就是说启动线程，调用start方法来启动线程，系统会将该run方法当成线程执行体来处理。如果直接调用线程对象的run方法。则run方法会立即执行，且在这个run方法的执行体未执行结束前其他线程无法并发执行（即系统会将run方法当做一个普通对象的普通方法，而不是线程执行体对待） - 附1：如果有一个主线程，一个子线程。当根据逻辑代码该调用子线程时不一定会立即调用，为了想在子线程start（）后立即调用子线程，可以考虑使用Thread.sleep（1），这样会让当前线程（主线程）睡眠1毫秒，因为cpu在这1毫秒中是不会休息的，这样就会去执行一条处于就绪状态的线程。 - 附2：不能对已经处于就绪状态的线程，再次使用start（） - Running 运行 - 当处于就绪状态时，该线程获得cpu，执行体开始运行，就处于运行状态了。 - Blocked 阻塞 - 线程不可能一直处于运行状态（线程执行体足够短，瞬间就可以完成的线程排除），线程会在运行过程中需要被中断，因为是并发，目的是会让其他线程获得执行的机会，线程的调度细节取决于OS采用的策略。（抢占式调度xp win7 linux unix..）。如果是一些特殊的小型设备可能采用协作式调度（只有线程自己调用它的sleep（）或yield（）才会放弃所占用的资源）。 - Dead死亡 - 测试某条线程是否已经死亡，可以调用线程对象的isAlive（）方法，当线程处于就绪，运行，阻塞时，返回true。线程处于新建，死亡时返回false。 - 不能对已经死亡的线程调用start（）方法使它重新启动，死亡就是死亡，是不能再次作为线程执行的。 - 当主线程结束时候，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受到主线程的影响。 ### 线程控制 #### JOIN：等待该线程结束后再往下执行 - 方法 - Join（）：等待被join的线程执行完成 - Join（long millis）:等待join线程的时间最长为millis毫秒，如果在这个时间内，被join的线程还没有执行结束则不再等待） - Join（long millis，int nanos）千分之一毫秒（不用） - 实例 JoinThread joinThread= new JoinThread(); new Thread(joinThread).start(); for(int i=0; i&amp;lt; 4; i&#43;&#43;) { Thread thread = new Thread(joinThread); thread.start(); thread.join(); //若只针对最后一个调用，则最后一个调用完成，可能其它线程还未完成也会继续往下执行而导致数据未完全 } for(int i=0; i&amp;lt; 3; i&#43;&#43;){ System.out.println(Thread.currentThread().getName() &#43; &amp;ldquo;\t&amp;rdquo; &#43; i); }
返回结果： Thread-0 0 Thread-1 0 Thread-0 1 Thread-1 1 Thread-1 2 Thread-0 2 Thread-2 0 Thread-2 1 Thread-2 2 Thread-3 0 Thread-3 1 Thread-3 2 main 0 main 1 main 2
#### 后台进程 JoinThread joinThread= new JoinThread(); Thread thread= new Thread(joinThread); thread.setDaemon(true); //必须于执行前设置。前台线程结束后，会再执行一段时间后台线程。 thread.start(); for(int i=0; i&amp;lt; 10; i&#43;&#43;){ System.out.println(Thread.currentThread().getName() &#43; &amp;ldquo;\t&amp;rdquo; &#43; i); } 返回结果： main 0 main 1 main 2 main 3 Thread-0 0 main 4 Thread-0 1 main 5 Thread-0 2 main 6 Thread-0 3 main 7 Thread-0 4 main 8 Thread-0 5 main 9 Thread-0 6 Thread-0 7 Thread-0 8 Thread-0 9 Thread-0 10 Thread-0 11 Thread-0 12 SLEEP：休眠，状态转阻塞 YIELD：线程让步，状态转就绪，让步于优先级相同或更高的线程
#### 多线程同步 - 同步代码块Synchronized(obj){ //...同步代码块 } - 同步方法 public synchronized void draw(){ &amp;hellip;}
- 锁定释放时机：1.调用执行结束 2.break或return 3.代码中出现Error或Exception 4.代码中执行监视器对象的wait进行当前线程的暂停释放 - 不释放情况：1.调用Thread.sleep/yield 2.其它线程调用该线程的suspend将之挂起（不推荐使用） - 同步锁LOCK private final ReentrantLock relock=new ReentrantLock(); //声明锁对象 public void run(){ relock.lock(); //加锁 try{
&amp;hellip; //同步执行代码 }finally{ //释放锁 relock.unlock(); } }
- 死锁 - 当两个线程相互等待对方释放同步监视器的时候就会发生死锁，一旦出现死锁，整个程序既不会发生任何异常，也不会有任何提示，只是所有线程处于阻塞状态，无法继续。 #### 线程通信 - 线程协调运行 - Object: wait()| notify()|| notifyAll() - 使用条件变量来控制协调 - Condition：await()|| signal()|| signalAll() - private final Lock lock=new ReentrantLock(); - private final Condition cond=lock.newCondition(); - 管道流通信 //1.创建管道输入输出流 PipedWriter pw = new PipedWriter(); PipedReader pr = new PipedReader(); //2.管道连接 pr.connect(pw); //3.将管理分别传入处理线程并调用实现 new Thread(new ReaderThread(pr),&amp;ldquo;读取管道线程&amp;rdquo;).start(); //pw.write(str); new Thread(new WriterThread(pw),&amp;ldquo;写入管道线程&amp;rdquo;).start(); //while ((buffer = br.readLine()) != null)
#### 线程组 - 介绍 - 对线程组的控制相当于同时控制这批线程。 - 用户创建默认属于默认线程组，如子线程和创建它的主线程同处同一线程组。 - 一旦加入指定线程组，中途不允许调整。 - Thread th=new Thread(new ThreadGroup(&amp;#34;私人&amp;#34;), new GroupThread(), &amp;#34;线程1&amp;#34;); ## 反射 ### 机制 - 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 ### 用途 - 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； - 对于任意一个对象，都能够调用它的任意一个方法； ### 实例 - 主要针对框架开发，如jsp的javabean,spring的自动注入，hibernate及struts ### 代码public class ReflectionTest { //测试变更属性，其中为了直观调用属性属性设置为public类型  public double field; public static void main(String[] args) { // printClssInfo(); // callClassMethod(); // callFieldChange();  List2Obj(); } /*** * 构造函数（无参-默认&amp;amp; 带参） */ public ReflectionTest() {} public ReflectionTest(Double field) { this.field = field; } /** * 动态获取数据对象，可将多维数组的部分结构拼成对象来调用 */ public static void List2Obj(){ int dims[] = new int[]{5, 10, 15}; Object arr = Array.newInstance(Integer.TYPE, dims); Object arrobj = Array.get(arr, 3); Class cls = arrobj.getClass().getComponentType(); System.out.println(cls.getSimpleName()); arrobj = Array.get(arrobj, 5); Array.setInt(arrobj, 10, 37); int arrcast[][][] = (int[][][]) arr; System.out.println(arrcast[3][5][10]); } /*** * 调用参数的方法进行属性更新 */ public static void callFieldChange(){ Class c = null; try { c = Class.forName(&amp;#34;com.yao.controller.reflection.ReflectionTest&amp;#34;); Field field= c.getField(&amp;#34;field&amp;#34;); ReflectionTest reflect= new ReflectionTest(12.34D); System.out.println(reflect.field); field.setDouble(reflect, 43.21); System.out.println(reflect.field); }catch (Exception e){ e.printStackTrace(); } } /*** * 专门用于提供反射调用 * @param a 加数1 * @param b 加数2 * @return a&#43;b的结果 */ public int add(int a, int b){ return a&#43; b; } /*** * 调用本方法内的ADD方法 * Constructor方式与之相似 */ public static void callClassMethod(){ Class c = null; try { c = Class.forName(&amp;#34;com.yao.controller.reflection.ReflectionTest&amp;#34;); //指定方法和参数类型以获取类中对应的方法  Class types[]= new Class[2]; types[0]= Integer.TYPE; types[1]= Integer.TYPE; Method method= c.getMethod(&amp;#34;add&amp;#34;, types); //针对各参数位填充以实际数值  Object args[]= new Object[2]; args[0]= new Integer(1); args[1]= new Integer(2); Integer retVal= (Integer)method.invoke(c.newInstance(), args); System.out.print(retVal); }catch (Exception e){ e.printStackTrace(); } } /*** * 输出String类大致文档结构 */ public static void printClssInfo(){ Class c = null; try { c = Class.forName(&amp;#34;java.lang.String&amp;#34;); System.out.println(&amp;#34;package &amp;#34; &#43; c.getPackage().getName() &#43; &amp;#34;;&amp;#34;); System.out.print(Modifier.toString(c.getModifiers()) &#43; &amp;#34; &amp;#34;); System.out.print(&amp;#34;class &amp;#34; &#43; c.getSimpleName() &#43; &amp;#34; &amp;#34;); if (c.getSuperclass() != Object.class) { System.out.print(&amp;#34;extends &amp;#34; &#43; c.getSuperclass().getSimpleName()); } Class[] inters = c.getInterfaces(); if (inters.length &amp;gt; 0) { System.out.print(&amp;#34;implements &amp;#34;); for (int i = 0; i &amp;lt; inters.length; i&#43;&#43;) { System.out.print(inters[i].getSimpleName()); if (i &amp;lt; inters.length - 1) { System.out.print(&amp;#34;,&amp;#34;); } } } System.out.println(&amp;#34;{&amp;#34;); printFields(c); printMethods(c); System.out.println(&amp;#34;}&amp;#34;); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /*** * 打印类的所有参数 * @param c */ public static void printFields(Class c) { Field[] field = c.getDeclaredFields(); if (field.length &amp;gt; 0) { for (int i = 0; i &amp;lt; field.length; i&#43;&#43;) { System.out.println(Modifier.toString(field[i].getModifiers()) &#43; &amp;#34; &amp;#34; &#43; field[i].getType().getSimpleName() &#43; &amp;#34; &amp;#34; &#43; field[i].getName() &#43; &amp;#34;;&amp;#34;); } } } /*** * 打印类的所有方法 * @param c */ public static void printMethods(Class c) { Method[] method = c.getDeclaredMethods(); if (method.length &amp;gt; 0) { for (int i = 0; i &amp;lt; method.length; i&#43;&#43;) { Class[] parameter = method[i].getParameterTypes(); System.out.print(Modifier.toString(method[i].getModifiers()) &#43; &amp;#34; &amp;#34; &#43; method[i].getReturnType().getSimpleName() &#43; &amp;#34; &amp;#34; &#43; method[i].getName() &#43; &amp;#34;(&amp;#34;); for (int j = 0; j &amp;lt; parameter.length; j&#43;&#43;) { System.out.print(parameter[j].getSimpleName() &#43; &amp;#34; args&amp;#34;); if (j != parameter.length - 1) { System.out.print(&amp;#34;,&amp;#34;); } } System.out.print(&amp;#34;) &amp;#34;); Class exception[] = method[i].getExceptionTypes(); if (exception.length &amp;gt; 0) { System.out.print(&amp;#34;throws &amp;#34;); for (int j = 0; j &amp;lt; exception.length; j&#43;&#43;) { System.out.print(exception[j].getSimpleName()); } } System.out.println(&amp;#34;{&amp;#34;); System.out.println(&amp;#34;\t... ...&amp;#34;); System.out.println(&amp;#34;}&amp;#34;); } } } }## 注解 ### 自定义注解 代码格式 @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface LoginRequired { } 框架详解 - Target - 指定该注解使用的位置 ``` public enum ElementType { TYPE, // 指定适用点为 class, interface, enum FIELD, // 指定适用点为 field METHOD, // 指定适用点为 method PARAMETER, // 指定适用点为 method 的 parameter CONSTRUCTOR, // 指定适用点为 constructor LOCAL_VARIABLE, // 指定使用点为 局部变量 ANNOTATION_TYPE, //指定适用点为 annotation 类型 PACKAGE // 指定适用点为 package } ``` - @Retention - 指定编译器处理的方式 ``` public enum RetentionPolicy { SOURCE, // 编译器处理完Annotation后不存储在class中，仅存在于源文件中 CLASS, // 编译器把Annotation存储在class中，但不能被VM读取，这是默认值 RUNTIME // 编译器把Annotation存储在class中，可以由虚拟机读取,反射需要 } ``` - @Documented - 指定允许写入javadoc - @Inherited - 允许子类继承时同时继承该注解 ``` public @interface LoginRequired { String value() default &amp;#34;login&amp;#34;; } ``` - @Constraint(指定用哪个类进行相关校验) @Constraint(validatedBy = {SafeStringValidator.class, SafeStringListValidator.class}) //注解类 public class SafeStringValidator implements ConstraintValidator{ //校验实现类 ``` - JAVA内置 - Override 只用于方法,它指明注释的方法重写父类的方法,如果不是,则编译器报错. - Deprecated 指明该方法不建议使用 - SuppressWarnings 告诉编译器:我知道我的代码没问题
</content>
    </entry>
    
     <entry>
        <title>Maven</title>
        <url>http://domain.yqjdcyy.com/post/maven/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Maven</tag>
        </tags>
        <content type="html">  部署安装 下载地址  http://maven.apache.org/download.cgi  安装流程  至下载地址下载最新版本Maven压缩包 解压至本地文件路径 补充环境变量  [M2_HOME: C:\Program Files\Apache Software Foundation\apache-maven-3.2.2] [M2: %M2_HOME%\bin] [MAVEN_OPTS: -Xms256m -Xmx512m] 并于最后于path变量里补充%M2%;  控制台输出 mvn -version，若有相关输出则表示安装成功  生命周期  内置构建：  default：处理项目部署 clean：清理项目 site：创建项目的网站文件
各生命周期执行内容： Clean Lifecycle pre-clean executes processes needed prior to the actual project cleaning
 clean remove all files generated by the previous build
 post-clean executes processes needed to finalize the project cleaning
Default Lifecycle validate validate the project is correct and all necessary information is available.
 initialize initialize build state, e.g. set properties or create directories.
 generate-sources generate any source code for inclusion in compilation.
 process-sources process the source code, for example to filter any values.
 generate-resources generate resources for inclusion in the package.
 process-resources copy and process the resources into the destination directory, ready for packaging.
 compile compile the source code of the project.
 process-classes post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.
 generate-test-sources generate any test source code for inclusion in compilation.
 process-test-sources process the test source code, for example to filter any values.
 generate-test-resources create resources for testing.
 process-test-resources copy and process the resources into the test destination directory.
 test-compile compile the test source code into the test destination directory
 process-test-classes post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above.
 test run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.
 prepare-package perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above)
 package take the compiled code and package it in its distributable format, such as a JAR.
 pre-integration-test perform actions required before integration tests are executed. This may involve things such as setting up the required environment.
 integration-test process and deploy the package if necessary into an environment where integration tests can be run.
 post-integration-test perform actions required after integration tests have been executed. This may including cleaning up the environment.
 verify run any checks to verify the package is valid and meets quality criteria.
 install install the package into the local repository, for use as a dependency in other projects locally.
 deploy done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.
Site Lifecycle pre-site executes processes needed prior to the actual project site generation
 site generates the project&amp;rsquo;s site documentation
 post-site executes processes needed to finalize the site generation, and to prepare for site deployment
 site-deploy deploys the generated site documentation to the specified web server
  调用 如调用deploy(mvn deploy)便会自动调用前面的几个流程步骤 仍可在同一指令中调用多个操作（多模块场景中会自动递归至各子模块），如 mvn clean install 相关指令  Clean Lifecycle Bindings
 clean clean:clean  Default Lifecycle Bindings - Packaging ejb / ejb3 / jar / par / rar / war
 process-resources resources:resources compile compiler:compile process-test-resources resources:testResources test-compile compiler:testCompile test surefire:test package ejb:ejb or ejb3:ejb3 or jar:jar or par:par or rar:rar or war:war install install:install deploy deploy:deploy  Default Lifecycle Bindings - Packaging ear
 generate-resources ear:generate-application-xml process-resources resources:resources package ear:ear install install:install deploy deploy:deploy  Default Lifecycle Bindings - Packaging maven-plugin
 generate-resources plugin:descriptor process-resources resources:resources compile compiler:compile process-test-resources resources:testResources test-compile compiler:testCompile test surefire:test package jar:jar and plugin:addPluginArtifactMetadata install install:install deploy deploy:deploy  Default Lifecycle Bindings - Packaging pom
 package site:attach-descriptor install install:install deploy deploy:deploy  Site Lifecycle Bindings
 site site:site site-deploy site:deploy   初始化 POM文件中补充节点，默认值为jar，可选值为jar/war/ear/pom jar方式流程  process-resources resources:resources compile compiler:compile process-test-resources resources:testResources test-compile compiler:testCompile test surefire:test package jar:jar install install:install deploy deploy:deploy
使用Plugins来实现各环节的操作步骤，其中若同一环节有多个插件支持，则以POM文件顺序下的第一个进行处理 &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-checkstyle-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${plugin.checkstyle.version}&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;configLocation&amp;gt;${project.basedir}/build/check-style.xml&amp;lt;/configLocation&amp;gt; &amp;lt;includeTestSourceDirectory&amp;gt;false&amp;lt;/includeTestSourceDirectory&amp;gt; &amp;lt;consoleOutput&amp;gt;true&amp;lt;/consoleOutput&amp;gt; &amp;lt;failsOnError&amp;gt;true&amp;lt;/failsOnError&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;phase&amp;gt;verify&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt;  POM.XML详解 作用  描述项目如下内容：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。
结构 &amp;lt;project&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;!-- 基础设置 --&amp;gt; &amp;lt;groupId&amp;gt;项目或者组织的唯一标志，也将会是配置生成路径&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;项目名称&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;版本&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;打包机制，支持pom,jar,maven-plugin,ejb,war,ear,rar,par&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;用户描述项目名称，可选&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;开发团队网站，可选&amp;lt;/url&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- 依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;默认 jar，常用类型有 jar,ejb-client,test-jar&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt; compile 缺省值，适用于所有阶段，会随着项目一起发布。 provided 类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 runtime 只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test 只在测试时使用，用于编译和运行测试代码。不会随项目发布。 system 类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 &amp;lt;/scope&amp;gt; &amp;lt;optional&amp;gt; 默认为 false，即子项目默认继承。为 true时则子项目必须显示引入。 &amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.china.shared&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;alibaba.apollo.webx&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.0&amp;lt;/version&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;!-- 移除指定依赖 --&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.external&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;org.slf4j.slf4j-api&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; .... &amp;lt;/exclusions&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;!-- 工程为 parent 时，packing 参数值需为 pom，则子项目可继承 dependencies,developers,contributors,plugin lists,reports lists,plugin execution with matching ids,plugin configuration --&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;my-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt; &amp;lt;relativePath&amp;gt;../my-parent&amp;lt;/relativePath&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt; 用于帮助管理子项目的依赖，子项目的相关引用 version 将由父项目进行设置 &amp;lt;/dependencyManagement&amp;gt; &amp;lt;modules&amp;gt; 与顺序无关，maven 会自动根据依赖关系拓扑排序 &amp;lt;/modules&amp;gt; &amp;lt;!-- 配置常量，并于 pom 其它地方以 ${file.encoding} 形式调用 --&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;file.encoding&amp;gt;UTF-8&amp;lt;/file_encoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;!--构建设置 --&amp;gt; &amp;lt;build&amp;gt;...&amp;lt;/build&amp;gt; &amp;lt;reporting&amp;gt;...&amp;lt;/reporting&amp;gt; &amp;lt;!-- 更多项目信息 --&amp;gt; &amp;lt;description&amp;gt;...&amp;lt;/description&amp;gt; &amp;lt;inceptionYear&amp;gt;...&amp;lt;/inceptionYear&amp;gt; &amp;lt;licenses&amp;gt;...&amp;lt;/licenses&amp;gt; &amp;lt;organization&amp;gt;...&amp;lt;/organization&amp;gt; &amp;lt;developers&amp;gt;...&amp;lt;/developers&amp;gt; &amp;lt;contributors&amp;gt;...&amp;lt;/contributors&amp;gt; &amp;lt;!-- 环境设置--&amp;gt; &amp;lt;issueManagement&amp;gt;...&amp;lt;/issueManagement&amp;gt; &amp;lt;ciManagement&amp;gt;...&amp;lt;/ciManagement&amp;gt; &amp;lt;mailingLists&amp;gt;...&amp;lt;/mailingLists&amp;gt; &amp;lt;scm&amp;gt;...&amp;lt;/scm&amp;gt; &amp;lt;prerequisites&amp;gt;...&amp;lt;/prerequisites&amp;gt; &amp;lt;repositories&amp;gt;...&amp;lt;/repositories&amp;gt; &amp;lt;pluginRepositories&amp;gt;...&amp;lt;/pluginRepositories&amp;gt; &amp;lt;distributionManagement&amp;gt;...&amp;lt;/distributionManagement&amp;gt; &amp;lt;profiles&amp;gt;...&amp;lt;/profiles&amp;gt; &amp;lt;/project&amp;gt;  示例 外部 Jar 引入本地项目System  相对引用  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.aliyun&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aliyun-java-sdk-dysmsapi&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;system&amp;lt;/scope&amp;gt; &amp;lt;systemPath&amp;gt;${basedir}/src/main/lib/aliyun-java-sdk-dysmsapi-1.0.0.jar&amp;lt;/systemPath&amp;gt; &amp;lt;/dependency&amp;gt;  打包时包括在内  &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;copy-dependencies&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;compile&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;copy-dependencies&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;outputDirectory&amp;gt;${project.build.directory}/${project.build.finalName}/WEB-INF/lib&amp;lt;/outputDirectory&amp;gt; &amp;lt;includeScope&amp;gt;system&amp;lt;/includeScope&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt;   </content>
    </entry>
    
     <entry>
        <title>DWR</title>
        <url>http://domain.yqjdcyy.com/post/dwr/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>DWR</tag>
        </tags>
        <content type="html">  参考  在 Spring Web MVC 环境下使用 DWR  作用  Spring 框架提供，可将 Java 组件方法直接暴露给 JavaScript 客户端 通过将 Spring 容易中的 Bean 转换为 JavaScript 对象  配置 web.xml &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;springServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/dwr/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; springmvc.xml &amp;lt;!-- DWR3.0配置 --&amp;gt; &amp;lt;!-- 打开dwr的控制器 --&amp;gt; &amp;lt;dwr:controller id=&amp;#34;dwrController&amp;#34; debug=&amp;#34;true&amp;#34; &amp;gt; &amp;lt;dwr:config-param name=&amp;#34;allowScriptTagRemoting&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;dwr:config-param name=&amp;#34;crossDomainSessionSecurity&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;dwr:config-param name=&amp;#34;activeReverseAjaxEnabled&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;/dwr:controller&amp;gt; &amp;lt;dwr:url-mapping/&amp;gt; &amp;lt;bean class=&amp;#34;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;alwaysUseFullPath&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;mappings&amp;#34;&amp;gt; &amp;lt;props&amp;gt; &amp;lt;prop key=&amp;#34;/dwr/**/*&amp;#34;&amp;gt;dwrController&amp;lt;/prop&amp;gt; &amp;lt;/props&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!-- 使用 dwr的 annotation --&amp;gt; &amp;lt;!-- 要求dwr在spring容器中检查拥有@RemoteProxy 和 @RemoteMethod注解的类。注意它不会去检查Spring容器之外的类。 --&amp;gt; &amp;lt;dwr:annotation-config id=&amp;#34;dwrAnnotationConfig&amp;#34; /&amp;gt; &amp;lt;dwr:annotation-scan base-package=&amp;#34;com.syncsoft.ywgl.xmgl.dtmszckz.web&amp;#34; scanDataTransferObject=&amp;#34;true&amp;#34; scanRemoteProxy=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;dwr:annotation-scan base-package=&amp;#34;com.syncsoft.dwr&amp;#34; scanDataTransferObject=&amp;#34;true&amp;#34; scanRemoteProxy=&amp;#34;true&amp;#34; /&amp;gt; java-code @RemoteProxy(creator=SpringCreator.class,name=&amp;#34;DtmszckzPusher&amp;#34;) //推送给谁，推送了什么内容 public class DtmszckzPusher { @RemoteMethod public void setContrlAction(String jmr_id,String contrlAction) { SessionInfo sessionInfo = (SessionInfo) SecurityUtils.getSubject().getSession().getAttribute(Constants.USER_INFO_SESSION); final String userId = sessionInfo.getUserId(); final String action = contrlAction; Browser.withAllSessionsFiltered( new ScriptSessionFilter() { public boolean match(ScriptSession scriptSession) { //返回true的情况下才可以接收到推送信息 System.out.println(&amp;#34;scriptSession in DtmszckzPusher:&amp;#34;&#43;scriptSession.getId()); if (scriptSession.getAttribute(&amp;#34;userId&amp;#34;) == null){ return false; }else{ return (scriptSession.getAttribute(&amp;#34;userId&amp;#34;)).equals(userId); } } }, new Runnable() { private ScriptBuffer script = new ScriptBuffer(); public void run() { script.appendCall(&amp;#34;showMessage&amp;#34;, action); //showMessage为前台调用方法 Collection&amp;lt;ScriptSession&amp;gt; sessions = Browser.getTargetSessions(); for (ScriptSession scriptSession : sessions) { scriptSession.addScript(script); } } } ); } } @RemoteProxy(creator=SpringCreator.class,name=&amp;#34;DtmsjmrdPusher&amp;#34;) //注册，申请推送 public class DtmsjmrdPusher { public static final String SS_ID=&amp;#34;DWR_ScriptSession_Id&amp;#34;; @RemoteMethod public void clientOnPageLoad(String userId) { SessionInfo sessionInfo = (SessionInfo) SecurityUtils.getSubject().getSession().getAttribute(Constants.USER_INFO_SESSION); userId = sessionInfo.getUserId(); ScriptSession scriptSession = WebContextFactory.get().getScriptSession(); scriptSession.setAttribute(&amp;#34;userId&amp;#34;, userId); DwrScriptSessionManagerUtil du = new DwrScriptSessionManagerUtil(); try { ScriptSessionListener li = du.init(); du.addScriptSessionListener(li); } catch (ServletException e) { e.printStackTrace(); } } } html -- import js package &amp;lt;script type=&amp;#39;text/javascript&amp;#39; src=&amp;#39;&amp;lt;%=request.getContextPath() %&amp;gt;/dwr/engine.js&amp;#39;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#39;text/javascript&amp;#39; src=&amp;#39;&amp;lt;%=request.getContextPath() %&amp;gt;/dwr/util.js&amp;#39;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#39;text/javascript&amp;#39; src=&amp;#39;&amp;lt;%=request.getContextPath() %&amp;gt;/dwr/interface/DtmszckzPusher.js&amp;#39;&amp;gt;&amp;lt;/script&amp;gt; ///dwr/interface为固定写法，DtmszckzPusher则为推送的Java类，.js也是固定写法 -- sender function Button_onClick(action){ var jmr_id = $(&amp;#34;#userId&amp;#34;).val(); DtmszckzPusher.setContrlAction(jmr_id,action); } -- receiver 初始化（通知服务器你准备好，并为你创建登陆记录） onload=&amp;#34;onLoadPage();dwr.engine.setActiveReverseAjax(true);dwr.engine.setNotifyServerOnPageUnload(true,true);&amp;#34; function onLoadPage(){ var userId = &amp;#39;&amp;lt;%= sessionId %&amp;gt;&amp;#39;; DtmsjmrdPusher.clientOnPageLoad(userId, showMessage); } -- receiver-callback function showMessage(action){ alert(action); }</content>
    </entry>
    
     <entry>
        <title>Regex</title>
        <url>http://domain.yqjdcyy.com/post/regex/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Regex</tag>
        </tags>
        <content type="html">  元字符  . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束  字符转义  想查找元字符本身的话，使用\来取消这些字符的特殊意义  重复  * 重复零次或更多次 &#43; 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次  字符类  [aeiou] 就匹配任何一个英文元音字母 [.?!] 匹配标点符号(.或?或!) [a-z0-9A-Z_]  分枝条件  \d{5}-\d{4}|\d{5} 5-4或5位数值  分组  以小括号指定的即为分组 ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)  反义  \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符  零宽断言  查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言  (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w&#43;(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&amp;rsquo;m singing while you&amp;rsquo;re dancing.时，它会匹配sing和danc。 (?&amp;lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&amp;lt;=\bre)\w&#43;\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。   负向零宽断言  零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)&#43;\b匹配不包含连续字符串abc的单词。 &#43;(?&amp;lt;=&amp;lt;(\w&#43;)&amp;gt;).*(?=&amp;lt;\/\1&amp;gt;)匹配不包含属性的简单HTML标签内里的内容。(?&amp;lt;=&amp;lt;(\w&#43;)&amp;gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是)，然后是.*(任意的字符串),最后是一个后缀(?=&amp;lt;\/\1&amp;gt;)。 * 注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w&#43;)匹配的内容，这样如果前缀实际上是&amp;lt;b&amp;gt;的话，后缀就是&amp;lt;/b&amp;gt;了。整个表达式匹配的是&amp;lt;b&amp;gt;和&amp;lt;/b&amp;gt;之间的内容(再次提醒，不包括前缀和后缀本身)。  注释  通过语法(?#comment)来包含注释 2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)  贪婪与懒惰  贪婪：匹配尽可能多的字符，如a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。 懒惰：匹配尽可能少的字符，a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。  其中懒惰例子中第一个不是ab是由于最先开始匹配的拥有最高的优先权   处理选项  IgnoreCase(忽略大小写) 匹配时不区分大小写。 Multiline(多行模式) 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) Singleline(单行模式) 更改.的含义，使它与每一个字符匹配（包括换行符\n）。 IgnorePatternWhitespace(忽略空白) 忽略表达式中的非转义空白并启用由#标记的注释。 ExplicitCapture(显式捕获) 仅捕获已被显式命名的组。  平衡组/递归匹配 概念：  (?&#39;group&#39;) 把捕获的内容命名为group,并压入堆栈(Stack) (?&#39;-group&#39;) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败  事例： &amp;lt; #最外层的左括号 [^&amp;lt;&amp;gt;]* #最外层的左括号后面的不是括号的内容 ( ( (?&amp;#39;Open&amp;#39;&amp;lt;) #碰到了左括号，在黑板上写一个&amp;#34;Open&amp;#34; [^&amp;lt;&amp;gt;]* #匹配左括号后面的不是括号的内容 )&#43; ( (?&amp;#39;-Open&amp;#39;&amp;gt;) #碰到了右括号，擦掉一个&amp;#34;Open&amp;#34; [^&amp;lt;&amp;gt;]* #匹配右括号后面不是括号的内容 )&#43; )* (?(Open)(?!)) #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&amp;#34;Open&amp;#34;；如果还有，则匹配失败 &amp;gt; #最外层的右括号 补充语法  \a 报警字符(打印它的效果是电脑嘀一声) \b 通常是单词分界位置，但如果在字符类里使用代表退格 \t 制表符，Tab \r 回车 \v 竖向制表符 \f 换页符 \n 换行符 \e Escape \0nn ASCII代码中八进制代码为nn的字符 \xnn ASCII代码中十六进制代码为nn的字符 \unnnn Unicode代码中十六进制代码为nnnn的字符 \cN ASCII控制字符。比如\cC代表Ctrl&#43;C \A 字符串开头(类似^，但不受处理多行选项的影响) \Z 字符串结尾或行尾(不受处理多行选项的影响) \z 字符串结尾(类似$，但不受处理多行选项的影响) \G 当前搜索的开头 \p{name} Unicode中命名为name的字符类，例如\p{IsGreek} (?&amp;gt;exp) 贪婪子表达式 (?&amp;lt;x&amp;gt;-&amp;lt;y&amp;gt;exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes|no) 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否`则使用no (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes|no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no  </content>
    </entry>
    
     <entry>
        <title>Spring.Cache</title>
        <url>http://domain.yqjdcyy.com/post/spring.cache/</url>
        <categories>
          <category>整理</category>
        </categories>
        <tags>
          <tag>Spring</tag><tag>Cache</tag>
        </tags>
        <content type="html">  参考链接  http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-cache/  特点  通过少量的配置 annotation 注释即可使得既有代码支持缓存 支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存 支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition 支持 AspectJ，并通过其实现任何方法的缓存支持 支持自定义 key和自定义缓存管理者，具有相当的灵活性和扩展  注释标签  @Cacheable(value=&amp;ldquo;缓存名称，如a/{b, c}&amp;rdquo;[, key=&amp;ldquo;可使用SqEL获取方法参数如#userName，其中缺少按照方法所有参数进行组合&amp;rdquo;] [, condition=&amp;ldquo;可使用SqEL表达式编写，为true时进行缓存&amp;rdquo;]) @CachEvict(value=&amp;ldquo;缓存名称，如a/{b, c}&amp;rdquo; [, key=&amp;ldquo;可使用SqEL获取方法参数如#userName，其中缺少按照方法所有参数进行组合&amp;rdquo;] [, condition=&amp;ldquo;可使用SqEL表达式编写，为true时进行缓存&amp;rdquo;] [, allEntries=&amp;ldquo;true时表示清空所有缓存内容&amp;rdquo;] [, beforeInvocation=&amp;ldquo;true时表示在方法执行前清空&amp;rdquo;]) @CachePut调用方式同@Cacheable，区别于每次都会触发真实方法调用  基本原理  关键：Spring AOP 过程：  原始代码：客户端通过直接作用于类对象的方法进行直接引用 调整实现：客户端申请调用时，所拥有的为代码的引用。proxy控制实际pojo.foo()方法的入参和返回值    </content>
    </entry>
    
     <entry>
        <title></title>
        <url>http://domain.yqjdcyy.com/post/ducati/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  历史 车型 Diavel  配置
   配置项 配置明细     引擎 Testastretta 11° 双火花塞引擎   马力 162 马力   扭力 96lb-ft   整车保养 整车 15,000公里/年
气门间隙检查 30,000 公里/年   排气系统 58 毫米口径的排气管结合 2-1-2 排放系统    推荐价
 20.5 万  欣赏
 []()
   </content>
    </entry>
    
     <entry>
        <title></title>
        <url>http://domain.yqjdcyy.com/post/hello.spring.boot.security/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Introduction providing both authentication and authorization to Java applications.
a comprehensive security solution for Java EE-based enterprise software applications
layers of security
each layer tries to be as secure as possible in its own right
authentication 鉴定 the process of establishing a principal is who they claim to be authorization 授权 the process of deciding whether a principal is allowed to perform an action within your application
FAQ Architecture Code 2.4 Getting Spring Security
2.4.3 Project Modules
 Java Configuration  OAuth2 实现 Authentication-Memory Maven  pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-web&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-config&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  Code  Application
@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } SecurityConfig
@EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { private static final String ROLE_USER = &amp;#34;USER&amp;#34;; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // 配置 /resource 开头的请求无需验证即可访问  .antMatchers(&amp;#34;/resource/**&amp;#34;).permitAll() // 配置 /user 开头的请求均需验证才能访问  .antMatchers(&amp;#34;/user/**&amp;#34;).hasRole(ROLE_USER) // 登录模式为跳转至内置的登录界面  .and().formLogin(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // 内存模式存储验证信息  auth.inMemoryAuthentication() // 指定密码编码器，否则 v5.0 以上版本会提示 `There is no PasswordEncoder mapped for the id &amp;#34;null&amp;#34;`  .passwordEncoder(new BCryptPasswordEncoder()) // 配置内置用户 yao 以 USER 角色  .withUser(User.withUsername(&amp;#34;yao&amp;#34;).password(new BCryptPasswordEncoder().encode(&amp;#34;lu&amp;#34;)).roles(ROLE_USER)); } }  Invoke  /recourse  200  /user  跳转至内置登录界面 /login   Upgrade  验证方式自定义 验证持久化 用户数据源配置  Authorization-Jdbc Maven  pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Security.* --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-web&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-config&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- H2.* --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.197&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- JPA.* --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  Properties  application.yml
spring: datasource: url: jdbc:h2:mem:h2test;DB_CLOSE_DELAY=-1 platform: h2 driver-class-name: org.h2.Driver username: sa password: schema: classpath:h2/schema.sql data: classpath:h2/data.sql h2: console: settings: web-allow-others: true path: /h2-console enabled: true jpa: database: h2 database-platform: org.hibernate.dialect.H2Dialect show-sql: true # 无法正常请求数据时添加该行 hibernate: ddl-auto: update  h2/schema.sql
create table users(id bigint auto_increment, username varchar(255), password varchar(255), enabled boolean); create table authorities(id bigint auto_increment, username varchar(255),authority varchar(255), UNIQUE(username,authority)); h2/data.sql
insert into users(username,password,enabled) values( &amp;#39;admin&amp;#39;, &amp;#39;$2a$10$BrpHlhYyofs0RSA72JXHxucWRSlHhqyPSdsfqqyY1DSUq5vEWDOH.&amp;#39;, true); insert into users(username,password,enabled) values( &amp;#39;user&amp;#39;, &amp;#39;$2a$10$wBkWTgqlprm1xJCroQo80..KVo.X.gJEgifddua6BSopY7RHVcB0i&amp;#39;, true); insert into authorities (username,authority) values(&amp;#39;admin&amp;#39;,&amp;#39;ROLE_ADMIN&amp;#39;); insert into authorities (username,authority) values(&amp;#39;user&amp;#39;,&amp;#39;ROLE_USER&amp;#39;);  Code  SecurityConfig
@EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { private static final String ROLE_ADMIN = &amp;#34;ADMIN&amp;#34;; private static final String ROLE_USER = &amp;#34;USER&amp;#34;; @Autowired DataSource dataSource; @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // 设置权限为 USER，在内部会自动加上 ROLE_ 前缀，所以数据配置权限时应该为 ROLE_USER  .antMatchers(&amp;#34;/user/role/user&amp;#34;).hasAnyRole(ROLE_ADMIN, ROLE_USER) // ADMIN 或 USER 均可  .antMatchers(&amp;#34;/user/role/admin&amp;#34;).hasAnyRole(ROLE_ADMIN) // 仅 ADMIN 可访问  .antMatchers(&amp;#34;/user/role/all&amp;#34;).authenticated() // 登录用户均可访问  .anyRequest().permitAll() // 所有用户均可  .and().formLogin(); // H2 正常连接  http.authorizeRequests().antMatchers(&amp;#34;/h2-console/**&amp;#34;).permitAll(); http.csrf().ignoringAntMatchers(&amp;#34;/h2-console/**&amp;#34;); http.headers().frameOptions().sameOrigin(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // auth.jdbc  auth.jdbcAuthentication() // 指定加密方式  .passwordEncoder(new BCryptPasswordEncoder()) .dataSource(dataSource) .usersByUsernameQuery(&amp;#34;select username,password,enabled from users where username= ?&amp;#34;) .authoritiesByUsernameQuery(&amp;#34;select username,authority from authorities where username= ?&amp;#34;) ; } } H2DataSourceConfig
@Configuration public class H2DataSourceConfig { @Value(&amp;#34;${spring.datasource.url:}&amp;#34;) private String sourceUrl; @Value(&amp;#34;${spring.datasource.username:}&amp;#34;) private String sourceUsername; @Value(&amp;#34;${spring.datasource.password:}&amp;#34;) private String sourcePassword; // 注册 H2 数据库连接，供配置验证时访问  @Bean public DataSource initH2DataSource() { JdbcDataSource dataSource = new JdbcDataSource(); dataSource.setURL(sourceUrl); dataSource.setUser(sourceUsername); dataSource.setPassword(sourcePassword); return dataSource; } } Invoke     Interface Anonymous User Admin     /user/role/admin HTTP.403 HTTP.403 HTTP.200   /user/role/user HTTP.403 HTTP.200 HTTP.200   /user/role/all HTTP.200 HTTP.200 HTTP.200    Authorization-Custom Authorization-Keep 异常 org.h2.jdbcx.JdbcDataSource 未找到 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.197&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 将 scope 移除，或手动更新为默认的 compile No suitable driver found for 断点发现读取获取文件均为空 将 target 删除，重新运行即可
HasAnyRole 无法正常过滤，返回403 http.authorizeRequests().antMatchers(&amp;#34;/user/role/user&amp;#34;).hasAnyRole(ROLE_ADMIN, ROLE_USER) insert into authorities (username,authority) values(&amp;#39;admin&amp;#39;,&amp;#39;ROLE_ADMIN&amp;#39;); ExpressionUrlAuthorizationConfigurer.java private static String hasAnyRole(String... authorities) { String anyAuthorities = StringUtils.arrayToDelimitedString(authorities, &amp;#34;&amp;#39;,&amp;#39;ROLE_&amp;#34;); return &amp;#34;hasAnyRole(&amp;#39;ROLE_&amp;#34; &#43; anyAuthorities &#43; &amp;#34;&amp;#39;)&amp;#34;; } OAuth2 实现 配置资源服务器 配置认证服务器 配置spring security
OAuth2 模式 授权码模式 - authorization code 简化模式 - implicit 密码模式 - resource owner password credentials 客户端模式 - client credentials
名词解析  CSRF  Cross Site Request Forgery 跨站请求伪造  挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法   CORS
 Cross-Origin Resource Sharing 跨域资源共享  允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制   LDAP
 Lightweight Directory Access Protocol 轻量目录访问协议
 在公司计算机上登录一次，便可以自动在公司内部网上登录 在多个服务中使用同一个密码
参考 官方   Spring Security Reference - 5.0.5
 Spring Security
 Spring Security Reference - 5.1.2
 /spring-session/docs
 H2.Features
 []()
  补充  理解OAuth 2.0 spring boot集成h2指南 Spring Data JPA(二)：SpringBoot集成H2 []() []()  异常  There is no PasswordEncoder mapped for the id &amp;ldquo;null&amp;rdquo; Why I can&amp;rsquo;t get the org.h2.Driver? I use maven  将 H2.scope 由 test 更新为 runtime  springboot配置内存数据库H2  数据插入，但无法正常查询  H2 Database Console  H2.Console 连接 403  H2 in-memory database. Table not found JdbcDaoImpl  sql.init  []() []()  代码  4. Samples and Guides  Hello Spring Security Hello Spring Security Boot Hello Spring Security XML Hello Spring MVC Security Custom Login Form OAuth 2.0 Login  []() []() []() []()  </content>
    </entry>
    
     <entry>
        <title></title>
        <url>http://domain.yqjdcyy.com/post/hello.spring.cloud.security/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  细节 client模式，没有用户的概念，直接与认证服务器交互，用配置中的客户端信息去申请accessToken，客户端有自己的client_id,client_secret对应于用户的username,password，而客户端也拥有自己的authorities，当采取client模式认证时，对应的权限也就是客户端自己的authorities。 password模式，自己本身有一套用户体系，在认证时需要带上自己的用户名和密码，以及客户端的client_id,client_secret。此时，accessToken所包含的权限是用户本身的权限，而不是客户端的权限。
异常 InsufficientAuthenticationException: User must be authenticated with Spring Security before authorization can be completed. </content>
    </entry>
    
     <entry>
        <title></title>
        <url>http://domain.yqjdcyy.com/post/hello.docker.data/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  Reference  []() []()  </content>
    </entry>
    
     <entry>
        <title></title>
        <url>http://domain.yqjdcyy.com/post/pyqt/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  [TOC]
参考 安装  PyQt PyQt4 Download How to install PyQt4 on Windows using pip? Python3 PyQt5 pycharm 环境搭建
文档 PyQt4
 PyQt5
 PyQt5学习与交流
  </content>
    </entry>
    
     <entry>
        <title></title>
        <url>http://domain.yqjdcyy.com/post/servlet.work/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  整体  Tomcat 容器模型     Tomcat.start() Tomcat.getServer() Tomcat.server = new StandardServer() StandardServer.globalNamingResources= new NamingResourcesImpl(); if(isUseNaming()) StandardServer.namingContextListener = new NamingContextListener(); Tomcat.getConnecotr() Tomcat.server.start()
细节 Servlet 作用 Filter Listener ServletContext 启动  程序容器启动
 Tomcat Jetty  应用部署
 应用加载
 ServletContext 创建 应用加载  web.xml 解析 &amp;lt;servlet&amp;gt;/ &amp;lt;filter&amp;gt;/ &amp;lt;listener&amp;gt; 实例化  在服务器内存中进行 实例化过滤器时，将由容器的一个新 FilterConfig 来调用应用的 init()     关闭  程序容器关闭  应用卸载  servlet|filter destroy() ServletContext/ Servlet/ Filter/ Listener 废弃    配置 load-on-startup  当 &amp;lt;servlet&amp;gt;&amp;lt;load-on-startup&amp;gt; &amp;gt; 0，Servlet.init() 方法将于启动时使用一个新的 ServletConfig 来调用  参数值代表序列值  比如 1 表示第一个被实例化 如若数值相同，则按 web.xml 出现的顺序进行加载  而若 load-on-startup 未配置，则将于第一次 HTTP 请求命中时，调用 init() 方法   HttpServlet(Request|Response)  Servlet 容器监听于指定端口的 HTTP 请求命中时，调用 客户端发起 HTTP 请求  Servlet 容器创建 HttpServletRequest 和 HttpServletResponse 对象 将对象传递给 Filter 链路  过滤器未拦截，则通过调用 chain.doFilter(request, response) 继续执行  最后传递给 Servlet 实例  调用 Servlet.service() 方法  通过 request.getMethod() 将请求分发给指定的 doXxx() 方法  传递的内容包含 HTTP.Request/ HTTP.Header/ HTTP.Body HttpServletResponse 可设置 HTTP.Header/ HTTP.Body 请求完成后，HttpServletRequest 和 HttpServletResponse 对象均将被回收再利用  如若特地方法不支持，则返回 405 Method not allowed 异常     HttpSession  客户端首次访问应用
 通过 request.getSession() 创建获取 HttpSession  生成长且唯一的 Session.Id，并存储于服务器内存中  返回时将 Session 一并返回  通过 HTTP.Set-Cookie 将 session.id 作为 JSESSIONID 返回 服务端将读取 cookie.JSESSIONID 值并匹配内存中的 HttpSession   客户端再次请求
 只要 cookie 仍有效，就将其通过 Http.Header.Cookie 带回  服务器留存
 HttpSession 将于未使用情况下， web.xml &amp;lt;session-timeout&amp;gt; 分钟后销毁  默认的 session.timeout 为 30 分钟  而在 HttpSession 过期后，客户端重新访问，将会生成以新的 HttpSession  客户端留存
 在浏览器实例运行其中，session.cookie 将始终保留   生命周期 ServletContext  同容器一并销毁 于所有请求、会话中共享  HttpSession  HttpSession 于客户端交互期间存在 服务端的会话不存在过期 于同一会话的所有请求中共享  HttpServlet(Request|Response)  于请求的发起时创建，于响应完成时销毁 不共享  Servlet/ Servlet/ Servlet  同容器一并销毁 于所有的请求、会话中共享  Attribute  于 ServletContext/ HttpServletRequest/ HttpSession 中创建的属性，于所属容器管理  类似于对象管理框架中的对象，如 JSF、CDI、Spring 等   线程安全  Servlet 和 Filter 于所有请求中共享  通过多线程、不同进程在同一实例中进行支持  实例的重新  切匆将请求或会话域数据作为 Servlet 或过滤器的实例变量  于所有请求、会话中共享，导致非线程安全    参考  How do servlets work? Servlet 工作原理解析 Spring Boot Servlet Java Servlet 技术简介 []() []() []() []()  </content>
    </entry>
    
     <entry>
        <title></title>
        <url>http://domain.yqjdcyy.com/post/%E6%9C%BA%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html">  概念  机器学习  机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。 因为学习算法中涉及了大量的统计学理论，机器学习与统计推断学联系尤为密切，也被称为统计学习理论。 算法设计方面，机器学习理论关注可以实现的，行之有效的学习算法。 赋予计算机在非编程情况下的学习能力 - Artuur Samuel  深度学习 卷积神经网络  基础  计算机科学的基本知识、原理  数据结构 编程  Matlab Octave   概率  随机变量 期望 方差  线性代数  矩阵 向量 逆矩阵   要点  decision trees  决策树  naive Bayes&amp;rsquo; classifiers  朴素贝叶斯分类器  maximum entropy classifiers
 最大熵分类器
学习路线   参考  入门  Best Machine Learning Resources for Getting Started  机器学习的最佳入门学习资源  tornadomeet.机器学习 机器学习该怎么入门？  入门补充  A Tour of Machine Learning Algorithms The Missing Roadmap to Self-Study Machine Learning 莫烦Python.有趣的机器学习 Andrew Ng Machine Learning UFLDL Tutorial icrtiou/Coursera-ML-AndrewNg  推荐
 metacademy  TensorFlow
 TensorFlow tensorflow/models tensorflow笔记：流程，概念和简单代码注释 莫烦Python.TensorFlow []()  Mahout
 Mahout []()  使用
 Natural Language Processing with Python  6. Learning to Classify Text  Pragmatic Perspectives THE MAP OF MACHINE LEARNING []() []() []() []()   </content>
    </entry>
    
     <entry>
        <title>Posts</title>
        <url>http://domain.yqjdcyy.com/post/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
</search>