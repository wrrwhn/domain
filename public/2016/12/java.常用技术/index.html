

  
    
  


  





  

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.30.2 with theme Tranquilpeak 0.4.3-BETA">
    <title>Java.常用技术</title>
    <meta name="author" content="姚清居到此一游">
    <meta name="keywords" content=", 姚清居">

    <link rel="icon" href="logo.png">
    

    
    <meta name="description" content="参考  http://unmi.cc/jdk-5-concurrent-callable-futuretask-etc/ http://www.cnblogs.com/wn398/archive/2013/06/15/3130967.html http://ifeve.com/locks/  获取路径 ###分类： - 绝对路径：主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 - 例：C:xyz est.txt 代表了test.txt文件的绝对路径 - 相对路径：相对与某个基准目录（一般对照WEB）的路径。 - 例：&rdquo;/&ldquo;代表Web应用的跟目录， &ldquo;./&rdquo; 代表当前目录,&ldquo;../&ldquo;代表上级目录 - 注：JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的
获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&ldquo;？&rdquo;) &ndash;&gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&rdquo;\&ldquo;) //站点绝对路径 application.getRealPath(&ldquo;&rdquo;) //JSP界面使用 ServletContext().getRealPath(&ldquo;&rdquo;)  返回字串  C:\Apache\Tomcat\webapps\local&#43; （\ . 空格 \web.xml）   工程Classes下路径（SRC/CLASS）  使用环境  SERVLET/JSP/JAVA（即任意CLASS）  使用语句  this.getClass()/JdomParse.class .getClassLoader().getResource(&ldquo;&rdquo;).getPath(); //注：因为三者均为JAVA程序，都为CLASS，故为三者通用方法 this.getClass()JdomParse.class .getResource(&ldquo;&rdquo;).getPath().toString(); //可用于不同WEB环境来确认路径 Thread.currentThread().getContextClassLoader().getResource(&ldquo;&rdquo;).getPath()  返回字串">
    <meta property="og:description" content="参考  http://unmi.cc/jdk-5-concurrent-callable-futuretask-etc/ http://www.cnblogs.com/wn398/archive/2013/06/15/3130967.html http://ifeve.com/locks/  获取路径 ###分类： - 绝对路径：主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 - 例：C:xyz est.txt 代表了test.txt文件的绝对路径 - 相对路径：相对与某个基准目录（一般对照WEB）的路径。 - 例：&rdquo;/&ldquo;代表Web应用的跟目录， &ldquo;./&rdquo; 代表当前目录,&ldquo;../&ldquo;代表上级目录 - 注：JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的
获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&ldquo;？&rdquo;) &ndash;&gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&rdquo;\&ldquo;) //站点绝对路径 application.getRealPath(&ldquo;&rdquo;) //JSP界面使用 ServletContext().getRealPath(&ldquo;&rdquo;)  返回字串  C:\Apache\Tomcat\webapps\local&#43; （\ . 空格 \web.xml）   工程Classes下路径（SRC/CLASS）  使用环境  SERVLET/JSP/JAVA（即任意CLASS）  使用语句  this.getClass()/JdomParse.class .getClassLoader().getResource(&ldquo;&rdquo;).getPath(); //注：因为三者均为JAVA程序，都为CLASS，故为三者通用方法 this.getClass()JdomParse.class .getResource(&ldquo;&rdquo;).getPath().toString(); //可用于不同WEB环境来确认路径 Thread.currentThread().getContextClassLoader().getResource(&ldquo;&rdquo;).getPath()  返回字串">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Java.常用技术">
    <meta property="og:url" content="/2016/12/java.%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/">
    <meta property="og:site_name" content="姚清居到此一游">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="姚清居到此一游">
    <meta name="twitter:description" content="参考  http://unmi.cc/jdk-5-concurrent-callable-futuretask-etc/ http://www.cnblogs.com/wn398/archive/2013/06/15/3130967.html http://ifeve.com/locks/  获取路径 ###分类： - 绝对路径：主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 - 例：C:xyz est.txt 代表了test.txt文件的绝对路径 - 相对路径：相对与某个基准目录（一般对照WEB）的路径。 - 例：&rdquo;/&ldquo;代表Web应用的跟目录， &ldquo;./&rdquo; 代表当前目录,&ldquo;../&ldquo;代表上级目录 - 注：JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的
获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&ldquo;？&rdquo;) &ndash;&gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&rdquo;\&ldquo;) //站点绝对路径 application.getRealPath(&ldquo;&rdquo;) //JSP界面使用 ServletContext().getRealPath(&ldquo;&rdquo;)  返回字串  C:\Apache\Tomcat\webapps\local&#43; （\ . 空格 \web.xml）   工程Classes下路径（SRC/CLASS）  使用环境  SERVLET/JSP/JAVA（即任意CLASS）  使用语句  this.getClass()/JdomParse.class .getClassLoader().getResource(&ldquo;&rdquo;).getPath(); //注：因为三者均为JAVA程序，都为CLASS，故为三者通用方法 this.getClass()JdomParse.class .getResource(&ldquo;&rdquo;).getPath().toString(); //可用于不同WEB环境来确认路径 Thread.currentThread().getContextClassLoader().getResource(&ldquo;&rdquo;).getPath()  返回字串">
    
    

    
    

    
      <meta property="og:image" content="http://otzm88f21.bkt.clouddn.com/45fdfc23-9844-433b-872c-dc78cddf7b21.png">
    

    
    
    

    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://wrrwhn.github.io/domain/css/style-jsjn0006wyhpyzivf6yceb31gvpjatbcs3qzjvlumobfnugccvobqwxnnaj8.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="3">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://wrrwhn.github.io/domain/">姚清居到此一游</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://wrrwhn.github.io/domain/#about">
    
    
    
      
        <img class="header-picture" src="http://otzm88f21.bkt.clouddn.com/45fdfc23-9844-433b-872c-dc78cddf7b21.png" alt="" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="3">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://wrrwhn.github.io/domain/#about">
          <img class="sidebar-profile-picture" src="http://otzm88f21.bkt.clouddn.com/45fdfc23-9844-433b-872c-dc78cddf7b21.png" alt="" />
        </a>
        <h4 class="sidebar-profile-name">姚清居到此一游</h4>
        
          <h5 class="sidebar-profile-bio"><a href="https://github.com/wrrwhn">https://github.com/wrrwhn</a></h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://wrrwhn.github.io/domain/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://wrrwhn.github.io/domain/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://wrrwhn.github.io/domain/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://wrrwhn.github.io/domain/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://wrrwhn.github.io/domain/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/wrrwhn" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://wrrwhn.github.io/domain/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="3"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      Java.常用技术
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2016-12-09T22:07:46&#43;08:00">
        
   9, 2016

      </time>
    
    
  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              

<h2 id="参考">参考</h2>

<ul>
<li><a href="http://unmi.cc/jdk-5-concurrent-callable-futuretask-etc/">http://unmi.cc/jdk-5-concurrent-callable-futuretask-etc/</a></li>
<li><a href="http://www.cnblogs.com/wn398/archive/2013/06/15/3130967.html">http://www.cnblogs.com/wn398/archive/2013/06/15/3130967.html</a></li>
<li><a href="http://ifeve.com/locks/">http://ifeve.com/locks/</a></li>
</ul>

<h2 id="获取路径">获取路径</h2>

<p>###分类：
- 绝对路径：主页上的文件或目录在硬盘上真正的路径，如URL和物理路径
    - 例：C:xyz est.txt 代表了test.txt文件的绝对路径
- 相对路径：相对与某个基准目录（一般对照WEB）的路径。
    - 例：&rdquo;/&ldquo;代表Web应用的跟目录， &ldquo;./&rdquo; 代表当前目录,&ldquo;../&ldquo;代表上级目录
- 注：JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的</p>

<h3 id="获取方法">获取方法</h3>

<h3 id="jsp路径-系统全路径">JSP路径/系统全路径</h3>

<ul>
<li>使用环境

<ul>
<li>SERVLET/JSP</li>
</ul></li>
<li>使用语句

<ul>
<li>request.getRealPath(&ldquo;？&rdquo;) &ndash;&gt; ？为/  .  空格  web.xml</li>
<li>request.getRealPath(request.getRequestURI());</li>
<li>getServletContext().getRealPath(&rdquo;\&ldquo;)     //站点绝对路径</li>
<li>application.getRealPath(&ldquo;&rdquo;)    //JSP界面使用</li>
<li>ServletContext().getRealPath(&ldquo;&rdquo;)</li>
</ul></li>
<li>返回字串

<ul>
<li>C:\Apache\Tomcat\webapps\local+ （\  .  空格  \web.xml）</li>
</ul></li>
</ul>

<h3 id="工程classes下路径-src-class">工程Classes下路径（SRC/CLASS）</h3>

<ul>
<li>使用环境

<ul>
<li>SERVLET/JSP/JAVA（即任意CLASS）</li>
</ul></li>
<li>使用语句

<ul>
<li>this.getClass()/JdomParse.class .getClassLoader().getResource(&ldquo;&rdquo;).getPath();        //注：因为三者均为JAVA程序，都为CLASS，故为三者通用方法</li>
<li>this.getClass()JdomParse.class .getResource(&ldquo;&rdquo;).getPath().toString();                //可用于不同WEB环境来确认路径</li>
<li>Thread.currentThread().getContextClassLoader().getResource(&ldquo;&rdquo;).getPath()</li>
</ul></li>

<li><p>返回字串</p>

<ul>
<li>/D:/workspace/strutsTest/WebRoot/WEB-INF/classes/</li>
<li>/D:/workspace/strutsTest/WebRoot/WEB-INF/classes/bl/</li>

<li><p>/E:/order/002_ext/WebRoot/WEB-INF/classes/</p>

<h3 id="系统路径">系统路径</h3></li>
</ul></li>

<li><p>使用环境</p>

<ul>
<li>APPLICATION/SERVLET/JSP</li>
</ul></li>

<li><p>使用语句：</p>

<ul>
<li>System.getProperty(&ldquo;user.dir&rdquo;)        //相对项目（JAVA为项目，WEB依工具而定）路径</li>
<li>ServletContext servletContext = config.getServletContext(); String rootPath = servletContext.getRealPath(&ldquo;/&rdquo;);</li>
<li>application.getRealPath(&ldquo;&rdquo;)</li>
</ul></li>

<li><p>返回字串</p></li>
</ul>

<h3 id="web根上下文环境-即相对路径">WEB根上下文环境（即相对路径）</h3>

<ul>
<li>使用环境

<ul>
<li>于SERVLET的INIT中</li>
<li>于httpServletRequest中</li>
</ul></li>
<li>使用语句

<ul>
<li>request.getContextPath()getRealPath(&ldquo;/&rdquo;);</li>
<li>request.getSession().getServletContext().getRealPath(&ldquo;/&rdquo;);</li>
</ul></li>
<li>返回字串

<ul>
<li>D:\工具\Tomcat-6.0\webapps\002_ext\ （其中002_ext为项目名称）</li>
<li>request.getContextPath() -&gt; web项目名</li>
</ul></li>
</ul>

<h3 id="站点虚拟路径">站点虚拟路径</h3>

<ul>
<li>使用环境</li>
<li>使用语句

<ul>
<li>getContextPath():</li>
</ul></li>
<li>返回字串</li>
</ul>

<h3 id="类加载器路径">类加载器路径</h3>

<ul>
<li>使用环境</li>
<li>使用语句

<ul>
<li>class.getClassLoader.getPath()；

<ul>
<li>InputStream is=TestAction.class.getClassLoader().getResourceAsStream(&ldquo;test.txt&rdquo;);</li>
<li>InputStream is=Test1.class.getResourceAsStream(&ldquo;/test.txt&rdquo;);</li>
</ul></li>
</ul></li>
<li>返回字串

<ul>
<li>均返回指定路径文件（\src\test.txt）的装载项目</li>
<li>注：不论是一般的java项目还是web项目,先定位到能看到包路径的第一级目录（TestAction在其中）</li>
</ul></li>
</ul>

<h2 id="泛型">泛型</h2>

<ul>
<li>介绍

<ul>
<li>重复代码重构，于编译时检测类型安全，保存所有强制类型均为自动或隐式，提高代码重用率</li>
</ul></li>
<li>规则

<ul>
<li>泛型参数允许多个，且仅能为类类型，不能为简单类型</li>
<li>泛型参数支持extends(有办类型)或通配符类型</li>
<li>支持类型有泛型类、接口和方法</li>
</ul></li>
<li>实例
<code>
class Gen&lt;T&gt; {
private T ob; //定义泛型成员变量
public Gen(T ob) {
    this.ob = ob;
}
public T getOb() {
    return ob;
}
public void setOb(T ob) {
    this.ob = ob;
}
public void showType() {
    System.out.println(&quot;T的实际类型是: &quot; + ob.getClass().getName());
}
}
public class GenDemo {
public static void main(String[] args){
    //定义泛型类Gen的一个Integer版本
    Gen&lt;Integer&gt; intOb=new Gen&lt;Integer&gt;(88);
    intOb.showType();
    int i= intOb.getOb();
    System.out.println(&quot;value= &quot; + i);
    //定义泛型类Gen的一个String版本
    Gen&lt;String&gt; strOb=new Gen&lt;String&gt;(&quot;Hello Gen!&quot;);
    strOb.showType();
    String s=strOb.getOb();
    System.out.println(&quot;value= &quot; + s);
}
}
</code></li>
<li>泛型方法
<code>
public static &lt;T&gt; T display(T t) {
return t;
}
</code></li>
</ul>

<h2 id="jmx">JMX</h2>

<h3 id="推荐">推荐</h3>

<ul>
<li>介绍：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse63/">http://www.ibm.com/developerworks/cn/java/j-lo-jse63/</a></li>
<li>Tomcat配置：<a href="http://tomcat.apache.org/tomcat-7.0-doc/monitoring.html#Enabling_JMX_Remote">http://tomcat.apache.org/tomcat-7.0-doc/monitoring.html#Enabling_JMX_Remote</a></li>
<li>入门示例：<a href="http://rabbit9898.iteye.com/blog/1009198">http://rabbit9898.iteye.com/blog/1009198</a></li>
<li>官方事例：<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jmx/examples.html">http://docs.oracle.com/javase/1.5.0/docs/guide/jmx/examples.html</a></li>
<li>官方教程：<a href="http://docs.oracle.com/javase/tutorial/jmx/index.html">http://docs.oracle.com/javase/tutorial/jmx/index.html</a></li>
</ul>

<h3 id="组成">组成</h3>

<ul>
<li>Instrumentation

<ul>
<li>使用MBean在遵循JMX规范中定义的设计模式和接口的基础上，确保提供标准化管理资源的仪表。</li>
<li>MXBean为在MBean的基础上预定义了一组数据类型。</li>
</ul></li>
<li>JMX agent

<ul>
<li>直接操作资源并使之于远程应用上生效，其核心部件为MBean server。</li>
</ul></li>
<li>Remote management

<ul>
<li>通过协议适配器和连接器支持JVM提供外部JMX agent</li>
</ul></li>
</ul>

<h3 id="监控管理">监控管理</h3>

<h4 id="平台mxbeans和平台mbean-server">平台MXBeans和平台MBean Server</h4>

<pre><code>平台MXBeans是用监视和管理JVM及运行时环境的的组件，功能包括类加载系统，即时编译系统和垃圾回收等平台。并保证不同环境下的JVM使用统一规范。
平台MBean Server用于注册管理平台MXBeans或自行创建的MBeans。
</code></pre>

<h4 id="jconsole">JConsole</h4>

<ul>
<li>特点

<ul>
<li>java自带(JAVA_HOME/bin/jconsole.exe)可视化监控管理工具，可查看Java平台上运行的程序的性能和资源消耗的信息。</li>
</ul></li>
<li>推荐

<ul>
<li>使用指导：<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></li>
</ul></li>
<li>定义

<ul>
<li>监控本地和远程JVM、java应用程序的可视化监督工具，使用JMX技术实现。</li>
</ul></li>
<li>异常

<ul>
<li>描述

<ul>
<li>jConsole的MXBean树显示不合理</li>
</ul></li>
<li>事例

<ul>
<li>MXBean列表：

<ul>
<li>com.sun.example:type=Triangle,side=isosceles,name=1</li>
<li>com.sun.example:type=Triangle,name=2,side=isosceles</li>
<li>com.sun.example:type=Triangle,side=isosceles,name=3</li>
</ul></li>
<li>树形结构
<code>
|-com.sum.example
|-Triangle
    |-isosceles
        |-1
        |-3
    |-2
        |-isosceles   
</code></li>
</ul></li>
<li>解决

<ul>
<li>补充-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=type,side,name，指定关键字的顺序</li>
</ul></li>
</ul></li>
</ul>

<h3 id="mbeans介绍">MBeans介绍</h3>

<ul>
<li>概念

<ul>
<li>类似于JavaBean，并可管理所有需要管理的应用、资源和设备。</li>
</ul></li>
<li>组成

<ul>
<li>一系列可读可写属性</li>
<li>一系列可调用方法</li>
<li>自行描述</li>
</ul></li>
<li>分类

<ul>
<li>Standard MBeans</li>
<li>Dynamic MBeans</li>
<li>Open MBeans</li>
<li>Model MBeans</li>
<li>MXBeans</li>
</ul></li>

<li><p>实例</p>

<pre><code>标准MBean= todoMBean接口（定义所有方法属性）+ todo实现
public interface HelloMBean {     //todoMBean接口     注：规范要求接口必须以 dosome+ MBean为名称
    public String getName();        //只读
    public int getCacheSize();         //可读可写
    public void setCacheSize(int size);
}
public class Hello implements HelloMBean {         //todo实现
    private final String name = &quot;Reginald&quot;;
    private int cacheSize = DEFAULT_CACHE_SIZE;
    private static final int DEFAULT_CACHE_SIZE = 200;
    public String getName() {
        return this.name;
    }                     
    public int getCacheSize() {
        return this.cacheSize;
    }
    public synchronized void setCacheSize(int size) {
        this.cacheSize = size;
        System.out.println(&quot;Cache size now &quot; + this.cacheSize);
    }
}
MXBean= 可支持任意客户端（包括远程）。命名不一定要为todoMXBean，可使用@MXBean注解
public interface QueueSamplerMXBean {         //MXBean接口
    public QueueSample getQueueSample();
    public void clearQueue();
}
public class QueueSampler implements QueueSamplerMXBean {         //定义QueueSamplerMXBean实现
    private Queue&lt;String&gt; queue;

    public QueueSampler (Queue&lt;String&gt; queue) {
        this.queue = queue;
    }
    public QueueSample getQueueSample() {                 //自定义返回类型
        synchronized (queue) {
            return new QueueSample(new Date(), queue.size(), queue.peek());
        }
    }                         
    public void clearQueue() {
        synchronized (queue) {
            queue.clear();
        }
    }
}
通知：用于反馈状态改变、事件或问题异常
必须实现 NotificationEmitter 或继承 NotificationBroadcasterSupport
实现 Notification 或子类如 AttributeChangedNotification
public class Hello extends NotificationBroadcasterSupport implements HelloMBean {
    public synchronized void setCacheSize(int size) {
        Notification n = new AttributeChangeNotification(this, sequenceNumber++, System.currentTimeMillis(), &quot;CacheSize changed&quot;, &quot;CacheSize&quot;, &quot;int&quot;, oldSize, this.cacheSize);
        sendNotification(n);
    }
    @Override
    public MBeanNotificationInfo[] getNotificationInfo() {
        String[] types = new String[]{
            AttributeChangeNotification.ATTRIBUTE_CHANGE
        };
        String name = AttributeChangeNotification.class.getName();
        String description = &quot;An attribute of this MBean has changed&quot;;
        MBeanNotificationInfo info =
                new MBeanNotificationInfo(types, name, description);
        return new MBeanNotificationInfo[]{info};
    }
}
</code></pre></li>
</ul>

<h3 id="远程管理">远程管理</h3>

<ul>
<li>概念

<ul>
<li>JMX API 允许通过JMX连接器（服务端和客户端组成）远程管理个人资源，并定义了远程方法调用（RMI）基础上标准连接协议。

<ul>
<li>注：需要应用配置以正常的参数，具体可参见【Tomcat本地JMX监控】或如下例</li>
</ul></li>
</ul></li>
<li>指令调用
<code>
javac com/example/*.java     //编译java文件
java -Dcom.sun.management.jmxremote.port = 9999  \
 -Dcom.sun.management.jmxremote.authenticate = false \
 -Dcom.sun.management.jmxremote.ssl = false \
 com.example.Main         //启动时配置调用端口等信息                 
</code></li>
<li>启动要求

<ul>
<li>java1.5：命令行指定JMX才会启动</li>
<li>java1.6：默认启动JMX

<ul>
<li>注：jConsole可通过pid（进程ID）进行JMX管理，其中内部将pid转换为JMX URL</li>
</ul></li>
</ul></li>
<li>调用
<code>
//RMI+ 连接+ MBeanServer获取
JMXServiceURL url =new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://:9999/jmxrmi&quot;);
JMXConnector jmxc = JMXConnectorFactory.connect(url, null);       
MBeanServerConnection mbsc = jmxc;
//明确的MBean或MXBean - 代理调用
ObjectName mbeanName = new ObjectName(&quot;com.example:type=Hello&quot;);
HelloMBean mbeanProxy = JMX.newMBeanProxy(mbsc, mbeanName, HelloMBean.class, true);
    或 OperatingSystemMXBean osBean= ManagementFactory.newPlatformMXBeanProxy(mbsc, ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME, OperatingSystemMXBean.class);
mbeanProxy.getCacheSize();        //调用方法和属性
//未明确MBean或MXBean情况
 ObjectName objectName= new ObjectName(appName+ &quot;:name=MuleContext&quot;);        //获取属性
String status= mbsc.getAttribute(objectName, &quot;Stopped&quot;).toString();
mbsc.invoke(object, action, param, signature);                                //调用方法
</code></li>
<li>连接方式整理
<code>
1&gt; MBeanServerFactory.createMBeanServer();                                    //ManagementFactory.getPlatformMBeanServer()第一次调用时会默认调用上述方法
ObjectName name = new ObjectName(&quot;book.liuyang:service=Counter&quot;);
server.registerMBean(new Counter(), name);
    注：可见Domain为JMImplementation
2&gt; JMXConnectorFactory.connect(
    new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://:9999/jmxrmi&quot;),
    null
).getMBeanServerConnection()
    注：可见Domain为JMImplementation,com.sun.management,Catalina,java.nio,org.apache.commons.pool2,java.lang,java.util.logging
</code></li>
</ul>

<h3 id="jvm运行情况-jmx">JVM运行情况 - JMX</h3>

<h4 id="监控双方于同一jvm">监控双方于同一JVM</h4>

<pre><code>MBeanServer server = ManagementFactory.getPlatformMBeanServer(); 
RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(server, &quot;java.lang:type=Runtime&quot;, RuntimeMXBean.class); 
</code></pre>

<h4 id="监控双方位于不同jvm">监控双方位于不同JVM</h4>

<ul>
<li>被监控JVM补充JVM代码启动参数
<code>
-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=127.0.0.1:8000
-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false
</code></li>

<li><p>连接代理</p>

<pre><code>JMXServiceURL url = new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:8000/jmxrmi&quot;); 
JMXConnector connector = JMXConnectorFactory.connect(url); 
RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(connector.getMBeanServerConnection(),&quot;java.lang:type=Runtime&quot;, RuntimeMXBean.class);
</code></pre>

<h4 id="监控双方位于不同jvm-但处于同一物理主机-java-instrutment-attach-api">监控双方位于不同JVM，但处于同一物理主机(Java Instrutment&amp; Attach API)</h4></li>

<li><p>通过Attach到被监控的JVM进程，并在被监控的JVM中启动一个JMX代理，然后使用该代理通过2的方式连接到被监控的JVM的JMX上。
```
//Attach 到5656的JVM进程上，后续Attach API再讲解
VirtualMachine virtualmachine = VirtualMachine.attach(&ldquo;5656&rdquo;);</p></li>
</ul>

<p>//让JVM加载jmx Agent，后续讲到Java Instrutment再讲解
String javaHome = virtualmachine.getSystemProperties().getProperty(&ldquo;java.home&rdquo;);
String jmxAgent = javaHome + File.separator + &ldquo;lib&rdquo; + File.separator + &ldquo;management-agent.jar&rdquo;;
virtualmachine.loadAgent(jmxAgent, &ldquo;com.sun.management.jmxremote&rdquo;);</p>

<p>//获得连接地址
Properties properties = virtualmachine.getAgentProperties();
String address = (String)properties.get(&ldquo;com.sun.management.jmxremote.localConnectorAddress&rdquo;);</p>

<p>//Detach
virtualmachine.detach();</p>

<p>JMXServiceURL url = new JMXServiceURL(address);
JMXConnector connector = JMXConnectorFactory.connect(url);
RuntimeMXBean rmxb = ManagementFactory.newPlatformMXBeanProxy(connector.getMBeanServerConnection(), &ldquo;java.lang:type=Runtime&rdquo;,RuntimeMXBean.class);</p>

<pre><code>
### [TOMCAT本地JMX监控](http://sharpspeed.iteye.com/blog/2009770)
#### windows
- 系统配置
    - windows7 64位
    - java 1.7.0_55
    - tomcat 7.0.54
- 配置修改
    - D:\Program Files\Apache\Tomcat\apache-tomcat-7.0.54\bin\catalina.bat
    - 于:doRun节点下补充
    ```
    set JMX_REMOTE_CONFIG=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=true -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false
    set CATALINA_OPTS=%CATALINA_OPTS% %JMX_REMOTE_CONFIG%
    其中port为代码连接端口，与jConsole中列举的端口不一致
    若需要鉴权，则请将authenticate设置为true，并调整鉴权相同配置，具体可见参考内容
    ```
- 连接测试
</code></pre>

<p>String rmi= &ldquo;service:jmx:rmi:///jndi/rmi://localhost:9999/jmxrmi&rdquo;;
JMXServiceURL serviceURL = new JMXServiceURL(rmi);
conn = JMXConnectorFactory.connect(serviceURL);
conn.getMBeanServerConnection();</p>

<pre><code>
#### Linux
- 系统配置
    - CentOS 6.5
    - java 1.6.0_33
    - tomcat 7.0.54Z
- 配置修改（含tomcat安装）
    - `cd /data/test/download/targz`
    - `rz #上传apache-tomcat-7.0.54.tar.gz`
    - `tar -xzf apache-tomcat-7.0.54.tar.gz`
    - `cd apache-tomcat-7.0.54/bin`
    - `vi catalina.sh`
    - `/Execute The Requested Command`
        - 于当行后补充
        ```
        CATALINA_OPTS=&quot;$CATALINA_OPTS -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;
        // 且注意上例代码不能折行！！
        ```
    - ESC
    - :wq
    - ./startup.sh
    - rz #上传测试执行文件jmx.jar
- 连接测试：
    - `java -jar /data/test/download/targz/apache-tomcat-7.0.54/bin/jmx.jar`



## 多线程
### 创建方法
- 继续Thread
</code></pre>

<pre><code>public class ExtendThread extends Thread {
    public void run(){System.out.println(this.getName());}
}
new ExtendThread().start();
</code></pre>

<pre><code>- 实现Runnable
</code></pre>

<pre><code>public class ImpleRunnable implements Runnable {
    public void run(){System.out.println(this.getName());}
}
new Thread(new ImpleRunnable(),&quot;Thread&quot;).start(); 
</code></pre>

<pre><code>- 注意事项
    - Runable非常适合多个相同线程来处理同一份资源的情况

### 生命周期
- New新建
    - 当线程被创建时，该线程处于新建状态，此时它和其他java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量的值。（此时的线程没有表现出任何表现出任何线程的动态特征，程序也不会执行线程的线程执行体）
    - new Thread（）||new Thread（Runnable target，String name）
- Runnable就绪
    - 就绪也就是说启动线程，调用start方法来启动线程，系统会将该run方法当成线程执行体来处理。如果直接调用线程对象的run方法。则run方法会立即执行，且在这个run方法的执行体未执行结束前其他线程无法并发执行（即系统会将run方法当做一个普通对象的普通方法，而不是线程执行体对待）
        - 附1：如果有一个主线程，一个子线程。当根据逻辑代码该调用子线程时不一定会立即调用，为了想在子线程start（）后立即调用子线程，可以考虑使用Thread.sleep（1），这样会让当前线程（主线程）睡眠1毫秒，因为cpu在这1毫秒中是不会休息的，这样就会去执行一条处于就绪状态的线程。
        - 附2：不能对已经处于就绪状态的线程，再次使用start（）
- Running 运行
    - 当处于就绪状态时，该线程获得cpu，执行体开始运行，就处于运行状态了。
- Blocked 阻塞
    - 线程不可能一直处于运行状态（线程执行体足够短，瞬间就可以完成的线程排除），线程会在运行过程中需要被中断，因为是并发，目的是会让其他线程获得执行的机会，线程的调度细节取决于OS采用的策略。（抢占式调度xp win7 linux unix..）。如果是一些特殊的小型设备可能采用协作式调度（只有线程自己调用它的sleep（）或yield（）才会放弃所占用的资源）。
- Dead死亡
    - 测试某条线程是否已经死亡，可以调用线程对象的isAlive（）方法，当线程处于就绪，运行，阻塞时，返回true。线程处于新建，死亡时返回false。
    - 不能对已经死亡的线程调用start（）方法使它重新启动，死亡就是死亡，是不能再次作为线程执行的。
- 当主线程结束时候，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受到主线程的影响。

### 线程控制
#### JOIN：等待该线程结束后再往下执行
- 方法
    - Join（）：等待被join的线程执行完成
    - Join（long millis）:等待join线程的时间最长为millis毫秒，如果在这个时间内，被join的线程还没有执行结束则不再等待）
    - Join（long millis，int nanos）千分之一毫秒（不用）
- 实例
</code></pre>

<p>JoinThread joinThread= new JoinThread();
new Thread(joinThread).start();
for(int i=0; i&lt; 4; i++) {
    Thread thread = new Thread(joinThread);
    thread.start();
    thread.join();        //若只针对最后一个调用，则最后一个调用完成，可能其它线程还未完成也会继续往下执行而导致数据未完全
}
for(int i=0; i&lt; 3; i++){
    System.out.println(Thread.currentThread().getName() + &ldquo;\t&rdquo; + i);
}</p>

<p>返回结果：
        Thread-0    0
        Thread-1    0
        Thread-0    1
        Thread-1    1
        Thread-1    2
        Thread-0    2
        Thread-2    0
        Thread-2    1
        Thread-2    2
        Thread-3    0
        Thread-3    1
        Thread-3    2
    main    0
    main    1
    main    2</p>

<pre><code>
#### 后台进程
</code></pre>

<p>JoinThread joinThread= new JoinThread();
Thread thread= new Thread(joinThread);
thread.setDaemon(true);        //必须于执行前设置。前台线程结束后，会再执行一段时间后台线程。
thread.start();
for(int i=0; i&lt; 10; i++){
    System.out.println(Thread.currentThread().getName() + &ldquo;\t&rdquo; + i);
}
返回结果：
    main    0
    main    1
    main    2
    main    3
        Thread-0    0
    main    4
        Thread-0    1
    main    5
        Thread-0    2
    main    6
        Thread-0    3
    main    7
        Thread-0    4
    main    8
        Thread-0    5
    main    9
        Thread-0    6
        Thread-0    7
        Thread-0    8
        Thread-0    9
        Thread-0    10
        Thread-0    11
        Thread-0    12
SLEEP：休眠，状态转阻塞
YIELD：线程让步，状态转就绪，让步于优先级相同或更高的线程</p>

<pre><code>
#### 多线程同步
- 同步代码块
</code></pre>

<pre><code>Synchronized(obj){ 
    //...同步代码块 
} 
</code></pre>

<pre><code>- 同步方法
</code></pre>

<p>public synchronized void draw(){  &hellip;}</p>

<pre><code>- 锁定释放时机：1.调用执行结束 2.break或return 3.代码中出现Error或Exception 4.代码中执行监视器对象的wait进行当前线程的暂停释放
- 不释放情况：1.调用Thread.sleep/yield 2.其它线程调用该线程的suspend将之挂起（不推荐使用）
- 同步锁LOCK
</code></pre>

<p>private final ReentrantLock relock=new ReentrantLock();  //声明锁对象
public void run(){
    relock.lock();      //加锁
    try{<br />
        &hellip;    //同步执行代码
    }finally{  //释放锁
        relock.unlock();
    }
}</p>

<pre><code>- 死锁
    - 当两个线程相互等待对方释放同步监视器的时候就会发生死锁，一旦出现死锁，整个程序既不会发生任何异常，也不会有任何提示，只是所有线程处于阻塞状态，无法继续。


#### 线程通信
- 线程协调运行
    - Object: wait()| notify()|| notifyAll()
- 使用条件变量来控制协调
    - Condition：await()|| signal()|| signalAll()
        - private final Lock lock=new ReentrantLock(); 
        - private final Condition cond=lock.newCondition(); 
- 管道流通信
</code></pre>

<p>//1.创建管道输入输出流
PipedWriter pw = new PipedWriter();
PipedReader pr = new PipedReader();
//2.管道连接
pr.connect(pw);
//3.将管理分别传入处理线程并调用实现
new Thread(new ReaderThread(pr),&ldquo;读取管道线程&rdquo;).start();        //pw.write(str);
new Thread(new WriterThread(pw),&ldquo;写入管道线程&rdquo;).start();        //while ((buffer = br.readLine()) != null)</p>

<pre><code>
#### 线程组
- 介绍
    - 对线程组的控制相当于同时控制这批线程。
    - 用户创建默认属于默认线程组，如子线程和创建它的主线程同处同一线程组。
    - 一旦加入指定线程组，中途不允许调整。
    - Thread th=new Thread(new ThreadGroup(&quot;私人&quot;), new GroupThread(), &quot;线程1&quot;);


## 反射
### 机制
- 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制
### 用途
- 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
- 对于任意一个对象，都能够调用它的任意一个方法；
### 实例
- 主要针对框架开发，如jsp的javabean,spring的自动注入，hibernate及struts
### 代码
</code></pre>

<pre><code>public class ReflectionTest {
    //测试变更属性，其中为了直观调用属性属性设置为public类型
    public double field;
    public static void main(String[] args) {
//        printClssInfo();
//        callClassMethod();
//        callFieldChange();
        List2Obj();
    }
    /***
     * 构造函数（无参-默认&amp; 带参）
     */
    public ReflectionTest() {}
    public ReflectionTest(Double field) {
        this.field = field;
    }
    /**
     *  动态获取数据对象，可将多维数组的部分结构拼成对象来调用
     */
    public static void List2Obj(){
        int dims[] = new int[]{5, 10, 15};
        Object arr = Array.newInstance(Integer.TYPE, dims);
        Object arrobj = Array.get(arr, 3);
        Class cls = arrobj.getClass().getComponentType();
        System.out.println(cls.getSimpleName());
        arrobj = Array.get(arrobj, 5);
        Array.setInt(arrobj, 10, 37);
        int arrcast[][][] = (int[][][]) arr;
        System.out.println(arrcast[3][5][10]);
    }
    /***
     * 调用参数的方法进行属性更新
     */
    public static void callFieldChange(){
        Class c = null;
        try {
            c = Class.forName(&quot;com.yao.controller.reflection.ReflectionTest&quot;);
            Field field= c.getField(&quot;field&quot;);
            ReflectionTest reflect= new ReflectionTest(12.34D);
            System.out.println(reflect.field);
            field.setDouble(reflect, 43.21);
            System.out.println(reflect.field);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    /***
     * 专门用于提供反射调用
     * @param a 加数1
     * @param b 加数2
     * @return  a+b的结果
     */
    public int add(int a, int b){
        return a+ b;
    }
    /***
     * 调用本方法内的ADD方法
     *      Constructor方式与之相似
     */
    public static void callClassMethod(){
        Class c = null;
        try {
            c = Class.forName(&quot;com.yao.controller.reflection.ReflectionTest&quot;);
            //指定方法和参数类型以获取类中对应的方法
            Class types[]= new Class[2];
            types[0]= Integer.TYPE;
            types[1]= Integer.TYPE;
            Method method= c.getMethod(&quot;add&quot;, types);
            //针对各参数位填充以实际数值
            Object args[]= new Object[2];
            args[0]= new Integer(1);
            args[1]= new Integer(2);
            Integer retVal= (Integer)method.invoke(c.newInstance(), args);
            System.out.print(retVal);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    /***
     * 输出String类大致文档结构
     */
    public static void printClssInfo(){
        Class c = null;
        try {
            c = Class.forName(&quot;java.lang.String&quot;);
            System.out.println(&quot;package &quot; + c.getPackage().getName() + &quot;;&quot;);
            System.out.print(Modifier.toString(c.getModifiers()) + &quot; &quot;);
            System.out.print(&quot;class &quot; + c.getSimpleName() + &quot; &quot;);
            if (c.getSuperclass() != Object.class) {
                System.out.print(&quot;extends &quot; + c.getSuperclass().getSimpleName());
            }
            Class[] inters = c.getInterfaces();
            if (inters.length &gt; 0) {
                System.out.print(&quot;implements &quot;);
                for (int i = 0; i &lt; inters.length; i++) {
                    System.out.print(inters[i].getSimpleName());
                    if (i &lt; inters.length - 1) {
                        System.out.print(&quot;,&quot;);
                    }
                }
            }
            System.out.println(&quot;{&quot;);
            printFields(c);
            printMethods(c);
            System.out.println(&quot;}&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    /***
     * 打印类的所有参数
     * @param c
     */
    public static void printFields(Class c) {
        Field[] field = c.getDeclaredFields();
        if (field.length &gt; 0) {
            for (int i = 0; i &lt; field.length; i++) {
                System.out.println(Modifier.toString(field[i].getModifiers()) + &quot; &quot; + field[i].getType().getSimpleName() + &quot; &quot; + field[i].getName() + &quot;;&quot;);
            }
        }
    }
    /***
     * 打印类的所有方法
     * @param c
     */
    public static void printMethods(Class c) {
        Method[] method = c.getDeclaredMethods();
        if (method.length &gt; 0) {
            for (int i = 0; i &lt; method.length; i++) {
                Class[] parameter = method[i].getParameterTypes();
                System.out.print(Modifier.toString(method[i].getModifiers()) + &quot; &quot; + method[i].getReturnType().getSimpleName() + &quot; &quot; + method[i].getName() + &quot;(&quot;);
                for (int j = 0; j &lt; parameter.length; j++) {
                    System.out.print(parameter[j].getSimpleName() + &quot; args&quot;);
                    if (j != parameter.length - 1) {
                        System.out.print(&quot;,&quot;);
                    }
                }
                System.out.print(&quot;) &quot;);
                Class exception[] = method[i].getExceptionTypes();
                if (exception.length &gt; 0) {
                    System.out.print(&quot;throws &quot;);
                    for (int j = 0; j &lt; exception.length; j++) {
                        System.out.print(exception[j].getSimpleName());
                    }
                }
                System.out.println(&quot;{&quot;);
                System.out.println(&quot;\t... ...&quot;);
                System.out.println(&quot;}&quot;);
            }
        }
    }
}
</code></pre>

<pre><code>
## 注解
### 自定义注解
代码格式
    @Target({ElementType.METHOD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface LoginRequired {
    }
框架详解
- Target
    - 指定该注解使用的位置
    ```
    public enum ElementType {   
        TYPE,                 // 指定适用点为 class, interface, enum   
        FIELD,                 // 指定适用点为 field   
        METHOD,             // 指定适用点为 method   
        PARAMETER,             // 指定适用点为 method 的 parameter   
        CONSTRUCTOR,         // 指定适用点为 constructor   
        LOCAL_VARIABLE,     // 指定使用点为 局部变量   
        ANNOTATION_TYPE,     //指定适用点为 annotation 类型   
        PACKAGE             // 指定适用点为 package   
    }
    ```
- @Retention
    - 指定编译器处理的方式
    ```
    public enum RetentionPolicy { 
        SOURCE,     // 编译器处理完Annotation后不存储在class中，仅存在于源文件中
        CLASS,         // 编译器把Annotation存储在class中，但不能被VM读取，这是默认值 
        RUNTIME     // 编译器把Annotation存储在class中，可以由虚拟机读取,反射需要 
    }
    ```
- @Documented     
    - 指定允许写入javadoc
- @Inherited
    - 允许子类继承时同时继承该注解
    ```
    public @interface LoginRequired {
        String value() default &quot;login&quot;;   
    }
    ```
- @Constraint(指定用哪个类进行相关校验)
</code></pre>

<p>@Constraint(validatedBy = {SafeStringValidator.class, SafeStringListValidator.class})    //注解类
public class SafeStringValidator implements ConstraintValidator<SafeString, String> {    //校验实现类
```
- JAVA内置
    - Override            只用于方法,它指明注释的方法重写父类的方法,如果不是,则编译器报错.
    - Deprecated        指明该方法不建议使用
    - SuppressWarnings    告诉编译器:我知道我的代码没问题</p>

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small"></span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://wrrwhn.github.io/domain/tags/%E6%95%B4%E7%90%86/">整理</a>

  <a class="tag tag--primary tag--small" href="https://wrrwhn.github.io/domain/tags/java/">Java </a>

                  </div>
                
              
            
            
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://wrrwhn.github.io/domain/2016/12/maven/" data-tooltip="Maven">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml"></span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://wrrwhn.github.io/domain/2016/12/redis.basic/" data-tooltip="Redis.Basic">
              
                  <span class="hide-xs hide-sm text-small icon-mr"></span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2017 姚清居到此一游. 
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
        
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://wrrwhn.github.io/domain/2016/12/maven/" data-tooltip="Maven">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml"></span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://wrrwhn.github.io/domain/2016/12/redis.basic/" data-tooltip="Redis.Basic">
              
                  <span class="hide-xs hide-sm text-small icon-mr"></span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="3">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="http://otzm88f21.bkt.clouddn.com/45fdfc23-9844-433b-872c-dc78cddf7b21.png" alt="" />
    
    <h4 id="about-card-name">姚清居到此一游</h4>
    
      <div id="about-card-bio"><a href="https://github.com/wrrwhn">https://github.com/wrrwhn</a></div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        中国-福建-厦门
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/12/uml/">
                <h3 class="media-heading">UML</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"> [TOC]
UML 参考  看懂UML类图和时序图  大纲    使用  StarUML  UML.mdj   </div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/12/linux.lsof/">
                <h3 class="media-heading">Linux.Lsof</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">参考  lsof 一切皆文件  功能  查看当前系统文件的工具 支持文件类型  普通文件 目录 网络文件系统的文件 字符或设备文件 函数共享库 管道、命名管道 符号链接 网络文件（NFS、Socket）   参数  -a  列出打开文件存在的进程  -c &lt;进程名&gt;  列出指定进程所打开的文件  -g  列出GID号进程详情  -d &lt;文件号&gt;  列出占用该文件号的进程  +d &lt;目录&gt;  列出目录下被打开的文件  +D &lt;目录&gt;  递归列出目录下被打开的文件  -n &lt;目录&gt;  列出使用NFS的文件  -i &lt;条件&gt;  列出符合条件的进程。（4、6、协议、:端口、 @ip）  -p &lt;进程号&gt;  列出指定进程号所打开的文件  -u  列出UID号进程详情  -h  显示帮助信息  -v  显示版本信息   示例  lsof | more  Result | COMMAND | PID | TID | USER | FD | TYPE | DEVICE | SIZE/OFF | NODE | NAME | |&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;&mdash;|&mdash;&ndash;|&mdash;&mdash;&mdash;&mdash;|&mdash;&mdash;&mdash;&mdash;|&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;| | 进程名称 | 进程标识符 | | 进程所有者 | 文件描述符 | 文件类型 | 指定磁盘 | 文件大小 | 索引节点 | 打开文件的确切名称 | | systemd | 1 | | root | cwd | unknown | | | | /proc/1/cwd(readlink: Permission denied) | FD  cwd  表示current work dirctory，即应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改  txt  该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序  lnn  library references (AIX);  er  FD information error (see NAME column);  jld  jail directory (FreeBSD);  ltx  shared library text (code and data);  mxx  hex memory-mapped type number xx.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/12/%E7%BD%91%E7%BB%9C-%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/">
                <h3 class="media-heading">网络-七层协议</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">参考  深入浅出－网络七层模型&amp;&amp;网络数据包 网络七层协议  定义  网络七层协议，理论模型 OSI（Open System Interconnection）    分层 应用层  直接为应用进程提供服务  根据提供的特性分组，称为服务元素  公共应用服务元素 CASE  所有用户可用，主要为应用进程通信，分页系统的基本控制机制  特定应用有服务元素 SASE  特定服务，如文卷传送、访问管理、银行业务等    示例  HTTP FTP SMTP/ POP3/ IMAP4 TELNET   表示层  定义数据格式、加密  如 FTP 下可选择以二进制或 ASCII 格式传输  懂中机通信的公共语言  IBM 主机使用 EBCDIC 编码 通用 PC 机采用 ASCII 码 转换以保证一致的数据形式  示例  ASCII EBCDIC  解决不同系统间的通信  LPP NBSSN   会话层  如何开始、同步和结束一个会话  使用校验点来保证通信失效后，由该校验点进行通信恢复 将会话地址映射为 IP 地址  示例  RPC SQL SSL TLS DAP   传输层  选择[无]差错恢复协议，在同一主机上对不同应用的数据流复用  对接收顺序有误的数据包排序  端对端数据的缓存层 面对会画层的界面端口 示例  TCP UDP SPX  端口通信    网络层  定义端对端的包传输 定义所有结点的逻辑地址，进行 路由|寻址 定义如何将包分解成更小的包的分段方法 示例  IP/ IPv6 EGP AHH/ ESP   数据链路层  定义在单个链路上如何传输、拆解包 每次通信时，建立起来的数据收发关系  链路连接的建立、拆除和分享 帧定界、同步 差错检测和恢复 链路标识、流量控制  示例  PPTP/ L2TP/ L2F/ ATMP ARP/ RARP  产品  网卡 网桥   物理层  为通信的两个数据终端设备提供连接，形成通路  将信息编码转换为电流脉冲或其它信号形式进行传输 方式  点对点 单点对多点 串行|并行 半双工|全双工 同步|异步   与传输介质有关  涉及连接头、帧、帧的使用、电流、编码、光调制等  示例  Rj45 将数据转换成 0|1 802.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/12/%E7%BD%91%E7%BB%9C-%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE/">
                <h3 class="media-heading">网络-四层协议</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">参考  TCP/IP四层模型 深入浅出－网络七层模型&amp;&amp;网络数据包 TCP/IP四层模型 OSI七层和TCP/IP四层的关系  定义  网络事实上的标准 又名 TCP/IP 协议族或 TCP/IP 协议栈  Transmission Control Protocol 传输控制协议 Internet Protocol 互联网协议      分层 应用层  定义  = OSI.应用层+ OSI.表示层 + OSI.会话层  示例  FTP/ TELNET/ HTTP   传输层  定义  = OSI.传输层 对数据进行缓存、报文的拆解和重组  示例  TCP  传输控制协议 transmission control protocol  UDP  用户数据报协议 user datagram protocol    网间层  定义 = OSI.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/12/%E4%B8%AD%E5%9B%BD-%E5%8E%A6%E9%97%A8-%E5%90%8C%E5%AE%89/">
                <h3 class="media-heading">中国-厦门-同安</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">参考  揣着100块钱来同安吃1整天！  路线  T4候机楼站 凤岗大肠国大肠血  BRT快2线，至同安枢纽站  阿呆盐鸭店  630A，由同安枢纽站至小西门  鑫旺旺汤包  步行  味源小吃  630A，由小西门至同安电视台站  台湾番婆冰  步行  肥栋满煎糕  步行  秀英食品  步行  双鹿老铺  步行  陆丰煎饼  612，由金安大厦至新西桥站  杨强芙蓉香骨鸡腿  625，由新西桥至同安劳动力市场站   介绍 凤岗大肠国  位置  凤岗岗头里786 同安枢纽站 直行50米左转进入凤岗路 直走600米  特色菜  纯猪血大肠  单价  15元/碗    阿呆盐鸭店  位置  小西门 下车前行50米后左转200米进入东山路  特色菜  盐鸭  单价  50元/只    鑫旺旺汤包  位置  沿着东山路走250米，进中山路再走200米  特色菜  汤包  单价  10元/笼    味源小吃  位置  同安电视台站  特色菜  碗仔粿  单价  3元/小碗 4元/大碗    台湾番婆冰  位置  沿着凤山路往南门桥走350米  特色菜  芒果冰 芋泥  单价  22元/芒果冰 6元/芋泥    肥栋满煎糕  位置  出了番婆冰右转20米就到  特色菜  满煎糕  单价  10元/个    秀英食品  位置  从番婆冰门口上桥，过桥左转沿路走到尽头右转300米，再右转上同新路，80米后左转直行100米  特色菜  醋肉  单价  20元/份    双鹿老铺  位置  从秀英出门右转到松柏林中路，200米后右转进南门路，再走70米  特色菜  马蹄酥  单价  6元/袋-10个    陆丰煎饼  位置  612路 金安大厦-新西桥站（2站） 步行到古庄大社里21号 下午三点开门  特色菜  煎饼  单价  4元/个 5.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/12/%E4%BA%91%E5%BC%80-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%B6%E6%9E%84-20171203/">
                <h3 class="media-heading">云开-服务端架构-20171203</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">流程  华山分享现有架构整理 志高补充压测等情况 讨论瓶颈优化  系统架构  客户端  微信 NW 老师端 PC 学习端  连接方式  HTTP TCP/IP  微服务  用户中心 直播相关 业务服务相关 推荐相关  模块  用户 直播  FFMpeg Nginx rtmp  NFS IM 转换  PPT  Gateway NSQ PPT.Command  音视频   底层服务  日志 持久化  Mysql，主从  缓存  Redis，仅主从无集群  文件数据   讨论  实现目标  两万人并发 目前900 QPS  确认瓶颈  缓存  解决方案  Twemproxy  参考  twitter/twemproxy Redis 存储分片之代理服务Twemproxy 测试 存储分片和Twemproxy核心解读  性能  性能损耗，最差低于 20%  优点  统一对外节点，多服务池 长连接，pipelinling 处理请求和响应，大大减少连接数 哈希分片，请求分配均匀  缺点  无法平滑地扩容或缩容 运维管理困难，无操作界面   Codis  参考  Redis集群技术及Codis实践 常见的redis集群方案有哪些优缺点？ []()  性能  最初比Twemproxy慢20%，现在比Twemproxy快近100%    优点  有图形化界面，扩容及运维方便 开发简单，对应用透明 不负责主从同步，轻量伦 提供 Jodis，支持 Java 程序的 HA  缺点  修改过 Redis 代码，无法与官方版本同步，新特性跟进缓慢 Value 字段大小小于 888B 字节时，性能较优秀 第三方组件较多     相关工作  AV-Server  可能存在问题？  CPU 使用率  GO 中使用  如何快速扩容  Kafka，多服务连接    Talk.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/11/kafka/">
                <h3 class="media-heading">Kafka</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Kafka 参考  Kafka剖析（一）：Kafka背景及架构介绍 Apache kafka 工作原理介绍 Quickstart Kafka系列2-producer和consumer报错 Using new consumer API with a Deserializer that throws SerializationException can lead to infinite loop How to find the kafka version in linux  简介  Linkedin 开发，Scala编写 特点  解耦 水平扩展 高吞吐率  缓冲 异步通信  可恢复性  冗余，确保安全保存至使用完毕后 处理消息进程宕机，仍可于启动后重新接收处理  顺序保证   架构 名词解析  Broker  集群中的服务器名称 支持水平扩展的节点  Topic  集群消息中类别  Partition  Topic 下包含一至多个 Partition  Producer  生产者 将消息发布至 Kafka broker  Consumer  消费者 向 Kafka broker 读消息的客户端  Consumer Group  各 Consumer 属于特定 Group 不指定时，则属于默认 Group   结构拓扑  整体拓扑    分析  kafka 通过 Zoopkeeper 管理集群配置  选举 Leader Consumer Group 变更时的 ReBalance  物理上 Topic 对应一至多个 Partition  每个 Partition 在物理上对应一个文件夹  消息 索引  结构  root 4k topic1-1 - 日志文件 root 4k topic1-2 .</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/11/ffmpeg.%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
                <h3 class="media-heading">FFmpeg.阅读笔记</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">[TOC]
简介  FFmpeg ffmpeg FFmpeg Formats Documentation FFmpeg - wiki FFmpeg - github 使用ffmpeg将视频转ts  概要  ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...  流程  _______ ______________ | | | | | input | demuxer | encoded data | decoder | file | ---------&gt; | packets | -----+ |_______| |______________| | v _________ | | | decoded | | frames | |_________| ________ ______________ | | | | | | | output | &lt;-------- | encoded data | &lt;----+ | file | muxer | packets | encoder |________| |______________|  选项 实例 裁剪  指令  ffmpeg -i old.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/11/git.subtree/">
                <h3 class="media-heading">Git.Subtree</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">参考  Git Subtree的使用 Git Tools - Subtree Merging 用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册  描述  简介 &gt; 经由 Git Subtree 来维护的子项目代码，对于父项目来说是透明的，所有的开发人员看到的就是一个普通的目录，原来怎么做现在依旧那么做，只需要维护这个 Subtree 的人在合适的时候去做同步代码的操作。
 适用情况
 使用 github 的 page 功能实现项目主页功能，结合 hugo 生成 public 文件夹后同步到 gh-pages 分支，作为分支完整内容 项目 A 和项目 B 存在公用模块，A 中的修改、新增等操作，均同步至项目 B  可用方案
 Git Submodule  Git 官方早期推荐方案 允许其它仓库指定 commit 嵌入仓库子目录  但需要 init 和 update  产生 .gitmodule 文件记录 submodule 版本信息 删除较费劲  Git Subtree  Git 1.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://wrrwhn.github.io/domain/2017/11/20%E5%B2%81%E7%9A%84%E4%BD%A0/">
                <h3 class="media-heading">20岁的你</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"> [TOC]
20岁时做什么到40岁时才不会后悔？ 要点  知道什么是生命中最重要的东西 尽量不要去想太多竞争 善待那些喜欢自己的人 学会欣赏这个世界 为健康打下基础 试错和重启 谨慎选择与谁一起共度 谨防短期情绪波动 一定要把收入的一部分用于储蓄 投资 写作将点燃你的头脑 要建立良好的个人品牌 设计你的生活永远不会太迟 没有人把一切都想通了  忧虑就是你在偿还你并未欠的债 - 马克吐温  了解，沟通是一切 提问 如果你发现自己不知道或不确定，就主动发问吧 做饭 冥想让头脑深度休息 更新你的心灵的操作系统  关键字  健康、控制情绪 尝试  投资理财 做饭  提问、思考、设计人生  </div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         132 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://wrrwhn.github.io/domain/images/cover.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://wrrwhn.github.io/domain/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>



<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  



    
  </body>
</html>

