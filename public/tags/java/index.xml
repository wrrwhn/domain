<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 好久不见</title>
    <link>http://domain.yqjdcyy.com/tags/java/</link>
    <description>Recent content in Java on 好久不见</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Powered by [姚清居](http://www.domain.yqjdcyy.com).</copyright>
    <lastBuildDate>Fri, 04 May 2018 00:40:00 +0800</lastBuildDate>
    
	<atom:link href="http://domain.yqjdcyy.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java.Tools.JMap</title>
      <link>http://domain.yqjdcyy.com/post/java.tools.jmap/</link>
      <pubDate>Fri, 04 May 2018 00:40:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.tools.jmap/</guid>
      <description>[TOC]
JMAP 作用  为进程、核心文件或远程调试服务器打印共享对象内存映射或堆内存细节 Java 1.8 版本中不支持   调用  jmap [option] &amp;lt;pid&amp;gt;|&amp;lt;executable &amp;lt;core&amp;gt;&amp;gt; | &amp;lt;[server_id@]&amp;lt;remoteServerIP | hostname&amp;gt;&amp;gt; 参数  &amp;lt;no option&amp;gt;  如果使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称  -dump:[live,]format=b,file=&amp;lt;filename&amp;gt;  以 hprof 二进制格式转储 Java 堆到指定文件中。live子选项是可选的 live子选项决定堆中只有活动的对象会被转储 可用 jhat 浏览 heap dump  -finalizerinfo  打印等待终结的对象信息  -heap  打印一个堆的摘要信息，包括使用的GC算法、堆配置信息和generation wise heap usage  -histo[:live]  打印堆的柱状图。其中包括每个Java类、对象数量、内存大小(单位：字节)- 、完全限定的类名 打印的虚拟机内部的类名称将会带有一个’*’前缀。如果指定了live子选项，则只计算活动的对象  -permstat  Java 1.8 版本中不支持 打印Java堆内存的永久保存区域的类加载器的智能统计信息 对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印  包含的字符串数量和大小   -F  强制模式。如果指定的pid没有响应，请使用jmap -dump或jmap -histo选项。此模式下，不支持live子选项  -h|help  打印帮助信息  -J&amp;lt;flag&amp;gt;  指定传递给运行jmap的JVM的参数    示例  jmap 24748 | 内存地址 | 内存占用 | 进程、核心文件或远程调试服务器 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;| | 0x0000000051560000 | 8740K | D:\server\Java\jdk1.</description>
    </item>
    
    <item>
      <title>Java.Tools.JINFO</title>
      <link>http://domain.yqjdcyy.com/post/java.tools.jinfo/</link>
      <pubDate>Thu, 03 May 2018 23:20:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.tools.jinfo/</guid>
      <description>[TOC]
JINFO 作用  输出进程、Core 文件或远程 Debug 服务器配置信息  Java 系统参数 命令行参数  运行于64位虚拟机上时，需指定 -J-d64 Java 1.8 版本中不支持  调用  jinfo [option] &amp;lt;pid&amp;gt; 参数  -flag &amp;lt;name&amp;gt;
 to print the value of the named VM flag  -flag [+|-]&amp;lt;name&amp;gt;
 to enable or disable the named VM flag  -flag &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;  to set the named VM flag to the given value  -flags
 to print VM flags    示例  jinfo pid  Caused by: sun.</description>
    </item>
    
    <item>
      <title>Java.Tools.JPS</title>
      <link>http://domain.yqjdcyy.com/post/java.tools.jps/</link>
      <pubDate>Thu, 03 May 2018 23:20:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.tools.jps/</guid>
      <description>[TOC]
JPS 作用  显示当前用户本地 JAVA 进程及进程号  机制  java 程序启动后，会在 java.io.tmpdir 指定临时目录下，生成名称类似于 hsperfdata_User 的文件夹，其中个别文件的名字就是 java 进程的 pid 示例  appuser 用户 ll /tmp/hsperfdata_appuser/  total 928 -rw------- 1 appuser appuser 32768 May 2 22:17 11337 -rw------- 1 appuser appuser 32768 May 2 22:17 11489    调用  jps [-q] [-mlvV] [&amp;lt;hostid&amp;gt;] 参数  -q  仅显示 pid 值  -m  显示调用时 main 函数收到的启动参数  -l  显示启动类的进程 ID 和完整路径名  -v  显示调用 JVM 时的相关参数    示例  /usr/java/jdk1.</description>
    </item>
    
    <item>
      <title>Java.Tools.JStack</title>
      <link>http://domain.yqjdcyy.com/post/java.tools.jstack/</link>
      <pubDate>Thu, 03 May 2018 23:20:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.tools.jstack/</guid>
      <description>[TOC]
JSTACK 作用  观察当前java虚拟机内每一条线程正在执行的方法堆栈的集合，以定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等 java 程序崩溃生成 core 文件，jstack工具可以用来获得 core 文件的java stack和native stack的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题 Java 1.8 版本中不支持  机制  生成java虚拟机当前时刻的线程快照 观察 Object.Monitor 于线程拥有和区域的情况，获得各进程的相关情况 | 区域 | 状态 | 描述 | |&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;| | Entry Set | Waiting ThreadWaiting for monitor entry | BLOCKEDwaiting for monitor entry线程进入临界区（ synchronized 保护起来的代码区） | | The Owner | Active Thread | RUNNABLE | | Wait Set | Waiting Threadin Object.wait() | WAITING / TIMED_WAITING  in Object.</description>
    </item>
    
    <item>
      <title>Java.Tools.JStat</title>
      <link>http://domain.yqjdcyy.com/post/java.tools.jstat/</link>
      <pubDate>Thu, 03 May 2018 23:20:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.tools.jstat/</guid>
      <description>[TOC]
JSTAT 作用 - 监视vm内存内的各种**堆**和非堆的**大小**及其**内存使用**量，并可观察classloader，compiler，**gc**相关信息  调用  jstat -&amp;lt;option&amp;gt; [-t] [-h&amp;lt;lines&amp;gt;] &amp;lt;vmid&amp;gt; [&amp;lt;interval&amp;gt; [&amp;lt;count&amp;gt;]] 参数  option  选项  –class  监视类装载、卸载数量、总空间及类装载所耗费时间 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;| | Loaded | 装载类的数量 | 11736 | | Bytes | 装载类所占字节数 | 22293.3 | | Unloaded | 卸载类的数量 | 0 | | Bytes | 卸载类所占字节数 | 0.0 | | Time | 装载和卸载类所花的时间 | 13.24 |  –gc  监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量 | 字段 | 描述 | 数值 | |&amp;mdash;&amp;mdash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;-| | S0C | 年轻代中第一个survivor（幸存区）的容量 (字节) | 20480.</description>
    </item>
    
    <item>
      <title>Java.Keyword</title>
      <link>http://domain.yqjdcyy.com/post/java.keyword/</link>
      <pubDate>Thu, 26 Apr 2018 00:30:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.keyword/</guid>
      <description>[TOC]
List Access  private protected public  class, method, variable  abstract class extends implements interface native  The native keyword may be applied to a method to indicate that the method is implemented in a language other then Java. 用于说明该方法为原生函数，由 C|C++ 实现并编译成 DLL 提供给 Java 进行调用  统一由操作系统实现   new static strictfp  strict float point | 精确浮点 确保数值计算均严格遵守 FP-strict 限制，并符合 IEEE-754 规范 保障不会因为不同的硬件平台导致计算结果不一致 可声明于类、接口或方法上  synchronized  The synchronized keyword may be applied to a method or statement block and provides protection for critical sections that should only be executed by one thread at a time.</description>
    </item>
    
    <item>
      <title>Java.Stream</title>
      <link>http://domain.yqjdcyy.com/post/java.stream/</link>
      <pubDate>Wed, 25 Apr 2018 23:30:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.stream/</guid>
      <description>[TOC]
分类 InputStream  PipedInputStream ObjectInputStream FilterInputStream  DataInputStream PushbackInputstream BufferedInputStream  FileInputStream SequenceInputStream ByteArrayInputStream  OutputStream  PipedOutputStream ObjectOutputStream FilterOutputStream  DataOutputStream BufferedOutputStream PrintStream  FileOutputStream ByteArrayOutputStream  Reader  StringReader PipedReader CharArrayReader InputStreamReader  FileReader  FilterReader  PushbackReader  BufferedReader  LineNumberReader   Writer  StringWriter PipedWriter ChatArrayWriter FilterWriter OutputStreamWriter  FileWriter  BufferedWriter PrintWriter  明细 Interface OutputStream  methods  write(int b) write(byte b[]) write(byte b[], int off, int len) flush() close()   InputStream  methods  read() read(byte b[]) read(byte b[], int off, int len) skip(long n) available() close() synchronized void mark(int readlimit) synchronized void reset()   Reader  params  Object lock  methods  read([char buf[], [int off, int len]]) skip(long n) ready() mark(int readAheadLimit) reset() close()   Writer  params  char[] writeBuffer Object lock  methods  write(int|char[]|string) Writer append(CharSequence csq[, int start, int end]) flush() close()   Stream Piped*Stream  用法  多线程时通过管道进行线程间的通讯  设计  PipedOutputStream  methods  connect(PipedInputStream snk) write(int b) write(byte b[], int off, int len)   PipedInputStream  params  DEFAULT_PIPE_SIZE = 1024 Thread readSide, writeSide;  methods  connect(PipedOutputStream src) receive(int b) receive(byte b[], int off, int len) read() read(byte b[], int off, int len)     Object*Stream  用法  通过文件永久地存储住对象（需支持 Serializable 接口）  设计  ObjectOutputStream  params  BlockDataOutputStream bout HandleTable handles ReplaceTable subs  methods  ObjectOutputStream(OutputStream out) write[Object|Boolean|Short|Char|Int|Long|Double|Bytes|Chars]   ObjectInputStream  params  BlockDataInputStream bin HandleTable handles  methods  ObjectInputStream(InputStream in) read[Object|Boolean|Short|Char|Int|Long|Double|Bytes|Chars]     Filter*Stream  用法  包含其它流，并作为基础的数据源  设计</description>
    </item>
    
    <item>
      <title>IDEA.Java.Version</title>
      <link>http://domain.yqjdcyy.com/post/idea.java.version/</link>
      <pubDate>Fri, 20 Apr 2018 14:30:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/idea.java.version/</guid>
      <description>[TOC]
Error  Run  Error:java: Compilation failed: internal java compiler error  Install  Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project thinking-in-java: Compilation failure: Compilation failure: xxxx.java:[26,56] -source 1.5 中不支持 diamond 运算符   Fix IDEA.Setting  Project Structure
 快捷键  Ctrl+ Alt+ Shift+ S  设置  project Setting/ Porject  Project SDK-&amp;gt; 1.8 Project language level-&amp;gt; 8 - Lambdas, type annotation etc.  project Setting/ Modules  choice your error modules Sources/ Language level-&amp;gt; 8 - Lambdas, type annotation etc.</description>
    </item>
    
    <item>
      <title>Java.&amp;0xff</title>
      <link>http://domain.yqjdcyy.com/post/java.0xff/</link>
      <pubDate>Fri, 20 Apr 2018 13:30:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.0xff/</guid>
      <description> [TOC]
Code  PipedInputStream.receive(int b)  buffer[in++] = (byte)(b &amp;amp; 0xFF);   Reason 原因  int= 32bits byte= 8bits 截取末 8 bit时，存在将数值位当符号位情况  示例  int-&amp;gt; byte  222 -&amp;gt; -34  222.补码  00000000 00000000 00000000 11011110  截取  11011110  反码  11011101  原码  10100010= -34   解决方案  222* 0xff    Supplement Java 使用 补码 进行数值存储  简化计算机运算，让符号位也参与运算，使计算机设计中只有加法，没有减法 示例  1[00000001] + -1[11111111] = 0[1 00000000]= 0[00000000] 丢弃高位数值   *码  原码  符号位+ 数字二进制表示 +7 [00000111] -7 [10000111]  反码  正数时同原码，负数时，符号位不变，其它位数取反 +7 [00000111] -7 [11111000]  补码  正数时同原码，负数时则为反码+1 +7 [00000111] -7 [11111001]   Reference  java中byte转换int时为何与0xff进行与运算 java原码、补码、反码总结 原码, 反码, 补码 详解  </description>
    </item>
    
    <item>
      <title>Java.Exception</title>
      <link>http://domain.yqjdcyy.com/post/java.exception/</link>
      <pubDate>Wed, 18 Apr 2018 18:00:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.exception/</guid>
      <description>[TOC]
分类 Throwable Exception  ReflectiveOperationException  NoSuchMethodException IllegalAccessException NoSuchFieldException InstantiationException ClassNotFoundException  CloneNotSupportedException InterruptedException  ClassCastException EnumConstantNotPresentException IllegalStateException NullPointException IllegalMonitorStateException IllegalArgumentException  IllegalThreadStateException NumberFormatException  SecurityException  RuntimeException  ArithmeticException TypeNotPresentException IndexOutOfBoundsException  ArrayIndexoutOfBoundsExxception StringIndexoutOfBoundsException  NegativeArraySizeException ArrayStoreException UnsupportedOperationException UnCheckIOException  IOException
 SyncFailedException CharConversionException UnsupportedEncodingException ObjectStreamException  NotSerializableException InvalidObjectException NotActiveException InvalidClassException WriteAbortedException StreamCorruptedException OptionDataException  InterruptedIOException UTFDataFormatException FileNotFoundException EOFException
Error  VirtualMachineError
 InternalError StackOverflowError UnknownError OutOfMemoryError  ThreadDeath</description>
    </item>
    
    <item>
      <title>Java.9.Feature</title>
      <link>http://domain.yqjdcyy.com/post/java.9.feature/</link>
      <pubDate>Thu, 16 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.9.feature/</guid>
      <description>深入解读 Java 9 新特性 参考  深入解读 Java 9 新特性 Java9先睹为快：JShell动手实践 JavaOne 2016——观众得以一睹JShell的威力  Jigsaw  核心 -实现 Java 平台模块化系统 - JPMS (Java Platform Module System)
 针对问题
 易错的 classpath  应用不同部分依赖同一类库的不同版本 ClassLoading 复杂而不明确，导致 ClassNotFoundException、 NoClassDefFoundError 等异常  JDK 过于臃肿，无法按不同需求进行定制或优化  目标
 可靠配置  明确模块边界和模块间的依赖关系  强封装性  通过封装模块内部私有细节，避免不希望发生的依赖关系   拆分 JDK 增强提议 (JEP)
 JEP 261  Module System，实现模块化系统；  JEP 200  The Modular JDK，将JDK自身进行模块化；  JEP 201  Modular Source Code，按照模块化的形式，重构源代码,因为现有代码并不是划分到一个一个的模块里的。  JEP 220  Modular Run-Time Images，重新设计JDK和JRE的结构，定义新的URI scheme操作模块，类和资源（jrt）。  JEP 260  Encapsulate Most Internal APIs，按照模块化封装性的要求，将不希望暴露的内部API封装起来，如果确实证明是广泛需要的，就作为公共API公开出来。  JEP 282  jlink: The Java Linker。新的link工具   模块图</description>
    </item>
    
    <item>
      <title>Java.Native</title>
      <link>http://domain.yqjdcyy.com/post/java.native/</link>
      <pubDate>Thu, 16 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.native/</guid>
      <description> 参考  http://blog.csdn.net/xw13106209/article/details/6989415 http://www.iteye.com/topic/304594  概念  Jni  sun 提供 支持通过与 c/c++ 交互调用系统的相关技术  Jawin  sourceforge 提供基于 Jni 的应用库 支持调用 com 对象，和win32-dll 动态链接库的方法  Jacob  sourceforge 提供 提供调用 microsoft 的 com 对象方法  补充        开发流程  Java 调用类 javah 生成 c/c++ 原生函数头文件 c/c++ 中实现原生函数 将项目依赖的所有*原生库和资源*加入至 java 项目的 java.library.path 生成 java 程序 发布 java 应用和 dll 库  </description>
    </item>
    
    <item>
      <title>Java.泛型</title>
      <link>http://domain.yqjdcyy.com/post/java.%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Thu, 16 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.%E6%B3%9B%E5%9E%8B/</guid>
      <description>[TOC]
泛型 与 C++ 的比较  优点  泛型实现参数化类型 创建泛型的一个实例时，编译器负责转型并保证类型的正确性  缺点  其它语言能做、好做的，java 中却不支持，难以实现  注
 理解泛型的边界！
简单泛型  告诉编译器想使用类型，然后由编译器帮你处理一切细节
 元组：一组对象打包存储于一单一对象
泛型接口 事例
public interface Generator&amp;lt;T&amp;gt; { T next(); }  基本类型无法作为类型参数
泛型方法 事例
public &amp;lt;T&amp;gt; void printClass(T t) { System.out.println(t.getClass().getName()); }  类型推断只对赋值操作有效
泛型内部类 构建复杂模型 类型安全且可管理
擦除的神秘之处 在泛型代码内部，无法获得任何有关泛型参数类型的信息
 T extends class/interface
 于静态类型检查期后，所有泛型类型均被擦除，并替换为其非泛型上界
 List&amp;lt;T&amp;gt; -&amp;gt; List &amp;lt;T&amp;gt; -&amp;gt; Object  使用擦除实现，唯一知道是在使用一个对象
 List&amp;lt;String&amp;gt;= List&amp;lt;Object&amp;gt;= List List&amp;lt;Integer&amp;gt;= List&amp;lt;Object&amp;gt;= List  与 C++ 对比</description>
    </item>
    
    <item>
      <title>Java.Log4j</title>
      <link>http://domain.yqjdcyy.com/post/java.log4j/</link>
      <pubDate>Wed, 15 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.log4j/</guid>
      <description>文件格式 配置根Logger  log4j.rootLogger = [ level ] , appenderName1 , appenderName2 , …  配置日志信息输出目的地 log4j.appender.appenderName = Appender log4j.appender.appenderName. Threshold= DEBUG ##输出DEBUG级别以上的日志 … log4j.appender.appenderName.optionN = valueN  配置日志信息的格式（布局） log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.ConversionPattern = value1 … log4j.appender.appenderName.layout.optionN = valueN  参数 [ level ] - 日志输出级别  FATAL[0] ERROR[3] WARN[4] INFO[6] DEBUG[7]  Appender - 日志输出目的地  org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）  Layout - 日志输出格式  org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.</description>
    </item>
    
    <item>
      <title>Java.注意事项</title>
      <link>http://domain.yqjdcyy.com/post/java.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Wed, 15 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>finally  用于及时释放资源以不影响系统性能，并遵循最晚申请，最早释放原则，就近释放（若在A类一方法中申请到某个资源，应该就在这个方法的末尾将资源释放掉）。  preparedStatement  预编译语句，继承自Statement，用于处理大业务量的数据库操作 正确方法  PreparedStatement ps = con.prepareStatement(&amp;quot;select * from student where stuNo=?&amp;quot;); //!! for(int i=0; i&amp;lt; 1000; i++){ ps.setString(1, &amp;quot;1000&amp;quot;); ResultSet rs = ps.executeQuery(); rs.close(); } ps.close(); //!! //PreparedStatement效率高，但代价是建立在创建对象时付出较大的成本，但是创建后可以通过传入不同的参数重复高效的使用  注意事项  在高频率反复执行同一类业务量的数据处理任务时使用   连接池  为服务器配置连接池，而在配置文件中指定所要连接的数据库和连接个数，便于服务器启动时，首先连接目标数据库创建指定个数的活动连接，并将其放到连接池中。 优点  不同的访问者共享有限的连接，免去了数据库连结的漫长创建过程  类似使用  在线程管理中，为避免线程资源的浪费和提高效率，也可以采用线程池来进行线程的管理   内存管理 引用类型 弱引用  定义  当被弱引用指向的对象除该弱引用之外不再有其他的引用指向这个对象，这个对象即为“弱引用”  回收标准  检查到该弱引用指向的对象，就会将其回收  支持对象  WeakRefrence：弱引用对象 WeakHashMap：专用于管理弱引用集合，消除由于HashMap不释放导致对象数据长期残留于内存的情况</description>
    </item>
    
    <item>
      <title>Java.Basic</title>
      <link>http://domain.yqjdcyy.com/post/java.basic/</link>
      <pubDate>Wed, 09 Aug 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.basic/</guid>
      <description>[TOC]
参考  使用 JDK 5 后的线程并发，Callable, Future, ExecutorServie Lock(重入锁，读写锁)及Condition示例 Java中的锁  功能 获取路径 分类  绝对路径  主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 例  C:xyz est.txt  代表了test.txt文件的绝对路径    相对路径  相对与某个基准目录（一般对照WEB）的路径。 示例  &amp;quot;/&amp;quot;代表Web应用的跟目录 &amp;quot;./&amp;quot; 代表当前目录 &amp;quot;../&amp;quot;代表上级目录   注  JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的   获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&amp;quot;？&amp;quot;) --&amp;gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&amp;quot;\&amp;quot;) //站点绝对路径 application.getRealPath(&amp;quot;&amp;quot;) //JSP界面使用 ServletContext().getRealPath(&amp;quot;&amp;quot;)  返回字串  C:\Apache\Tomcat\webapps\local+ （\ \.</description>
    </item>
    
    <item>
      <title>Java.Command</title>
      <link>http://domain.yqjdcyy.com/post/java.command/</link>
      <pubDate>Wed, 09 Aug 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.command/</guid>
      <description> [TOC]
Javac  作用  将 *.java 源代码转换为 *.class 格式文件  参考  Javac编译原理  事例  目录  D:\workspace\Knowledge_Structure\jni\JNIProxy.java  执行语句  D:\workspace\Knowledge_Structure\jni&amp;gt; javac JNIProxy.java    Javah  作用  生成类中所需的 JNI 头文件  参考  用javah 导出类的头文件， 常见的错误及正确的使用方法  事例  目录  D:\workspace\work4Git\Knowledge_Structure\00.语言\Java\代码\java-study\src\main\java\ com\yao\study\java\jni\JNIProxy.java  类定义  package com.yao.study.java.jni; public class JNIProxy{&amp;hellip;}  执行语句  D:\workspace\work4Git\Knowledge_Structure\00.语言\Java\代码\java-study\src\main\java&amp;gt; javah -o jni_msg.h com.yao.study.java.jni.JNIProxy    </description>
    </item>
    
    <item>
      <title>Java.Detail</title>
      <link>http://domain.yqjdcyy.com/post/java.detail/</link>
      <pubDate>Wed, 09 Aug 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.detail/</guid>
      <description>[TOC]
finally  用于及时释放资源以不影响系统性能 遵循最晚申请，最早释放原则，就近释放  若在A类一方法中申请到某个资源，应该就在这个方法的末尾将资源释放掉   preparedStatement  预编译语句，继承自Statement，用于处理大业务量的数据库操作 效率高，但代价是建立在创建对象时付出较大的成本，但是创建后可以通过传入不同的参数重复高效的使用 示例  PreparedStatement ps = con.prepareStatement(&amp;quot;select * from student where stuNo=?&amp;quot;); //!! for(int i=0; i&amp;lt; 1000; i++){ ps.setString(1, &amp;quot;1000&amp;quot;); ResultSet rs = ps.executeQuery(); rs.close(); } ps.close(); //!!  注  在高频率反复执行同一类业务量的数据处理任务时使用   连接池  为服务器配置连接池，而在配置文件中指定所要连接的数据库和连接个数 便于服务器启动时，首先连接目标数据库创建指定个数的活动连接，并将其放到连接池中 优点  不同的访问者共享有限的连接，免去了数据库连结的漫长创建过程  类似使用  在线程管理中，为避免线程资源的浪费和提高效率，也可以采用线程池来进行线程的管理   内存管理 引用类型 弱引用  当被弱引用指向的对象除该弱引用之外不再有其他的引用指向这个对象，这个对象即为“弱引用” 回收标准  检查到该弱引用指向的对象，就会将其回收  支持对象  WeakRefrence：弱引用对象 WeakHashMap：专用于管理弱引用集合，消除由于HashMap不释放导致对象数据长期残留于内存的情况</description>
    </item>
    
    <item>
      <title>Java.常用技术</title>
      <link>http://domain.yqjdcyy.com/post/java.%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Fri, 09 Dec 2016 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</guid>
      <description>参考  http://unmi.cc/jdk-5-concurrent-callable-futuretask-etc/ http://www.cnblogs.com/wn398/archive/2013/06/15/3130967.html http://ifeve.com/locks/  获取路径 ###分类： - 绝对路径：主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 - 例：C:xyz est.txt 代表了test.txt文件的绝对路径 - 相对路径：相对与某个基准目录（一般对照WEB）的路径。 - 例：&amp;rdquo;/&amp;ldquo;代表Web应用的跟目录， &amp;ldquo;./&amp;rdquo; 代表当前目录,&amp;ldquo;../&amp;ldquo;代表上级目录 - 注：JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的
获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&amp;ldquo;？&amp;rdquo;) &amp;ndash;&amp;gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&amp;rdquo;\&amp;ldquo;) //站点绝对路径 application.getRealPath(&amp;ldquo;&amp;rdquo;) //JSP界面使用 ServletContext().getRealPath(&amp;ldquo;&amp;rdquo;)  返回字串  C:\Apache\Tomcat\webapps\local+ （\ . 空格 \web.xml）   工程Classes下路径（SRC/CLASS）  使用环境  SERVLET/JSP/JAVA（即任意CLASS）  使用语句  this.getClass()/JdomParse.class .getClassLoader().getResource(&amp;ldquo;&amp;rdquo;).getPath(); //注：因为三者均为JAVA程序，都为CLASS，故为三者通用方法 this.getClass()JdomParse.class .getResource(&amp;ldquo;&amp;rdquo;).getPath().toString(); //可用于不同WEB环境来确认路径 Thread.currentThread().getContextClassLoader().getResource(&amp;ldquo;&amp;rdquo;).getPath()  返回字串</description>
    </item>
    
    <item>
      <title>DWR</title>
      <link>http://domain.yqjdcyy.com/post/dwr/</link>
      <pubDate>Thu, 08 Dec 2016 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/dwr/</guid>
      <description>[TOC]
参考  在 Spring Web MVC 环境下使用 DWR  作用  Spring 框架提供，可将 Java 组件方法直接暴露给 JavaScript 客户端 通过将 Spring 容易中的 Bean 转换为 JavaScript 对象  配置 web.xml &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;springServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/dwr/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt;  springmvc.xml &amp;lt;!-- DWR3.0配置 --&amp;gt; &amp;lt;!-- 打开dwr的控制器 --&amp;gt; &amp;lt;dwr:controller id=&amp;quot;dwrController&amp;quot; debug=&amp;quot;true&amp;quot; &amp;gt; &amp;lt;dwr:config-param name=&amp;quot;allowScriptTagRemoting&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt; &amp;lt;dwr:config-param name=&amp;quot;crossDomainSessionSecurity&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt; &amp;lt;dwr:config-param name=&amp;quot;activeReverseAjaxEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;/dwr:controller&amp;gt; &amp;lt;dwr:url-mapping/&amp;gt; &amp;lt;bean class=&amp;quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;alwaysUseFullPath&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;mappings&amp;quot;&amp;gt; &amp;lt;props&amp;gt; &amp;lt;prop key=&amp;quot;/dwr/**/*&amp;quot;&amp;gt;dwrController&amp;lt;/prop&amp;gt; &amp;lt;/props&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!</description>
    </item>
    
  </channel>
</rss>