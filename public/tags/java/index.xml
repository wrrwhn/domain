<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 好久不见</title>
    <link>http://domain.yqjdcyy.com/tags/java/</link>
    <description>Recent content in Java on 好久不见</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Powered by [姚清居](http://www.domain.yqjdcyy.com).</copyright>
    <lastBuildDate>Fri, 20 Apr 2018 13:30:00 +0800</lastBuildDate>
    
	<atom:link href="http://domain.yqjdcyy.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java.&amp;0xff</title>
      <link>http://domain.yqjdcyy.com/post/java.0xff/</link>
      <pubDate>Fri, 20 Apr 2018 13:30:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.0xff/</guid>
      <description> [TOC]
Code  PipedInputStream.receive(int b)  buffer[in++] = (byte)(b &amp;amp; 0xFF);    Reason ԭ��  int= 32bits byte= 8bits ��ȡĩ 8 bitʱ�����ڽ���ֵλ������λ����  ʾ��  int-&amp;gt; byte  222 -&amp;gt; -34  222.����  00000000 00000000 00000000 11011110  ��ȡ  11011110  ����  11011101  ԭ��  10100010= -34   ��������  222* 0xff    Supplement Java ʹ�� ���� ������ֵ�洢  �򻯼��������㣬�÷���λҲ�������㣬ʹ������������ֻ�мӷ���û�м��� ʾ��  1[00000001] + -1[11111111] = 0[1 00000000]= 0[00000000] ������λ��ֵ   *��  ԭ��  ����λ+ ���ֶ����Ʊ�ʾ +7 [00000111] -7 [10000111]  ����  ����ʱͬԭ�룬����ʱ������λ���䣬����λ��ȡ�� +7 [00000111] -7 [11111000]  ����  ����ʱͬԭ�룬����ʱ��Ϊ����+1 +7 [00000111] -7 [11111001]   Reference  java��byteת��intʱΪ����0xff���������� javaԭ�롢���롢�����ܽ� ԭ��, ����, ���� ����  </description>
    </item>
    
    <item>
      <title>Java.Exception</title>
      <link>http://domain.yqjdcyy.com/post/java.exception/</link>
      <pubDate>Wed, 18 Apr 2018 18:00:00 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.exception/</guid>
      <description>[TOC]
分类 Throwable Exception  ReflectiveOperationException  NoSuchMethodException IllegalAccessException NoSuchFieldException InstantiationException ClassNotFoundException  CloneNotSupportedException InterruptedException  ClassCastException EnumConstantNotPresentException IllegalStateException NullPointException IllegalMonitorStateException IllegalArgumentException  IllegalThreadStateException NumberFormatException  SecurityException  RuntimeException  ArithmeticException TypeNotPresentException IndexOutOfBoundsException  ArrayIndexoutOfBoundsExxception StringIndexoutOfBoundsException  NegativeArraySizeException ArrayStoreException UnsupportedOperationException UnCheckIOException  IOException
 SyncFailedException CharConversionException UnsupportedEncodingException ObjectStreamException  NotSerializableException InvalidObjectException NotActiveException InvalidClassException WriteAbortedException StreamCorruptedException OptionDataException  InterruptedIOException UTFDataFormatException FileNotFoundException EOFException
Error  VirtualMachineError
 InternalError StackOverflowError UnknownError OutOfMemoryError  ThreadDeath</description>
    </item>
    
    <item>
      <title>Java.9.Feature</title>
      <link>http://domain.yqjdcyy.com/post/java.9.feature/</link>
      <pubDate>Thu, 16 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.9.feature/</guid>
      <description>深入解读 Java 9 新特性 参考  深入解读 Java 9 新特性 Java9先睹为快：JShell动手实践 JavaOne 2016——观众得以一睹JShell的威力  Jigsaw  核心 -实现 Java 平台模块化系统 - JPMS (Java Platform Module System)
 针对问题
 易错的 classpath  应用不同部分依赖同一类库的不同版本 ClassLoading 复杂而不明确，导致 ClassNotFoundException、 NoClassDefFoundError 等异常  JDK 过于臃肿，无法按不同需求进行定制或优化  目标
 可靠配置  明确模块边界和模块间的依赖关系  强封装性  通过封装模块内部私有细节，避免不希望发生的依赖关系   拆分 JDK 增强提议 (JEP)
 JEP 261  Module System，实现模块化系统；  JEP 200  The Modular JDK，将JDK自身进行模块化；  JEP 201  Modular Source Code，按照模块化的形式，重构源代码,因为现有代码并不是划分到一个一个的模块里的。  JEP 220  Modular Run-Time Images，重新设计JDK和JRE的结构，定义新的URI scheme操作模块，类和资源（jrt）。  JEP 260  Encapsulate Most Internal APIs，按照模块化封装性的要求，将不希望暴露的内部API封装起来，如果确实证明是广泛需要的，就作为公共API公开出来。  JEP 282  jlink: The Java Linker。新的link工具   模块图</description>
    </item>
    
    <item>
      <title>Java.Native</title>
      <link>http://domain.yqjdcyy.com/post/java.native/</link>
      <pubDate>Thu, 16 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.native/</guid>
      <description> 参考  http://blog.csdn.net/xw13106209/article/details/6989415 http://www.iteye.com/topic/304594  概念  Jni  sun 提供 支持通过与 c/c++ 交互调用系统的相关技术  Jawin  sourceforge 提供基于 Jni 的应用库 支持调用 com 对象，和win32-dll 动态链接库的方法  Jacob  sourceforge 提供 提供调用 microsoft 的 com 对象方法  补充        开发流程  Java 调用类 javah 生成 c/c++ 原生函数头文件 c/c++ 中实现原生函数 将项目依赖的所有*原生库和资源*加入至 java 项目的 java.library.path 生成 java 程序 发布 java 应用和 dll 库  </description>
    </item>
    
    <item>
      <title>Java.泛型</title>
      <link>http://domain.yqjdcyy.com/post/java.%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Thu, 16 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.%E6%B3%9B%E5%9E%8B/</guid>
      <description>[TOC]
泛型 与 C++ 的比较  优点  泛型实现参数化类型 创建泛型的一个实例时，编译器负责转型并保证类型的正确性  缺点  其它语言能做、好做的，java 中却不支持，难以实现  注
 理解泛型的边界！
简单泛型  告诉编译器想使用类型，然后由编译器帮你处理一切细节
 元组：一组对象打包存储于一单一对象
泛型接口 事例
public interface Generator&amp;lt;T&amp;gt; { T next(); }  基本类型无法作为类型参数
泛型方法 事例
public &amp;lt;T&amp;gt; void printClass(T t) { System.out.println(t.getClass().getName()); }  类型推断只对赋值操作有效
泛型内部类 构建复杂模型 类型安全且可管理
擦除的神秘之处 在泛型代码内部，无法获得任何有关泛型参数类型的信息
 T extends class/interface
 于静态类型检查期后，所有泛型类型均被擦除，并替换为其非泛型上界
 List&amp;lt;T&amp;gt; -&amp;gt; List &amp;lt;T&amp;gt; -&amp;gt; Object  使用擦除实现，唯一知道是在使用一个对象
 List&amp;lt;String&amp;gt;= List&amp;lt;Object&amp;gt;= List List&amp;lt;Integer&amp;gt;= List&amp;lt;Object&amp;gt;= List  与 C++ 对比</description>
    </item>
    
    <item>
      <title>Java.Log4j</title>
      <link>http://domain.yqjdcyy.com/post/java.log4j/</link>
      <pubDate>Wed, 15 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.log4j/</guid>
      <description>文件格式 配置根Logger  log4j.rootLogger = [ level ] , appenderName1 , appenderName2 , …  配置日志信息输出目的地 log4j.appender.appenderName = Appender log4j.appender.appenderName. Threshold= DEBUG ##输出DEBUG级别以上的日志 … log4j.appender.appenderName.optionN = valueN  配置日志信息的格式（布局） log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.ConversionPattern = value1 … log4j.appender.appenderName.layout.optionN = valueN  参数 [ level ] - 日志输出级别  FATAL[0] ERROR[3] WARN[4] INFO[6] DEBUG[7]  Appender - 日志输出目的地  org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）  Layout - 日志输出格式  org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.</description>
    </item>
    
    <item>
      <title>Java.注意事项</title>
      <link>http://domain.yqjdcyy.com/post/java.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Wed, 15 Nov 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>finally  用于及时释放资源以不影响系统性能，并遵循最晚申请，最早释放原则，就近释放（若在A类一方法中申请到某个资源，应该就在这个方法的末尾将资源释放掉）。  preparedStatement  预编译语句，继承自Statement，用于处理大业务量的数据库操作 正确方法  PreparedStatement ps = con.prepareStatement(&amp;quot;select * from student where stuNo=?&amp;quot;); //!! for(int i=0; i&amp;lt; 1000; i++){ ps.setString(1, &amp;quot;1000&amp;quot;); ResultSet rs = ps.executeQuery(); rs.close(); } ps.close(); //!! //PreparedStatement效率高，但代价是建立在创建对象时付出较大的成本，但是创建后可以通过传入不同的参数重复高效的使用  注意事项  在高频率反复执行同一类业务量的数据处理任务时使用   连接池  为服务器配置连接池，而在配置文件中指定所要连接的数据库和连接个数，便于服务器启动时，首先连接目标数据库创建指定个数的活动连接，并将其放到连接池中。 优点  不同的访问者共享有限的连接，免去了数据库连结的漫长创建过程  类似使用  在线程管理中，为避免线程资源的浪费和提高效率，也可以采用线程池来进行线程的管理   内存管理 引用类型 弱引用  定义  当被弱引用指向的对象除该弱引用之外不再有其他的引用指向这个对象，这个对象即为“弱引用”  回收标准  检查到该弱引用指向的对象，就会将其回收  支持对象  WeakRefrence：弱引用对象 WeakHashMap：专用于管理弱引用集合，消除由于HashMap不释放导致对象数据长期残留于内存的情况</description>
    </item>
    
    <item>
      <title>Java.Basic</title>
      <link>http://domain.yqjdcyy.com/post/java.basic/</link>
      <pubDate>Wed, 09 Aug 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.basic/</guid>
      <description>[TOC]
参考  使用 JDK 5 后的线程并发，Callable, Future, ExecutorServie Lock(重入锁，读写锁)及Condition示例 Java中的锁  功能 获取路径 分类  绝对路径  主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 例  C:xyz est.txt  代表了test.txt文件的绝对路径    相对路径  相对与某个基准目录（一般对照WEB）的路径。 示例  &amp;quot;/&amp;quot;代表Web应用的跟目录 &amp;quot;./&amp;quot; 代表当前目录 &amp;quot;../&amp;quot;代表上级目录   注  JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的   获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&amp;quot;？&amp;quot;) --&amp;gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&amp;quot;\&amp;quot;) //站点绝对路径 application.getRealPath(&amp;quot;&amp;quot;) //JSP界面使用 ServletContext().getRealPath(&amp;quot;&amp;quot;)  返回字串  C:\Apache\Tomcat\webapps\local+ （\ \.</description>
    </item>
    
    <item>
      <title>Java.Command</title>
      <link>http://domain.yqjdcyy.com/post/java.command/</link>
      <pubDate>Wed, 09 Aug 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.command/</guid>
      <description> [TOC]
Javac  作用  将 *.java 源代码转换为 *.class 格式文件  参考  Javac编译原理  事例  目录  D:\workspace\Knowledge_Structure\jni\JNIProxy.java  执行语句  D:\workspace\Knowledge_Structure\jni&amp;gt; javac JNIProxy.java    Javah  作用  生成类中所需的 JNI 头文件  参考  用javah 导出类的头文件， 常见的错误及正确的使用方法  事例  目录  D:\workspace\work4Git\Knowledge_Structure\00.语言\Java\代码\java-study\src\main\java\ com\yao\study\java\jni\JNIProxy.java  类定义  package com.yao.study.java.jni; public class JNIProxy{&amp;hellip;}  执行语句  D:\workspace\work4Git\Knowledge_Structure\00.语言\Java\代码\java-study\src\main\java&amp;gt; javah -o jni_msg.h com.yao.study.java.jni.JNIProxy    </description>
    </item>
    
    <item>
      <title>Java.Detail</title>
      <link>http://domain.yqjdcyy.com/post/java.detail/</link>
      <pubDate>Wed, 09 Aug 2017 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.detail/</guid>
      <description>[TOC]
finally  用于及时释放资源以不影响系统性能 遵循最晚申请，最早释放原则，就近释放  若在A类一方法中申请到某个资源，应该就在这个方法的末尾将资源释放掉   preparedStatement  预编译语句，继承自Statement，用于处理大业务量的数据库操作 效率高，但代价是建立在创建对象时付出较大的成本，但是创建后可以通过传入不同的参数重复高效的使用 示例  PreparedStatement ps = con.prepareStatement(&amp;quot;select * from student where stuNo=?&amp;quot;); //!! for(int i=0; i&amp;lt; 1000; i++){ ps.setString(1, &amp;quot;1000&amp;quot;); ResultSet rs = ps.executeQuery(); rs.close(); } ps.close(); //!!  注  在高频率反复执行同一类业务量的数据处理任务时使用   连接池  为服务器配置连接池，而在配置文件中指定所要连接的数据库和连接个数 便于服务器启动时，首先连接目标数据库创建指定个数的活动连接，并将其放到连接池中 优点  不同的访问者共享有限的连接，免去了数据库连结的漫长创建过程  类似使用  在线程管理中，为避免线程资源的浪费和提高效率，也可以采用线程池来进行线程的管理   内存管理 引用类型 弱引用  当被弱引用指向的对象除该弱引用之外不再有其他的引用指向这个对象，这个对象即为“弱引用” 回收标准  检查到该弱引用指向的对象，就会将其回收  支持对象  WeakRefrence：弱引用对象 WeakHashMap：专用于管理弱引用集合，消除由于HashMap不释放导致对象数据长期残留于内存的情况</description>
    </item>
    
    <item>
      <title>Java.常用技术</title>
      <link>http://domain.yqjdcyy.com/post/java.%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Fri, 09 Dec 2016 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/java.%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</guid>
      <description>参考  http://unmi.cc/jdk-5-concurrent-callable-futuretask-etc/ http://www.cnblogs.com/wn398/archive/2013/06/15/3130967.html http://ifeve.com/locks/  获取路径 ###分类： - 绝对路径：主页上的文件或目录在硬盘上真正的路径，如URL和物理路径 - 例：C:xyz est.txt 代表了test.txt文件的绝对路径 - 相对路径：相对与某个基准目录（一般对照WEB）的路径。 - 例：&amp;rdquo;/&amp;ldquo;代表Web应用的跟目录， &amp;ldquo;./&amp;rdquo; 代表当前目录,&amp;ldquo;../&amp;ldquo;代表上级目录 - 注：JSP/SERVLET中的比较特殊，服务器端的地址服务器端的相对地址指的是相对于你的web应用的地址，因为该地址是由服务器端解析聘的
获取方法 JSP路径/系统全路径  使用环境  SERVLET/JSP  使用语句  request.getRealPath(&amp;ldquo;？&amp;rdquo;) &amp;ndash;&amp;gt; ？为/ . 空格 web.xml request.getRealPath(request.getRequestURI()); getServletContext().getRealPath(&amp;rdquo;\&amp;ldquo;) //站点绝对路径 application.getRealPath(&amp;ldquo;&amp;rdquo;) //JSP界面使用 ServletContext().getRealPath(&amp;ldquo;&amp;rdquo;)  返回字串  C:\Apache\Tomcat\webapps\local+ （\ . 空格 \web.xml）   工程Classes下路径（SRC/CLASS）  使用环境  SERVLET/JSP/JAVA（即任意CLASS）  使用语句  this.getClass()/JdomParse.class .getClassLoader().getResource(&amp;ldquo;&amp;rdquo;).getPath(); //注：因为三者均为JAVA程序，都为CLASS，故为三者通用方法 this.getClass()JdomParse.class .getResource(&amp;ldquo;&amp;rdquo;).getPath().toString(); //可用于不同WEB环境来确认路径 Thread.currentThread().getContextClassLoader().getResource(&amp;ldquo;&amp;rdquo;).getPath()  返回字串</description>
    </item>
    
    <item>
      <title>DWR</title>
      <link>http://domain.yqjdcyy.com/post/dwr/</link>
      <pubDate>Thu, 08 Dec 2016 22:07:46 +0800</pubDate>
      
      <guid>http://domain.yqjdcyy.com/post/dwr/</guid>
      <description>[TOC]
参考  在 Spring Web MVC 环境下使用 DWR  作用  Spring 框架提供，可将 Java 组件方法直接暴露给 JavaScript 客户端 通过将 Spring 容易中的 Bean 转换为 JavaScript 对象  配置 web.xml &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;springServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/dwr/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt;  springmvc.xml &amp;lt;!-- DWR3.0配置 --&amp;gt; &amp;lt;!-- 打开dwr的控制器 --&amp;gt; &amp;lt;dwr:controller id=&amp;quot;dwrController&amp;quot; debug=&amp;quot;true&amp;quot; &amp;gt; &amp;lt;dwr:config-param name=&amp;quot;allowScriptTagRemoting&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt; &amp;lt;dwr:config-param name=&amp;quot;crossDomainSessionSecurity&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt; &amp;lt;dwr:config-param name=&amp;quot;activeReverseAjaxEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;/dwr:controller&amp;gt; &amp;lt;dwr:url-mapping/&amp;gt; &amp;lt;bean class=&amp;quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;alwaysUseFullPath&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;mappings&amp;quot;&amp;gt; &amp;lt;props&amp;gt; &amp;lt;prop key=&amp;quot;/dwr/**/*&amp;quot;&amp;gt;dwrController&amp;lt;/prop&amp;gt; &amp;lt;/props&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;!</description>
    </item>
    
  </channel>
</rss>